{
    "original_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time. They are filled with autonomous, mutable virtual content which is continuously augmented by the users. To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds. In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium. In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability. Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting. We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query. Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments. The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination. We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization. We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future. Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1. INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments. Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side. To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability. In this paper, we mainly focus on the first two requirements. Dynamic extensibility allows regular game-users to deploy their own created content. This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems. Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers. Another important requirement is scalability. Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world. By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported. Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3]. Second Life [4] is the first successfully deployed MMOG system that meets both requirements. To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform. But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5]. In this model, a server continuously transmits both update events and geometry data to every connected user. As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space. One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user. The traditional visibility determination approach, however, has an object popping problem. For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a). As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b). If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience. The visibility calculation for each user not only needs to be accurate, but also fast. This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds. To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing). Our two novel methods represent the main contributions of this work. The organization of this paper is as follows. Section 2 presents related work. Section 3 describes our new view method. In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations. We also discuss its optimization issues. Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments. Finally, we conclude and address future research directions in Section 7. 2. RELATED WORK Visibility determination has been widely explored in the field of 3D graphics. Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline. View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6]. However, these algorithms assume that all the candidate visible objects have been stored locally. If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases. Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5]. Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7]. However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments. On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities. In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users. Here we recognize that such graphics related issues have a very close similarity to spatial database problems. Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments. To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing. The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR). The grid-based partitioning model is a special case of fixed partitioning. Recently, it has been re-discovered since it can be efficient in highly dynamic environments. Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12]. A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism. Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table. Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments. In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely. The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree. SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries. Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently. Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects. As long as any object resides in this region, all the query results are guaranteed to be valid in the system. If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly. Our indexing method is very similar to the above approaches. The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3. OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model. We then propose our own model, and finally we discuss its strengths and limitations. To begin with, we define the terminologies commonly used throughout this paper. Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars. The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities. The spectator entity corresponds to a players viewpoint, but is invisible to other entities. It has no shape and is represented only by a point location. It is designed to allow a game participant to see from a third-person viewpoint. It functions similar to a camera control in the 3D graphics field. It also has a higher degree of mobility than other entities. The avatar represents a normal game user who can freely navigate in the space and interact with other entities. It possesses both features: its own viewpoint and visibility. For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity. The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence. It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility. Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other. To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity. Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area. However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world. The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not. As the user navigates, she continuously searches for all the entities within her AOI. Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model. However, the user-initiated model has a serious object popping problem during navigation. Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely. A large AOI, however, may lead to a significant system degradation. To overcome the object popping problem, we propose a new view model which we call object-initiated view model. All object entities have their own AOI centered at their current location while all spectator entities have no AOI. Every user entity recognizes the objects whose AOIs cover its point location. The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes. A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure. One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view. We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model. To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4. Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time. For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 . Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image. In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4. DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model. Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4. Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting. The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world. Second Life is the classic example of such an approach. A virtual space is partitioned into equal-sized sub-worlds. The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A. As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI. Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure). The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R. Every sub-world is managed by its dedicated server machine. Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities. For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells. Figure 2 shows the 4 × 4 grid enclosed by the dashed lines. Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells. Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2. There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in. This retrieval process is interchangeably called a user (or query) evaluation. Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved. Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell. In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell. Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell. Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell. We also define two data structures for storing and retrieving the tokens: a node and an edge. A node is a data structure that stores ITs of a cell. Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region. An edge is another data structure for two adjacent cells that stores their ATs or DTs. If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE). The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j. The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ). Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10]. To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing. Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query. In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location. For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query. Due to the use of a simple point geometry for entities, this allows for lightweight index updates. Much of the existing work falls into this category. However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead. For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case. One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13]. For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a). Every cell stores IT entities that intersect with its region. Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid. Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures. With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated. In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures. If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M). Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2. Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures. If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1. The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2. Lemma 1. Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information. Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25. To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing. Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated. Generally, this is done through a twostep algorithm [13] that works as follows. The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step). After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user. After all the cells are evaluated, the algorithm starts over. The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations. In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures. Let us assume that the system maintains the row-wise edges. The leftmost node structures are assumed to be obtained in advance. Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges. We repeat this computation until we reach the rightmost cell. Hence, without any column-wise edges we can obtain all the node structures successfully. As a result, we reduce the complexity of the index construction and update by a factor of two. Figure 3(c) illustrates the concept of our row-wise edge indexing method. The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT). The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells. In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2. As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}. E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}. Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}. If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. The above calculation also corresponds to our intuition. P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4. When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged. Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set. Obviously, edge indexing is inefficient for indexing a point geometry. Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement. Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case. In such a situation, we take advantage of using both according to the spatial property of entity extension. In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas. Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation. Let us assume that an edge index is realized with a hash table. Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant. However, the token removal time depends on the expected number of tokens per hash bucket. Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities. Two-table edge indexing is designed to make the token removal overhead constant. First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties. Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq). It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance. It is represented by the number of cell units. structures. If an entity is not moving, its tokens will be placed in a stationary edge structure. Otherwise, it will be placed with a moving edge. Second, all moving edge structures are periodically reconstructed. After the reconstruction, all grid cells are evaluated to compute their visible sets. Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows. As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities. A singly linked list implementation is used for the moving edge structure. 5. ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time. In this analysis, we assume that node and edge structures are implemented with hash tables. For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan. Their processing costs are denoted by Ta, Td, and Ts, respectively. A token scan operation reads the tokens in a hash bucket sequentially. It is extensively used during cell evaluations. Ts and Td are a function of the number of tokens in the bucket while Ta is constant. For the purpose of analysis, we define two random variables. One variable, denoted by mo, represents the side length of the AOI of an entity o. The side lengths are uniformly distributed in the range of [mmin, mmax]. The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval. The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v]. For a simple calculation, both random variables are expressed as the number of cell units. Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities. Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities. Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects. Table 2 summarizes these results. In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing. Different grid cell partitioning with edge methods will lead to different memory requirements. For example, here are two grids: a M × M grid and a 2M × 2M grid. The memory requirement for the user entities is unchanged because it depends only on the total number of user entities. The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid. Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations. For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance. Similar to edge indexing, node indexing has two update policies: full update and incremental update. Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes. The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period. In this analysis, we only consider incremental node indexing. To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5. We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O. As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0). If an object resides in the same cell, there will be no update. If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0). The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed. Roughly speaking, its worst-case processing cost is the same as Tedgefull per update . Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3. In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)). However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2). Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta. Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods. The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v). The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation. After the lookup, Td executes the reverse operation of Ta. Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets. From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing. Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI. In this figure we assume that the average side length of the AOI is 0.1 (or 10 %). The node indexing method, however, depends not only on the side length but also on the reachable distance. Thus the entity update in node indexing is much heavier than the full update for edge indexing. As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node. Therefore, it would take |Q|×Ts to scan all user entities. If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1). In this analysis, we do not consider any data delivery overhead after a cell evaluation. Note that in single-table edge indexing we need to scan all the tokens for cell evaluations. Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation. Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation. Table 4 shows the expected complexities of different cell evaluation scenarios. If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|). However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations. In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing. The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement. First of all, Td is very predictable and a more lightweight procedure than Td. All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant. In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing. Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform. Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific. The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9. Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second. Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6. EVALUATION This section presents two simulation setups and their performance results. Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity. Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15]. P is the ratio of relevant, retrieved items to all retrieved items. A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client. A higher P value means a higher network traffic load than required. R is the ratio of relevant, retrieved items to all relevant items. A lower R value means that more objects that should be recognized are ignored. From the R measure, we can quantitatively estimate the occurrence of object popping. In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15]. The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important. If β is less than 1, P becomes more important. Otherwise, R will affect the E-measure significantly. A lower E-measure value implies that the tested view model has a higher quality. The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI. PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}. RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}. Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing. If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes. Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell. Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result. It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well. Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1). The populated entities are uniformly located in the unit space. The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space. The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP. We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range. A smaller side length leads to higher accuracy but lower comprehensiveness. For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%. Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client. But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered. Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects. To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation. E-measure Distribution: Figure 8 reveals two trends. First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR. Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR. It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR. Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model. We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme. We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes. While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI. As expected, fine-grained grid partitioning showed a smaller E-measure value. The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths. As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP. From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment. As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation. To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell. We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory. We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update. However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal. Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist. Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments. However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment. Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput. In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP. Figure 8: E-measure value as a function of Precision value P when β = 1. Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes. Exhaustive search methods do not maintain any intermediate results. They simply compute whether a given user point is inside a given object AOI. They can tolerate unpredictable behavior of object movement. In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination. Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude. As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI. Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally. Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7. CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing. Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity. Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations. However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain. Currently, we are developing another edge indexing method to make the indexing complexity constant. Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data. We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8. REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech. Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput. Graph. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib. Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411",
    "original_translation": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411",
    "error_count": 9,
    "keys": {
        "edge indexing": {
            "translated_key": [
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde"
            ],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la \"indexación de bordes\" siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) \"indexación de bordes\" (c) \"indexación de bordes\" con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, \"indexación de bordes\", está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con \"indexación de bordes\" deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, na Índice de borde almacena más tokens que la indexación de nodo - el número total de tokens de borde que se muestra en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la \"indexación de borde\" original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra \"indexación de borde\" actualizando las estructuras de borde de las entidades que se desplazaron durante el período de tiempo anterior y aplicando Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de \"indexación de bordes\" en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de \"indexación de borde\" de dos entidades de punto {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la \"indexación de bordes\" es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de \"indexación de bordes\" utiliza estructuras de borde para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección, describimos varias técnicas de optimización para la \"indexación de bordes\", lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La \"indexación de borde\" de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, \"indexación de borde\", y \"indexación de borde\" de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La \"indexación de bordes\" de una sola mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. Dos mesas de \"indexación de borde\" ocupa s · Uq unidades para los usuarios y s{ ÈiÃ3O 2(mi+1)+ ÈjÃ3(U−O) 2(mj +1)} Ã r 2s(m+1)U unidades para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. método de indexación entidades de objetos entidades de nodos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Similar a \"indexación de bordes\", la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental Q  O · v(v+1){v(4m+3−v) El tiempo esperado de cualquier actualización de entidad única para la \"indexación de borde\" con actualización completa es: T edgefull por actualización = ÈoÃO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la \"indexación de borde\" con actualización incremental se complica porque el costo del tiempo depende tanto de la En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la \"indexación de borde\" en el peor de los casos (una tabla de \"indexación de borde\" con política de actualización completa) depende sólo de m, la de la indexación de nodo en el mejor de los casos (indexación de nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la \"indexación de borde\" de dos tablas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de una sola tabla de \"indexación de borde\" toma al menos el doble de tiempo que la actualización de dos tablas de \"indexación de borde\". La Figura 6 muestra que la actualización completa de la \"indexación de borde\" cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de borde correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la \"indexación de bordes\". Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en una sola tabla de \"indexación de borde\" tenemos que escanear todos los tokens para las evaluaciones de celdas. La \"indexación de borde\" de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de \"indexación de bordes\". 5.2.3 Juntarlo: Coste de monitoreo periódico Como vimos en la sección 5.2.1, métodos de \"indexación de bordes\" superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la \"indexación de borde\" de una sola tabla y la \"indexación de borde\" de dos tablas. El tiempo total transcurrido de la \"indexación de borde\" basada en la actualización completa para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones celulares: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la \"indexación de borde\" de dos tablas es el siguiente: (Ta + Td + En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la actualización completa de una sola tabla \"indexación de borde\". Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la \"indexación de bordes\". Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de \"indexación de borde\" en C y ejecutamos los experimentos en un procesador de Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de \"indexación de bordes\" variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de \"indexación de bordes\" incremental supera la actualización completa de \"indexación de bordes\", debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de \"indexación de borde\" de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, \"indexación de bordes\". Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Sin embargo, nuestro modelo de \"indexación de bordes\" puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrículas y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra \"indexación de bordes\" aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de \"indexación de bordes\" para hacer constante la complejidad de la indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra \"indexación de borde\" pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de borde",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de bordes",
                "indexación de borde"
            ]
        },
        "dynamic virtual environment": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        },
        "game-based application": {
            "translated_key": "aplicación basada en juegos",
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de \"aplicación basada en juegos\" como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                ""
            ]
        },
        "mutable virtual content": {
            "translated_key": "mutable",
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Se llenan de contenido virtual autónomo, \"mutable\" que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                ""
            ]
        },
        "spatial database": {
            "translated_key": "base de datos espacial",
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de \"base de datos espacial\", y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una \"base de datos espacial\" mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que tales problemas relacionados con gráficos tienen una similitud muy cercana a los problemas de la \"base de datos espacial\". Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                ""
            ]
        },
        "spatial indexing method": {
            "translated_key": "método de indexación espacial",
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo \"método de indexación espacial\" diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                ""
            ]
        },
        "real-time visibility test": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        },
        "object-initiated view model": {
            "translated_key": [
                "modelo de vista iniciado por objetos",
                "modelo de vista iniciado por el usuario",
                "modelo de vista iniciado por el objeto",
                "modelo de visión iniciado por objetos"
            ],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos \"modelo de vista iniciado por objetos\". Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un \"modelo de vista iniciado por el usuario\" o un \"modelo de vista iniciado por el objeto\": • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computation de visibilidad orientada a objetos - PQ-OR: Point Query - Region - RQ-OR: Region Query - PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad dinámica y la escalabilidad en entornos altamente dinámicos, se propuso un nuevo paradigma de visión, el \"modelo de visión iniciado por objetos\", y su método eficiente de indexación, indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                "modelo de vista iniciado por objetos",
                "modelo de vista iniciado por el usuario",
                "modelo de vista iniciado por el objeto",
                "modelo de visión iniciado por objetos"
            ]
        },
        "object popping": {
            "translated_key": [
                "aparición de objetos",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente"
            ],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice el inesperado \"aparición de objetos\" y apoye la determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. El enfoque tradicional de determinación de visibilidad, sin embargo, tiene un problema de \"objeto emergente\". Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema de \"objeto emergente\" puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de \"objeto emergente\" durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema de \"objeto emergente\", proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema de \"objeto emergente\" siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y que (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia de \"objeto emergente\". Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de \"objeto emergente\", la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de \"objeto emergente\" que se pueda observar fácilmente en entornos virtuales existentes a expensas de una mayor complejidad de indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                "aparición de objetos",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente",
                "objeto emergente"
            ]
        },
        "3d spatial extension": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        },
        "3d object stream": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        },
        "object pop problem": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        },
        "spatial index": {
            "translated_key": "índice espacial",
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura eficiente de \"índice espacial\" que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una conocida estructura de \"índice espacial\" que permite la superposición entre las regiones en diferentes ramas que están representadas por Mínimo Rectángulos Bounding (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": [
                ""
            ]
        },
        "visibility model": {
            "translated_key": [],
            "translated_annotated_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments* Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 RESUMEN Los nuevos sistemas de aplicación basados en juegos como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y extensibles dinámicamente, generalmente se construyen en una división subespacial basada en el servidor-cliente donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos móviles de servidores conectados remotamente y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan a la capacidad y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy difícil ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, y por lo tanto mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este trabajo es presentar una estructura de índice espacial eficiente que minimice la aparición inesperada de objetos y permita una determinación de visibilidad altamente escalable en tiempo real. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura del índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse en los servicios existentes basados en la web en un futuro próximo. Categorías y Subject Descriptores: C.2.4 [Computer - Redes de Comunicación]: Sistemas distribuidos - Cliente/servidor, Aplicaciones distribuidas, Bases de datos distribuidas; I.3.7 [Gráficas de Computación]: Gráficos y Realismo de tres dimensiones - Realidad Virtual Términos generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en línea multijugador masivo (MMOGs) han sido estudiados como un marco para entornos virtuales de próxima generación. Muchas aplicaciones MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde su complejidad de escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderización en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea sin fisuras, interminables e ilimitados, Marshall et al. [1] identificó cuatro nuevos requisitos2 : extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque el número de usuarios concurrentes aumenta, el sistema sigue funcionando eficazmente); interactividad; e interoperabilidad. En este documento, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos implementar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El pleno apoyo a la extensibilidad dinámica seguirá siendo, por lo tanto, uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden apoyar a cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicando mundos en ubicaciones geográficamente dispersas, se puede soportar un gran número de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo gestionado por un solo servidor o un grupo de servidores se limita a varios miles, asumiendo un mundo bastante estacionario [2, 3]. Second Life [4] es el primer sistema MMOG desplegado con éxito que cumple ambos requisitos. Para mitigar la dinámica del mundo del juego, donde un gran número de objetos autónomos se mueven continuamente, se divide el espacio de una manera similar a la cuadrícula y 2 Originalmente, estos requisitos fueron especificados para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el momento t (b) En el momento t+ Figura 1: El estallido de objetos ocurrió cuando un usuario se mueve hacia adelante (imagenes de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de streaming de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente tanto eventos de actualización como datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado el despliegue de contenidos creados por el usuario y ofrece a los usuarios una libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las operaciones principales en las aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de la visibilidad tiene un problema de aparición de objetos. Por ejemplo, una casa fuera de un rango visible de usuarios no se dibuja en el momento t, ilustrado en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, esto perturbará la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no sólo necesita ser preciso, sino también rápido. Este desafío queda ilustrado por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifique los objetos visibles más relevantes de una determinada base de datos de geometría (modelo de vista) y luego propusimos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización del presente documento es la siguiente. En la sección 2 se presentan los trabajos conexos. La sección 3 describe nuestro nuevo método de visión. En la Sección 4, presentamos suposiciones sobre nuestra aplicación de destino e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La sección 5 informa sobre el análisis cuantitativo y la sección 6 presenta los resultados preliminares de nuestros experimentos basados en la simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. TRABAJO RELACIONADO La determinación de visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos de renderización locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de renderización. Las técnicas conocidas de selección de la visibilidad [6] son la selección de la vista-frustum, la de la cara posterior y la de la oclusión. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para renderizar desde las bases de datos del servidor. Teller et al. describe un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de fotogramas a lo largo del tiempo en recorridos remotos de escenas 3D complejas de una ruta de navegación de los usuarios [5]. Funkhouser et al. mostró que la representación multi-resolución, como Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de representación del marco y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no abordan el problema de rendimiento en el servidor en entornos muy concurridos. Por otro lado, nuestro modelo de computación de visibilidad, representativo de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo en el apoyo a los cálculos de visibilidad en tiempo real para un gran número de objetos en movimiento y usuarios. Aquí reconocemos que estos problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de la base de datos espaciales. Recientemente, varias publicaciones han abordado la cuestión de la escalabilidad sobre cómo apoyar un gran número de objetos y consultas en entornos altamente dinámicos. Para soportar actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en árboles-R y (2) indexación espacial basada en cuadrículas. El árbol-R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos Bounding Mínimo (MBR). El modelo de partición basado en cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol-R y sus variantes (árbol R+, R* -árbol) sufren de degradación del rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo arriba propuesta para R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para peticiones frecuentes de actualización (enfoque de arriba hacia abajo), accede directamente al nodo de hoja del objeto a actualizar a través de una tabla de hash de objeto. Q-Index [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en cuadrícula para entornos de objetos en movimiento emergentes. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice sobre los objetos en movimiento, construye un índice sobre las consultas de rango continuo, asumiendo que las consultas se mueven con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación de los objetos cuasiestacionarios y los objetos móviles: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R* -tree. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/movientes y consultas estacionarias/movientes. Específicamente, este enfoque solo detecta actualizaciones de objetos recién descubiertos (positivos) o que ya no son relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de la evaluación de la consulta, Hu et al. [12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación manteniendo un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto resida en esta región, todos los resultados de la consulta están garantizados para ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser entregadas al servidor de base de datos y las consultas afectadas se reevaluan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos estamos concentrando más en la determinación de la visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo suelto. 3. MODELO DE VISTA INITIADO DE OBJETO En esta sección ilustramos cómo el problema del estallido de objetos puede ser asociado con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas a lo largo de este trabajo. Las entidades en un espacio virtual pueden clasificarse en tres tipos 403 según su rol: entidades autónomas, entidades de espectadores y avatares. El término entidad autónoma se refiere a un objeto geométrico ordinario en movimiento o estacionario que puede ser visible para otras entidades. La entidad espectadora corresponde a un punto de vista de los jugadores, pero es invisible a otras entidades. No tiene forma y está representado sólo por un punto de ubicación. Está diseñado para permitir que un participante del juego vea desde un punto de vista de tercera persona. Funciona de manera similar a un control de cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto usamos el término entidad objeto para referirse a una entidad autónoma o a un avatar, mientras que usamos la entidad usuario para denotar una entidad avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la hipótesis de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y cada usuario posee la misma visibilidad. Así, el usuario y el objeto, sólo cuando su distancia actual es menor o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un Área de Interés circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios rápidos de dirección sin interrupciones de visualización en la periferia del área visible. Sin embargo, empleamos un AOI en forma cuadrada a expensas de la precisión porque la extensión espacial en forma cuadrada es muy simple y eficiente para ser indexado en un mundo dividido en cuadrícula. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño sencillo y a su bajo nivel de indexación, muchos servicios basados en ubicaciones (LBS) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de aparición de objetos durante la navegación. Recordemos, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + Δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t. De hecho, resultó que la longitud lateral de su AOI era menor que la distancia óptima entre el usuario y la casa en el momento t. Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo Sin embargo, una AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema del estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objeto. Todas las entidades objeto tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades espectadoras no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema con el estallido de objetos siempre y cuando el sistema subyacente pueda manejar el rango visible óptimo de todas las entidades objeto correctamente y (2) los creadores de contenido puedan producir una expresividad enriquecida de varios cambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño; un objeto tiene un rango visible más amplio durante el día que durante la noche; incluso durante la noche el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto se encuentra dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la vista iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la vista iniciada por el usuario. Acordamos E2 E1 Un cliente S Cliente S Un servidor Sub-world Figura 2: Sistema de destino en una partición de cuadrícula de 4 × 4. que los métodos de indexación espacial existentes son ineficientes para apoyar nuestro modelo de visión. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del papel nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de visión no pretende rivalizar con un sofisticado algoritmo de decisión de visibilidad como el sacrificio de visibilidad [6], sino filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de visión y discutimos los resultados de la simulación. 4. DISEÑO DE INDEXACIÓN DE EDGE En la Sección 4.1 presentamos nuestro modelo de aplicación de destino. A continuación, la sección 4.2 presenta una abstracción de nuestras estructuras de nodos y bordes cuyos métodos detallados de indización y evaluación celular se explican más adelante en las secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de bordes siguen en la Sección 4.5. 4.1 Aplicación de destino Nuestra aplicación de destino asume la transmisión de objetos en 3D y el alojamiento en el submundo. El alojamiento sub-mundo es un entorno virtual colaborativo donde cada servidor alberga un sub-mundo, construyendo así un mundo único. Segunda Vida es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de igual tamaño. El submundo de muestra separado con líneas en negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma cuadrada. Dos entidades usuarias (S, A) están asociadas con máquinas clientes individuales, (cliente S y cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 se puede simbolizar como S.P.E.R. Cada sub-mundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para una gestión eficiente de las entidades en movimiento, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula de 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D es trabajo en curso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) a) indexación de nodos (b) indexación de bordes (c) indexación de bordes con evaluación de celdas en fila Figura 3: Ilustración de diferentes estructuras de datos para la Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A} en el mundo. librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se llama indistintamente una evaluación de usuario (o consulta). Nuestra aplicación sólo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápidamente se reconocen y recuperan las actualizaciones de los índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: Inclusion Token (IT) indica que su entidad se superpone con o está cubierta por la celda dada. Apariencia Token (AT) denota que su entidad es una TI para la celda dada, pero no para la celda previamente adyacente. Desaparición Token (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación IT con la célula dada, lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena TI de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de TI y formalmente expresado como Ni = {oo.Ri.R =, donde R es una AOI o una región celular. Un borde es otra estructura de datos para dos células adyacentes que almacenan sus ATs o DTs. Si el borde sólo almacena las entidades AT, se denomina borde de apariencia (AE); de lo contrario, si almacena DTs, se denomina borde de desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni • Nj ) (1) donde Ni y Nj son las estructuras de los nodos para las células i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DTs, satisfaciendo: E−(i, j) = Ni − (Ni) (2) En un mapa en 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican además como en ambas filas, si dos vecinos son adyacentes horizontalmente (Er ), o columna, si son adyacentes verticalmente (Ec ). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j), y Ec −(i, j). 4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para la indexación de entidades móviles en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro nuevo método propuesto, llamamos indexación de nodos a todos los métodos de indexación basados en la cuadrícula existentes. La indexación del nodo divide el espacio en subespacios de tamaño equi (células de red), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda desde las estructuras de los nodos de las células cuya región se intersecta con la extensión espacial de la consulta de rango. Gracias al uso de una geometría simple de puntos para entidades, esto permite actualizaciones de índices ligeros. Gran parte de la labor existente corresponde a esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costosa actualización de los gastos generales. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de cuadrícula requiere 100 deleciones de token y 100 inserciones de token, en el peor de los casos. Uno de los métodos populares de indexación de nodos, la Indización de consultas, ha sido reportado como tal degradación del rendimiento durante la actualización de las consultas de rango en forma de rectángulo [13]. Para el espacio de muestra mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se cruzan con su región. Proceso de consulta para el espectador S significa buscar la estructura del nodo cuya región celular se intersecta con S. En la Figura 3(a), E2 es indexado en la misma celda, siendo así entregado al cliente S después de la evaluación de la consulta. 4.4 Indización de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidad y evaluación celular. 4.4.1 Idea Edge Structure La principal característica de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodos. Con este enfoque, se eliminan las TI redundantes entre dos celdas adyacentes (Ni-Nj ). En un mapa de cuadrícula 2D M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 células externas) y ocho estructuras de borde diferentes. Si las dos primeras células vecinas son horizontalmente adyacentes a i y las dos últimas células (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i + La figura 3 b) ilustra cómo se construyen las estructuras de borde a partir de estructuras de nodos, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos de las estructuras de borde. Si cualquier estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo tal como se define por Lemma 1. La prueba de Lemma 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lemma 1. Nj, un conjunto de ITs de una celda dada j puede derivarse de un conjunto de ITs de su celda vecina i, Ni y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Estructuras de borde de fila y columna, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na â € € TM ave almacena más tokens que la indexación de nodo - el número total de tokens de borde mostrado en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para la indexación de nodo en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos a la indexación de bordes original. Actualización periódica de entidades y evaluación de celdas Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona como sigue. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de los nodos de cada celda (el paso de evaluación de celdas). Después de la evaluación de una celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo computarizado para cada cliente asociado con un usuario. Después de que todas las células sean evaluadas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de bordes mediante la actualización de las estructuras de bordes de las entidades que se desplazaron durante el período de tiempo anterior y mediante la aplicación de Lemma 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lemma también revela otra propiedad importante de las evaluaciones de celdas: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de los nodos. Supongamos que el sistema mantiene los bordes de la fila. Se supone que las estructuras de los nodos más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda a la derecha desde la estructura del nodo más a la izquierda y los bordes de la fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes de columna podemos obtener todas las estructuras de nodos con éxito. Como resultado, se reduce la complejidad de la construcción del índice y se actualiza por un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes en fila. El número total de fichas se reduce a 17 (8 AT + 8 DT + 1 IT). El análisis detallado de su complejidad de indización se presenta en la Sección 5. 4.4.2 Otro ejemplo La figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos celdas adyacentes en sentido de fila 3 y 4 tienen dos transiciones de borde en sentido de fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3,4) se obtiene de la Ecuación 1: N4 − (N3 N4) = {P1}. De manera similar, E−(3, 4) = N3 − Célula 3 Célula 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en sentido de fila. (N3 N4) = {P2, R1}. Si conocemos N3, E+(3, 4), y E−(3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4)- E−(3, 4) = {P1, R2}. El cálculo anterior corresponde también a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparece y P1 aparece de nuevo mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de bordes es ineficiente para indexar una geometría de puntos. La indexación del nodo tiene una IT por entidad de punto y requiere una eliminación de token y una inserción en cualquier movimiento de ubicación. La indexación del borde, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de bordes para las entidades habilitadas AOI (A, E1, E2) mientras que utiliza estructuras de nodos para la entidad de puntos (S). 4.5 Problemas de optimización En esta sección se describen varias técnicas de optimización para la indexación de bordes, lo que reduce significativamente la complejidad del algoritmo. 4.5.1 Enfoque de una sola mesa: Actualización Normalmente, existen dos políticas prácticas para una actualización de la región: Full Update simplemente elimina todos los símbolos de la región de la entidad anterior y reinserta los tokens recién actualizados en las áreas recientemente posicionadas. La actualización incremental sólo elimina los tokens cuya relación espacial con las células cambió al actualizarse y los inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. 4.5.2 Enfoque de dos mesas: Separación de entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de la eliminación de tokens durante la operación de actualización. Supongamos que un índice de borde se realiza con una tabla de hash. La inserción de un token se implementa insertándolo en la cabeza del cubo de hachís correspondiente, por lo que el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo de hachís. Por lo tanto, la aplicación de hash puede sufrir una sanción importante del sistema cuando se utiliza con un gran número de entidades pobladas. La indexación de borde de dos mesas está diseñada para hacer constante la eliminación de tokens. En primer lugar, dividimos una estructura de borde único que indiza tanto entidades estacionarias como en movimiento en dos bordes separados 406 Tabla 1: Resumen de las anotaciones para entidades virtuales y sus propiedades. Signatura Significado U conjunto de entidades de objetos pobladas O conjunto de entidades de objetos móviles, O  U Uq conjunto de entidades de usuarios pobladas Q conjunto de entidades de usuarios móviles, Q  Uq Un conjunto de avatares, A = {aa • U • Uq} i.P ubicación de la entidad i donde i • (U • Uq) i.R AOI de entidad Está representado por el número de unidades celulares. m longitud media del lado AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima accesible. Está representado por el número de unidades celulares. estructuras. Si una entidad no se mueve, sus fichas se colocarán en una estructura estacionaria de borde. De lo contrario, se colocará con un borde móvil. En segundo lugar, todas las estructuras de borde móvil se reconstruyen periódicamente. Después de la reconstrucción, todas las celdas de la red se evalúan para calcular sus conjuntos visibles. Una vez evaluadas todas las células, se destruyen los bordes móviles y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móvil ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Para la estructura de borde móvil se utiliza una implementación de lista vinculada individualmente. 5. ANÁLISIS Analizamos tres esquemas de indización cuantitativa (indización de nodo, indexación de borde e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas de hash. Para las manipulaciones de tablas de hash asumimos tres funciones de acceso a la memoria: inserción de tokens, eliminación de tokens y exploración de tokens. Sus costos de procesamiento son denotados por Ta, Td y Ts, respectivamente. Una operación de exploración de tokens lee los tokens en un cubo de hash secuencialmente. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras Ta es constante. Para fines de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor medio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima x-direccional o ydireccional de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token sea denotado por s. Node indexing uses s · Uq unidades de memoria para entidades de usuario y s · ÈoU (mo + 1)2 فارسى s(m2 + 2m + 1 + V ar(mo))U unidades para entidades de objeto. La indexación de bordes de una mesa consume unidades de almacenamiento s · Uq para las entidades usuarias y s · ÈoâU 2 (mo + 1) • 2s(m + 1)U para las entidades objeto. La indexación de borde de dos mesas ocupa unidades s · Uq para los usuarios y unidades s{ ÈiÃ3O 2 (mi+1)+ ÈjÃ3(U−O) 2 (mj +1)} • 2s(m+1)U para los objetos. En el cuadro 2 se resumen estos resultados. En nuestra apTabla 2: Requisitos de memoria de diferentes métodos de indexación. Método de indexación de entidades de objetos entidades de objetos s · Uq s(m + 1)2 + V ar(mo))U borde de una tabla s · Uq 2s(m + 1)U borde de dos mesas s · Uq 2s(m + 1)U aplicación, nuestros métodos de indexación de bordes consumen Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula 2M × 2M. El requisito de memoria para las entidades usuarias no cambia porque depende únicamente del número total de entidades usuarias. Los requisitos de memoria para las entidades objeto son aproximadamente 2s(m + 1)U en el caso de la cuadrícula M × M y 2s(2m + 1)U para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces mayor llevará a un número aproximadamente dos veces menor de tokens. 5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad en tiempo de ejecución de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de actualización Asumimos que un conjunto de objetos móviles O y un conjunto de usuarios móviles Q se conocen de antemano. Al igual que la indexación de bordes, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevos. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, sólo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad en movimiento, cuya ubicación previa estaba en la celda(0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v), como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral de la AOI de los objetos en el sistema, es decir, v < mo donde o O. Como se ve en la Figura 5, la siguiente ubicación puede clasificarse en tres categorías: áreas A, B y el área de la célula central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) mo + 1) − ij inserciones y eliminaciones de tokens, donde 1 ≤ i, j ≤ v. De lo contrario, habrá inserciones y eliminaciones de tokens de k(mo + 1), donde 1 ≤ k ≤ v. Así, el tiempo de procesamiento esperado de una actualización de un objeto para la indexación de 407 Tabla 3: Actualización del costo de tiempo para cualquier evento de actualización individual donde v < mq, mo y q • Q. indexing method consultations ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) nodo indexación con actualización incremental Q  O · v(v+1){v(4m+3−v)+ La hora esperada de cualquier actualización de entidad única para la indexación de borde con actualización completa es: T edgefull por actualización = ÈoO T edgefull por actualización (o) O = 2 m + 1 (Ta + Td) (5) El análisis del tiempo esperado de cualquier actualización de entidad única para la indexación de borde con actualización incremental se complica porque el costo del tiempo depende tanto de la longitud En términos aproximados, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, sólo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o o O es más pequeño que mo: Tedgeincremental per update = Èo»,v<mo Tedgeincremental per update (o) O = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) En esta tabla, es evidente que si bien el costo de actualización de la indexación del borde del peor caso (indexación del borde de una tabla con política de actualización completa) depende sólo de m, el de la indexación del nodo del mejor caso (indexación del nodo con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor menor de v (v = 1), el costo de actualización de la indexación Sin embargo, a medida que v aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 frente a 2 m + 1), donde v = 2). Otro resultado interesante es que la indexación de borde de dos mesas depende sólo del costo de inserción de tokens, Ta. Típicamente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima alcanzable (v) (%) #deAfectedTokens Dos Tablas Indización de borde Indización de borde incremental Indización de borde completo Indización de nodo incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de token por actualización de objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral media del objeto AOIs es el 10% de la longitud lateral de un mapa 2-D dado. mayor que Ta porque Td requiere al menos una operación de búsqueda de fichas. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Así, Td bien puede ser expresado como (Ta + Tlookup) y puede ser simplificado como (Ta + E 2·b ·Ts) donde E es el tamaño de la estructura del borde y b es el número de sus cubos de hachís. De esta observación, podemos inferir que la actualización completa de la indexación de borde de una tabla toma al menos el doble de tiempo que la actualización para la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad en movimiento toma tiempo constante para actualizar las estructuras de bordes correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura suponemos que la longitud media lateral del AOI es de 0,1 (o 10 %). El método de indexación de nodos, sin embargo, depende no sólo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y absorciones de tokens mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante. 5.2.2 Evaluación celular La indexación del nodo de coste escanea todas las entidades y luego recoge las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, se necesitaría QTs para escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))O M2 entidades objeto en promedio, el tiempo de finalización esperado de una celda de evaluación será entonces ÈoÃ3O (m2 +2m+1+V ar(mo))O M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será Q · (m2 +2m+1+V ar(mo))O M2 · Ts. La complejidad del tiempo de funcionamiento de la evaluación celular de una sola mesa puede 408 Tabla 4: Resumen del costo de la evaluación celular. Se simplificará el método de indización esperado de los nodos de tiempo transcurridos Ts · Q · (m2 +2m+1+V ar(mo))O M2 borde de una tabla Ts · (Q + O · 2 m + 1)) borde de dos mesas (Ts + Td) · (Q + En este análisis, no consideramos ningún gasto general de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de borde de dos mesas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados computados previamente se reutilizan durante la siguiente ronda de evaluación, el tiempo esperado de indización de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))O). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces mayor que la de cualquier método de indexación de bordes. 5.2.3 Juntarlo: Costo de monitoreo periódico Como vimos en la sección 5.2.1, los métodos de indexación de bordes superan la indexación de nodos en términos de actualizaciones y evaluaciones celulares. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una mesa y la indexación de borde de dos mesas. El tiempo total transcurrido de la actualización completa basada en la indexación de bordes de una tabla para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · Q + O2(m + 1)} (7) Del mismo modo, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los gastos generales de manipulación de la estructura de datos, como Ta, Ts y Td, se pueden perfilar fácilmente y todos se vuelven constantes. Además, la indexación bitable está garantizada para superar la indexación completa de borde de actualización de una sola mesa. Otra novedad del enfoque de dos mesas es que es altamente resistente a la distribución de datos subyacente, independientemente de si es altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, Q, O, y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, O, Q, y m son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real dada T. Así, el rendimiento del sistema - cuántos objetos móviles y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. Máximo rendimiento del sistema = Q + O2(m + 1) = T T Ts + Ta + Td (9) Por ejemplo, si un submundo dado sólo está lleno de avatares en movimiento, A = Q = O, cuya longitud lateral media es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0,42 microsegundos por evaluación de token Cada avatar puede navegar libremente por el sub-mundo y el mismo número de clientes conectados remotamente reciben continuamente los últimos eventos de actualización. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. En la sección 6.1 se examina si nuestro nuevo enfoque de visión es superior a los modelos de visión existentes, a pesar de su mayor complejidad de indización. En la sección 6.2 se analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de visión. 6.1 Justificación de la vista iniciada por el objeto Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de la consulta, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recall (R), que estiman el grado de precisión y exhaustividad de un determinado conjunto de resultados [15]. P es la relación de los artículos recuperados pertinentes a todos los artículos recuperados. Un valor menor de P implica que el conjunto de resultados de consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta que la requerida. R es la relación entre los artículos pertinentes recuperados y todos los artículos pertinentes. Un valor R menor significa que se ignoran más objetos que deben ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del estallido de objeto. Además de las métricas P y R, utilizamos una métrica de evaluación de consulta de un solo valor estandarizada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menos de 1, P se vuelve más importante. De lo contrario, R afectará significativamente a la medida E. Un valor de medición E menor implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de medición E es cero, donde los mejores valores para P y R son ambos. 6.1.2 Configuración de simulación Hemos probado cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o un modelo iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Region Query - Object Point • Computación de visibilidad orientada a objetos - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - ACQ-OR: A PQ-OR recoge un conjunto de objetos cuyo AOI se intersecta con un punto de usuario dado, formalmente {oq.P  o.R}. RQ-OR, un esquema de computación imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {oo.R  q.R =. Por último, ACQ-OR, un modelo de computación de visibilidad aproximada, es un esquema especial diseñado para la partición espacial basada en cuadrícula, que es nuestra elección de metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas alicatadas y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuyos AOI 409 Tabla 5: Cálculos P y R de diferentes esquemas de determinación de visibilidad. Esquema P RQ-OP oo.P q.Rq.P o.R) oo.P o.Ro.P o.Ro.P o.Ro.P o.Ro.P o.Ro.R = 1 RQ-OR oo.P Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que satisface la condición c.R. O.R. = • donde la celda c satisface q.P • c.R. también. Nuestro programa de simulación pobló entidades de objetos de 100K y entidades de usuarios de 10K en un espacio de unidad 2D, [0, 1) × [0, 1). Las entidades pobladas están situadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0,05, 0,14], lo que significa un 5% a 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos de forma exhaustiva y calcula los valores P, R y E-measure (que se muestran en la Tabla 5). 6.1.3 Resultados experimentales Distribución de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero menor exhaustividad. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos el 5%. Por lo tanto, todos los objetos recuperados por RQ-OP están garantizados para ser prestados en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, sufriendo así de demasiados objetos faltantes que deben ser renderizados. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, que puede incurrir en una degradación significativa del sistema. E-measure Distribución: La Figura 8 revela dos tendencias. En primer lugar, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (100 × 100 grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a medida E de RQ-OR muestra semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, que transmite que ACQ-OR hereda las propiedades de RQ-OR. Efecto de diferentes tamaños de cuadrícula: La Figura 9 muestra la diferencia estadística de los valores de medición E de siete esquemas de partición de cuadrícula diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un gráfico de Boxand-Whisker para mostrar tanto los valores medios como las varianzas de las distribuciones de E-measure y los valores atípicos de cada esquema. También extraemos el valor medio de las medidas E de RQ-OP (línea verde) a efectos de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están muy concentrados en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como era de esperar, la partición de cuadrícula de grano fino mostró un menor valor de medición E. El sistema RQ-OP mostró una variación más amplia de su calidad que otros sistemas, que se puede atribuir en gran medida a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR se mejora más evidentemente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula 20×20 tenía una mejor medida E Tabla 6: Tiempo transcurrido medido (segundos) de objetos en movimiento de 100K y usuarios en movimiento de 10K en un entorno en movimiento lento (v = 1). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de objetos móviles de 100K y usuarios móviles de 10K en un entorno altamente dinámico (v = 15). indexación Actualización Tiempo Evaluación Tiempo Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Valor de dos tablas 1.75 0.93 2.68 en un entorno priorizado que en un entorno priorizado igual. Como resultado, podemos anticipar que al menos la partición 20×20 de celdas de cuadrícula recupera una mayor calidad de conjuntos visibles que el RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualización de todas las entidades móviles y conjuntos visibles de computación para cada celda. También experimentamos con diferentes políticas de partición de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas. 6.2.1 Configuración de simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits 900MHz con 8 GB de memoria. Implementamos un mecanismo de mesa de hash generalizado para almacenar estructuras de nodo y borde. 6.2.2 Resultados experimentales Coste de seguimiento periódico: los cuadros 6 y 7 muestran los números de rendimiento de los diferentes métodos de indexación de bordes, variando v. La velocidad de movimiento de las entidades también se asignó de manera uniforme entre 0 y v. En un entorno en movimiento lento (cuadro 6), el método de indexación de bordes incrementales supera la indexación de bordes de actualización completa, debido a la reducción de las actualizaciones de índices; el enfoque de dos Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una tabla debido a su eliminación de token secuencial. La Tabla 7 ejemplifica el tiempo transcurrido de actualizaciones de índices y evaluaciones de celdas en un ambiente altamente dinámico donde objetos en movimiento lento y dinámico coexisten. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos en movimiento subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única se reduce en comparación con la del entorno en movimiento lento. Efecto de diferentes tamaños de cuadrícula: ¿Cuántas actualizaciones de objetos y evaluaciones de celdas pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de computación de visibilidad diferentes: dos métodos de búsqueda exhaustiva basados en computación; y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula. 410 0,1 0,2 0,3 0,4 0,6 0,7 0,8 0,9 1 0,1 0,2 0,3 0,5 0,6 0,7 0,8 0,9 1 Llamamiento (R) Precisión (P) 5% Consulta de rango 6% Consulta de rango 7% Consulta de rango 8% Consulta de rango 9% Consulta de rango 10% Consulta de rango 11% Consulta de rango 12% Consulta de rango 13% Consulta de rango 14% Consulta de rango Optimidad 0 0.1 0,3 0,4 0,6 0,8 0, Figura 8: Valor de medición E en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición E en función del esquema de partición de cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 Número de actualizaciones de objetos (10K consultas) TotalTiempo transcurrido(segundos) Población Tamaño = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Indización de borde de dos tablas 100x100 Indización de borde de dos tablas 50x50 Los métodos de búsqueda exhaustivos no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar un comportamiento impredecible del movimiento del objeto. A pesar de su simple diseño y extensibilidad, sufren de largos retrasos computacionales para completar la determinación de la visibilidad. La Figura 10 revela la diferencia de desempeño entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral media del objeto AOI. Debido a que la longitud lateral está representada por unidades celulares, un aumento en el número de células aumenta proporcionalmente las longitudes laterales. La figura 10 ilustra que los resultados de la simulación medida corresponden aproximadamente a la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJO FUTURO Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de visión, el modelo de vista iniciado por objetos, y su método de indexación eficiente, la indexación de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de aparición de objetos que se pueda observar fácilmente en entornos virtuales existentes a expensas del aumento de la complejidad de la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar una complejidad de indexación tan alta mediante la indexación de extensiones espaciales a nivel de borde no a nivel de nodo en un submundo dividido en cuadrícula y fue validado mediante análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestra indexación de bordes aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer constante la complejidad de indexación. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. 8. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone, y T. Ward, Challeges en diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, y Yanghee Choi, Charaterísticas de tráfico de un juego de rol en línea masivamente multijugador y sus implicaciones, en NetGames 05, Oct 2005. [4] Philip Rosedale y Cory Ondrejka, Enable player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, Transmisión de complejas escenas en 3D para recorridos remotos., Comput. Gráfico. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para la renderización remota, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, algoritmo de visualización adaptativa para velocidades de fotograma interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, y K. Teo, Apoyo a actualizaciones frecuentes en árboles-r: Un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, y Susanne E. Hambrusch, Evaluación de memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, no. 2, pp. 117 a 135, 2004. [12] Haibo Hu, Jianliang Xu, y Dik Lun Lee, Un marco genérico para el monitoreo de consultas espaciales continuas sobre objetos en movimiento., en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, y S. Hambrusch, indexación de preguntas e indexación de velocidad limitada: Técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de información, 2a edición, Dept. de Informática, Universidad de Glasgow, 1979. 411 ",
            "error": []
        }
    }
}