{
    "original_text": "Self-interested Automated Mechanism Design and Implications for Optimal Combinatorial Auctions∗ Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu ABSTRACT Often, an outcome must be chosen on the basis of the preferences reported by a group of agents. The key difficulty is that the agents may report their preferences insincerely to make the chosen outcome more favorable to themselves. Mechanism design is the art of designing the rules of the game so that the agents are motivated to report their preferences truthfully, and a desirable outcome is chosen. In a recently proposed approach-called automated mechanism design-a mechanism is computed for the preference aggregation setting at hand. This has several advantages, but the downside is that the mechanism design optimization problem needs to be solved anew each time. Unlike the earlier work on automated mechanism design that studied a benevolent designer, in this paper we study automated mechanism design problems where the designer is self-interested. In this case, the center cares only about which outcome is chosen and what payments are made to it. The reason that the agents preferences are relevant is that the center is constrained to making each agent at least as well off as the agent would have been had it not participated in the mechanism. In this setting, we show that designing optimal deterministic mechanisms is NP-complete in two important special cases: when the center is interested only in the payments made to it, and when payments are not possible and the center is interested only in the outcome chosen. We then show how allowing for randomization in the mechanism makes problems in this setting computationally easy. Finally, we show that the payment-maximizing AMD problem is closely related to an interesting variant of the optimal (revenuemaximizing) combinatorial auction design problem, where the bidders have best-only preferences. We show that here, too, designing an optimal deterministic auction is NPcomplete, but designing an optimal randomized auction is easy. Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics General Terms Algorithms, Economics, Theory 1. INTRODUCTION In multiagent settings, often an outcome must be chosen on the basis of the preferences reported by a group of agents. Such outcomes could be potential presidents, joint plans, allocations of goods or resources, etc. The preference aggregator generally does not know the agents preferences a priori. Rather, the agents report their preferences to the coordinator. Unfortunately, an agent may have an incentive to misreport its preferences in order to mislead the mechanism into selecting an outcome that is more desirable to the agent than the outcome that would be selected if the agent revealed its preferences truthfully. Such manipulation is undesirable because preference aggregation mechanisms are tailored to aggregate preferences in a socially desirable way, and if the agents reveal their preferences insincerely, a socially undesirable outcome may be chosen. Manipulability is a pervasive problem across preference aggregation mechanisms. A seminal negative result, the Gibbard-Satterthwaite theorem, shows that under any nondictatorial preference aggregation scheme, if there are at least 3 possible outcomes, there are preferences under which an agent is better off reporting untruthfully [10, 23]. (A preference aggregation scheme is called dictatorial if one of the agents dictates the outcome no matter what preferences the other agents report.) What the aggregator would like to do is design a preference aggregation mechanism so that 1) the self-interested agents are motivated to report their preferences truthfully, and 2) the mechanism chooses an outcome that is desirable from the perspective of some objective. This is the classic setting of mechanism design in game theory. In this paper, we study the case where the designer is self-interested, that is, the designer does not directly care about how the out132 come relates to the agents preferences, but is rather concerned with its own agenda for which outcome should be chosen, and with maximizing payments to itself. This is the mechanism design setting most relevant to electronic commerce. In the case where the mechanism designer is interested in maximizing some notion of social welfare, the importance of collecting the agents preferences is clear. It is perhaps less obvious why they should be collected when the designer is self-interested and hence its objective is not directly related to the agents preferences. The reason for this is that often the agents preferences impose limits on how the designer chooses the outcome and payments. The most common such constraint is that of individual rationality (IR), which means that the mechanism cannot make any agent worse off than the agent would have been had it not participated in the mechanism. For instance, in the setting of optimal auction design, the designer (auctioneer) is only concerned with how much revenue is collected, and not per se with how well the allocation of the good (or goods) corresponds to the agents preferences. Nevertheless, the designer cannot force an agent to pay more than its valuation for the bundle of goods allocated to it. Therefore, even a self-interested designer will choose an outcome that makes the agents reasonably well off. On the other hand, the designer will not necessarily choose a social welfare maximizing outcome. For example, if the designer always chooses an outcome that maximizes social welfare with respect to the reported preferences, and forces each agent to pay the difference between the utility it has now and the utility it would have had if it had not participated in the mechanism, it is easy to see that agents may have an incentive to misreport their preferences-and this may actually lead to less revenue being collected. Indeed, one of the counterintuitive results of optimal auction design theory is that sometimes the good is allocated to nobody even when the auctioneer has a reservation price of 0. Classical mechanism design provides some general mechanisms, which, under certain assumptions, satisfy some notion of nonmanipulability and maximize some objective. The upside of these mechanisms is that they do not rely on (even probabilistic) information about the agents preferences (e.g., the Vickrey-Clarke-Groves (VCG) mechanism [24, 4, 11]), or they can be easily applied to any probability distribution over the preferences (e.g., the dAGVA mechanism [8, 2], the Myerson auction [18], and the Maskin-Riley multi-unit auction [17]). However, the general mechanisms also have significant downsides: • The most famous and most broadly applicable general mechanisms, VCG and dAGVA, only maximize social welfare. If the designer is self-interested, as is the case in many electronic commerce settings, these mechanisms do not maximize the designers objective. • The general mechanisms that do focus on a selfinterested designer are only applicable in very restricted settings-such as Myersons expected revenue maximizing auction for selling a single item, and Maskin and Rileys expected revenue maximizing auction for selling multiple identical units of an item. • Even in the restricted settings in which these mechanisms apply, the mechanisms only allow for payment maximization. In practice, the designer may also be interested in the outcome per se. For example, an auctioneer may care which bidder receives the item. • It is often assumed that side payments can be used to tailor the agents incentives, but this is not always practical. For example, in barter-based electronic marketplaces-such as Recipco, firstbarter.com, BarterOne, and Intagio-side payments are not allowed. Furthermore, among software agents, it might be more desirable to construct mechanisms that do not rely on the ability to make payments, because many software agents do not have the infrastructure to make payments. In contrast, we follow a recent approach where the mechanism is designed automatically for the specific problem at hand. This approach addresses all of the downsides listed above. We formulate the mechanism design problem as an optimization problem. The input is characterized by the number of agents, the agents possible types (preferences), and the aggregators prior distributions over the agents types. The output is a nonmanipulable mechanism that is optimal with respect to some objective. This approach is called automated mechanism design. The automated mechanism design approach has four advantages over the classical approach of designing general mechanisms. First, it can be used even in settings that do not satisfy the assumptions of the classical mechanisms (such as availability of side payments or that the objective is social welfare). Second, it may allow one to circumvent impossibility results (such as the Gibbard-Satterthwaite theorem) which state that there is no mechanism that is desirable across all preferences. When the mechanism is designed for the setting at hand, it does not matter that it would not work more generally. Third, it may yield better mechanisms (in terms of stronger nonmanipulability guarantees and/or better outcomes) than classical mechanisms because the mechanism capitalizes on the particulars of the setting (the probabilistic information that the designer has about the agents types). Given the vast amount of information that parties have about each other today, this approach is likely to lead to tremendous savings over classical mechanisms, which largely ignore that information. For example, imagine a company automatically creating its procurement mechanism based on statistical knowledge about its suppliers, rather than using a classical descending procurement auction. Fourth, the burden of design is shifted from humans to a machine. However, automated mechanism design requires the mechanism design optimization problem to be solved anew for each setting. Hence its computational complexity becomes a key issue. Previous research has studied this question for benevolent designers-that wish to maximize, for example, social welfare [5, 6]. In this paper we study the computational complexity of automated mechanism design in the case of a self-interested designer. This is an important setting for automated mechanism design due to the shortage of general mechanisms in this area, and the fact that in most e-commerce settings the designer is self-interested. We also show that this problem is closely related to a particular optimal (revenue-maximizing) combinatorial auction design problem. 133 The rest of this paper is organized as follows. In Section 2, we justify the focus on nonmanipulable mechanisms. In Section 3, we define the problem we study. In Section 4, we show that designing an optimal deterministic mechanism is NP-complete even when the designer only cares about the payments made to it. In Section 5, we show that designing an optimal deterministic mechanism is also NP-complete when payments are not possible and the designer is only interested in the outcome chosen. In Section 6, we show that an optimal randomized mechanism can be designed in polynomial time even in the general case. Finally, in Section 7, we show that for designing optimal combinatorial auctions under best-only preferences, our results on AMD imply that this problem is NP-complete for deterministic auctions, but easy for randomized auctions. 2. JUSTIFYING THE FOCUS ON NONMANIPULABLE MECHANISMS Before we define the computational problem of automated mechanism design, we should justify our focus on nonmanipulable mechanisms. After all, it is not immediately obvious that there are no manipulable mechanisms that, even when agents report their types strategically and hence sometimes untruthfully, still reach better outcomes (according to whatever objective we use) than any nonmanipulable mechanism. This does, however, turn out to be the case: given any mechanism, we can construct a nonmanipulable mechanism whose performance is identical, as follows. We build an interface layer between the agents and the original mechanism. The agents report their preferences (or types) to the interface layer; subsequently, the interface layer inputs into the original mechanism the types that the agents would have strategically reported to the original mechanism, if their types were as declared to the interface layer. The resulting outcome is the outcome of the new mechanism. Since the interface layer acts strategically on each agents behalf, there is never an incentive to report falsely to the interface layer; and hence, the types reported by the interface layer are the strategic types that would have been reported without the interface layer, so the results are exactly as they would have been with the original mechanism. This argument is known in the mechanism design literature as the revelation principle [16]. (There are computational difficulties with applying the revelation principle in large combinatorial outcome and type spaces [7, 22]. However, because here we focus on flatly represented outcome and type spaces, this is not a concern here.) Given this, we can focus on truthful mechanisms in the rest of the paper. 3. DEFINITIONS We now formalize the automated mechanism design setting. Definition 1. In an automated mechanism design setting, we are given: • a finite set of outcomes O; • a finite set of N agents; • for each agent i, 1. a finite set of types Θi, 2. a probability distribution γi over Θi (in the case of correlated types, there is a single joint distribution γ over Θ1 × . . . × ΘN ), and 3. a utility function ui : Θi × O → R; 1 • An objective function whose expectation the designer wishes to maximize. There are many possible objective functions the designer might have, for example, social welfare (where the designer seeks to maximize the sum of the agents utilities), or the minimum utility of any agent (where the designer seeks to maximize the worst utility had by any agent). In both of these cases, the designer is benevolent, because the designer, in some sense, is pursuing the agents collective happiness. However, in this paper, we focus on the case of a self-interested designer. A self-interested designer cares only about the outcome chosen (that is, the designer does not care how the outcome relates to the agents preferences, but rather has a fixed preference over the outcomes), and about the net payments made by the agents, which flow to the designer. Definition 2. A self-interested designer has an objective function given by g(o) + N i=1 πi, where g : O → R indicates the designers own preference over the outcomes, and πi is the payment made by agent i. In the case where g = 0 everywhere, the designer is said to be payment maximizing. In the case where payments are not possible, g constitutes the objective function by itself. We now define the kinds of mechanisms under study. By the revelation principle, we can restrict attention to truthful, direct revelation mechanisms, where agents report their types directly and never have an incentive to misreport them. Definition 3. We consider the following kinds of mechanism: • A deterministic mechanism without payments consists of an outcome selection function o : Θ1 × Θ2 × . . . × ΘN → O. • A randomized mechanism without payments consists of a distribution selection function p : Θ1 × Θ2 × . . . × ΘN → P(O), where P(O) is the set of probability distributions over O. • A deterministic mechanism with payments consists of an outcome selection function o : Θ1 ×Θ2 ×. . .×ΘN → O and for each agent i, a payment selection function πi : Θ1 × Θ2 × . . . × ΘN → R, where πi(θ1, . . . , θN ) gives the payment made by agent i when the reported types are θ1, . . . , θN . 1 Though this follows standard game theory notation [16], the fact that the agent has both a utility function and a type is perhaps confusing. The types encode the various possible preferences that the agent may turn out to have, and the agents type is not known to the aggregator. The utility function is common knowledge, but because the agents type is a parameter in the agents utility function, the aggregator cannot know what the agents utility is without knowing the agents type. 134 • A randomized mechanism with payments consists of a distribution selection function p : Θ1 × Θ2 × . . . × ΘN → P(O), and for each agent i, a payment selection function πi : Θ1 × Θ2 × . . . × ΘN → R.2 There are two types of constraint on the designer in building the mechanism. 3.1 Individual rationality (IR) constraints The first type of constraint is the following. The utility of each agent has to be at least as great as the agents fallback utility, that is, the utility that the agent would receive if it did not participate in the mechanism. Otherwise that agent would not participate in the mechanism-and no agents participation can ever hurt the mechanism designers objective because at worst, the mechanism can ignore an agent by pretending the agent is not there. (Furthermore, if no such constraint applied, the designer could simply make the agents pay an infinite amount.) This type of constraint is called an IR (individual rationality) constraint. There are three different possible IR constraints: ex ante, ex interim, and ex post, depending on what the agent knows about its own type and the others types when deciding whether to participate in the mechanism. Ex ante IR means that the agent would participate if it knew nothing at all (not even its own type). We will not study this concept in this paper. Ex interim IR means that the agent would always participate if it knew only its own type, but not those of the others. Ex post IR means that the agent would always participate even if it knew everybodys type. We will define the latter two notions of IR formally. First, we need to formalize the concept of the fallback outcome. We assume that each agents fallback utility is zero for each one of its types. This is without loss of generality because we can add a constant term to an agents utility function (for a given type), without affecting the decision-making behavior of that expected utility maximizing agent [16]. Definition 4. In any automated mechanism design setting with an IR constraint, there is a fallback outcome o0 ∈ O where, for any agent i and any type θi ∈ Θi, we have ui(θi, o0) = 0. (Additionally, in the case of a self-interested designer, g(o0) = 0.) We can now to define the notions of individual rationality. Definition 5. Individual rationality (IR) is defined by: • A deterministic mechanism is ex interim IR if for any agent i, and any type θi ∈ Θi, we have E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, .., θN ))−πi(θ1, .., θN )] ≥ 0. A randomized mechanism is ex interim IR if for any agent i, and any type θi ∈ Θi, we have E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,..,θn [ui(θi, o)−πi(θ1, .., θN )] ≥ 0. • A deterministic mechanism is ex post IR if for any agent i, and any type vector (θ1, . . . , θN ) ∈ Θ1 × . . . × ΘN , we have ui(θi, o(θ1, . . . , θN )) − πi(θ1, . . . , θN ) ≥ 0. 2 We do not randomize over payments because as long as the agents and the designer are risk neutral with respect to payments, that is, their utility is linear in payments, there is no reason to randomize over payments. A randomized mechanism is ex post IR if for any agent i, and any type vector (θ1, . . . , θN ) ∈ Θ1 × . . . × ΘN , we have Eo|θ1,..,θn [ui(θi, o) − πi(θ1, .., θN )] ≥ 0. The terms involving payments can be left out in the case where payments are not possible. 3.2 Incentive compatibility (IC) constraints The second type of constraint says that the agents should never have an incentive to misreport their type (as justified above by the revelation principle). For this type of constraint, the two most common variants (or solution concepts) are implementation in dominant strategies, and implementation in Bayes-Nash equilibrium. Definition 6. Given an automated mechanism design setting, a mechanism is said to implement its outcome and payment functions in dominant strategies if truthtelling is always optimal even when the types reported by the other agents are already known. Formally, for any agent i, any type vector (θ1, . . . , θi, . . . , θN ) ∈ Θ1 × . . . × Θi × . . . × ΘN , and any alternative type report ˆθi ∈ Θi, in the case of deterministic mechanisms we have ui(θi, o(θ1, . . . , θi, . . . , θN )) − πi(θ1, . . . , θi, . . . , θN ) ≥ ui(θi, o(θ1, . . . , ˆθi, . . . , θN )) − πi(θ1, . . . , ˆθi, . . . , θN ). In the case of randomized mechanisms we have Eo|θ1,..,θi,..,θn [ui(θi, o) − πi(θ1, . . . , θi, . . . , θN )] ≥ Eo|θ1,.., ˆθi,..,θn [ui(θi, o) − πi(θ1, . . . , ˆθi, . . . , θN )]. The terms involving payments can be left out in the case where payments are not possible. Thus, in dominant strategies implementation, truthtelling is optimal regardless of what the other agents report. If it is optimal only given that the other agents are truthful, and given that one does not know the other agents types, we have implementation in Bayes-Nash equilibrium. Definition 7. Given an automated mechanism design setting, a mechanism is said to implement its outcome and payment functions in Bayes-Nash equilibrium if truthtelling is always optimal to an agent when that agent does not yet know anything about the other agents types, and the other agents are telling the truth. Formally, for any agent i, any type θi ∈ Θi, and any alternative type report ˆθi ∈ Θi, in the case of deterministic mechanisms we have E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, . . . , θi, . . . , θN ))− πi(θ1, . . . , θi, . . . , θN )] ≥ E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, . . . , ˆθi, . . . , θN ))− πi(θ1, . . . , ˆθi, . . . , θN )]. In the case of randomized mechanisms we have E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,..,θi,..,θn [ui(θi, o)− πi(θ1, . . . , θi, . . . , θN )] ≥ E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,.., ˆθi,..,θn [ui(θi, o)− πi(θ1, . . . , ˆθi, . . . , θN )]. The terms involving payments can be left out in the case where payments are not possible. 135 3.3 Automated mechanism design We can now define the computational problem we study. Definition 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) We are given: • an automated mechanism design setting, • an IR notion (ex interim, ex post, or none), • a solution concept (dominant strategies or Bayes-Nash), • whether payments are possible, • whether randomization is possible, • (in the decision variant of the problem) a target value G. We are asked whether there exists a mechanism of the specified kind (in terms of payments and randomization) that satisfies both the IR notion and the solution concept, and gives an expected value of at least G for the objective. An interesting special case is the setting where there is only one agent. In this case, the reporting agent always knows everything there is to know about the other agents types-because there are no other agents. Since ex post and ex interim IR only differ on what an agent is assumed to know about other agents types, the two IR concepts coincide here. Also, because implementation in dominant strategies and implementation in Bayes-Nash equilibrium only differ on what an agent is assumed to know about other agents types, the two solution concepts coincide here. This observation will prove to be a useful tool in proving hardness results: if we prove computational hardness in the singleagent setting, this immediately implies hardness for both IR concepts, for both solution concepts, for any number of agents. 4. PAYMENT-MAXIMIZINGDETERMINISTIC AMD IS HARD In this section we demonstrate that it is NP-complete to design a deterministic mechanism that maximizes the expected sum of the payments collected from the agents. We show that this problem is hard even in the single-agent setting, thereby immediately showing it hard for both IR concepts, for both solution concepts. To demonstrate NPhardness, we reduce from the MINSAT problem. Definition 9 (MINSAT). We are given a formula φ in conjunctive normal form, represented by a set of Boolean variables V and a set of clauses C, and an integer K (K < |C|). We are asked whether there exists an assignment to the variables in V such that at most K clauses in φ are satisfied. MINSAT was recently shown to be NP-complete [14]. We can now present our result. Theorem 1. Payment-maximizing deterministic AMD is NP-complete, even for a single agent, even with a uniform distribution over types. Proof. It is easy to show that the problem is in NP. To show NP-hardness, we reduce an arbitrary MINSAT instance to the following single-agent payment-maximizing deterministic AMD instance. Let the agents type set be Θ = {θc : c ∈ C} ∪ {θv : v ∈ V }, where C is the set of clauses in the MINSAT instance, and V is the set of variables. Let the probability distribution over these types be uniform. Let the outcome set be O = {o0} ∪ {oc : c ∈ C} ∪ {ol : l ∈ L}, where L is the set of literals, that is, L = {+v : v ∈ V } ∪ {−v : v ∈ V }. Let the notation v(l) = v denote that v is the variable corresponding to the literal l, that is, l ∈ {+v, −v}. Let l ∈ c denote that the literal l occurs in clause c. Then, let the agents utility function be given by u(θc, ol) = |Θ| + 1 for all l ∈ L with l ∈ c; u(θc, ol) = 0 for all l ∈ L with l /∈ c; u(θc, oc) = |Θ| + 1; u(θc, oc ) = 0 for all c ∈ C with c = c ; u(θv, ol) = |Θ| for all l ∈ L with v(l) = v; u(θv, ol) = 0 for all l ∈ L with v(l) = v; u(θv, oc) = 0 for all c ∈ C. The goal of the AMD instance is G = |Θ| + |C|−K |Θ| , where K is the goal of the MINSAT instance. We show the instances are equivalent. First, suppose there is a solution to the MINSAT instance. Let the assignment of truth values to the variables in this solution be given by the function f : V → L (where v(f(v)) = v for all v ∈ V ). Then, for every v ∈ V , let o(θv) = of(v) and π(θv) = |Θ|. For every c ∈ C, let o(θc) = oc; let π(θc) = |Θ| + 1 if c is not satisfied in the MINSAT solution, and π(θc) = |Θ| if c is satisfied. It is straightforward to check that the IR constraint is satisfied. We now check that the agent has no incentive to misreport. If the agents type is some θv, then any other report will give it an outcome that is no better, for a payment that is no less, so it has no incentive to misreport. If the agents type is some θc where c is a satisfied clause, again, any other report will give it an outcome that is no better, for a payment that is no less, so it has no incentive to misreport. The final case to check is where the agents type is some θc where c is an unsatisfied clause. In this case, we observe that for none of the types, reporting it leads to an outcome ol for a literal l ∈ c, precisely because the clause is not satisfied in the MINSAT instance. Because also, no type besides θc leads to the outcome oc, reporting any other type will give an outcome with utility 0, while still forcing a payment of at least |Θ| from the agent. Clearly the agent is better off reporting truthfully, for a total utility of 0. This establishes that the agent never has an incentive to misreport. Finally, we show that the goal is reached. If s is the number of satisfied clauses in the MINSAT solution (so that s ≤ K), the expected payment from this mechanism is |V ||Θ|+s|Θ|+(|C|−s)(|Θ|+1) |Θ| ≥ |V ||Θ|+K|Θ|+(|C|−K)(|Θ|+1) |Θ| = |Θ| + |C|−K |Θ| = G. So there is a solution to the AMD instance. Now suppose there is a solution to the AMD instance, given by an outcome function o and a payment function π. First, suppose there is some v ∈ V such that o(θv) /∈ {o+v, o−v}. Then the utility that the agent derives from the given outcome for this type is 0, and hence, by IR, no payment can be extracted from the agent for this type. Because, again by IR, the maximum payment that can be extracted for any other type is |Θ| + 1, it follows that the maximum expected payment that could be obtained is at most (|Θ|−1)(|Θ|+1) |Θ| < |Θ| < G, contradicting that this is a solution to the AMD instance. It follows that in the solution to the AMD instance, for every v ∈ V , o(θv) ∈ {o+v, o−v}. 136 We can interpret this as an assignment of truth values to the variables: v is set to true if o(θv) = o+v, and to false if o(θv) = o−v. We claim this assignment is a solution to the MINSAT instance. By the IR constraint, the maximum payment we can extract from any type θv is |Θ|. Because there can be no incentives for the agent to report falsely, for any clause c satisfied by the given assignment, the maximum payment we can extract for the corresponding type θc is |Θ|. (For if we extracted more from this type, the agents utility in this case would be less than 1; and if v is the variable satisfying c in the assignment, so that o(θv) = ol where l occurs in c, then the agent would be better off reporting θv instead of the truthful report θc, to get an outcome worth |Θ|+1 to it while having to pay at most |Θ|.) Finally, for any unsatisfied clause c, by the IR constraint, the maximum payment we can extract for the corresponding type θc is |Θ| + 1. It follows that the expected payment from our mechanism is at most V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ , where s is the number of satisfied clauses. Because our mechanism achieves the goal, it follows that V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ ≥ G, which by simple algebraic manipulations is equivalent to s ≤ K. So there is a solution to the MINSAT instance. Because payment-maximizing AMD is just the special case of AMD for a self-interested designer where the designer has no preferences over the outcome chosen, this immediately implies hardness for the general case of AMD for a selfinterested designer where payments are possible. However, it does not yet imply hardness for the special case where payments are not possible. We will prove hardness in this case in the next section. 5. SELF-INTERESTED DETERMINISTIC AMD WITHOUT PAYMENTS IS HARD In this section we demonstrate that it is NP-complete to design a deterministic mechanism that maximizes the expectation of the designers objective when payments are not possible. We show that this problem is hard even in the single-agent setting, thereby immediately showing it hard for both IR concepts, for both solution concepts. Theorem 2. Without payments, deterministic AMD for a self-interested designer is NP-complete, even for a single agent, even with a uniform distribution over types. Proof. It is easy to show that the problem is in NP. To show NP-hardness, we reduce an arbitrary MINSAT instance to the following single-agent self-interested deterministic AMD without payments instance. Let the agents type set be Θ = {θc : c ∈ C} ∪ {θv : v ∈ V }, where C is the set of clauses in the MINSAT instance, and V is the set of variables. Let the probability distribution over these types be uniform. Let the outcome set be O = {o0} ∪ {oc : c ∈ C}∪{ol : l ∈ L}∪{o∗ }, where L is the set of literals, that is, L = {+v : v ∈ V } ∪ {−v : v ∈ V }. Let the notation v(l) = v denote that v is the variable corresponding to the literal l, that is, l ∈ {+v, −v}. Let l ∈ c denote that the literal l occurs in clause c. Then, let the agents utility function be given by u(θc, ol) = 2 for all l ∈ L with l ∈ c; u(θc, ol) = −1 for all l ∈ L with l /∈ c; u(θc, oc) = 2; u(θc, oc ) = −1 for all c ∈ C with c = c ; u(θc, o∗ ) = 1; u(θv, ol) = 1 for all l ∈ L with v(l) = v; u(θv, ol) = −1 for all l ∈ L with v(l) = v; u(θv, oc) = −1 for all c ∈ C; u(θv, o∗ ) = −1. Let the designers objective function be given by g(o∗ ) = |Θ|+1; g(ol) = |Θ| for all l ∈ L; g(oc) = |Θ| for all c ∈ C. The goal of the AMD instance is G = |Θ| + |C|−K |Θ| , where K is the goal of the MINSAT instance. We show the instances are equivalent. First, suppose there is a solution to the MINSAT instance. Let the assignment of truth values to the variables in this solution be given by the function f : V → L (where v(f(v)) = v for all v ∈ V ). Then, for every v ∈ V , let o(θv) = of(v). For every c ∈ C that is satisfied in the MINSAT solution, let o(θc) = oc; for every unsatisfied c ∈ C, let o(θc) = o∗ . It is straightforward to check that the IR constraint is satisfied. We now check that the agent has no incentive to misreport. If the agents type is some θv, it is getting the maximum utility for that type, so it has no incentive to misreport. If the agents type is some θc where c is a satisfied clause, again, it is getting the maximum utility for that type, so it has no incentive to misreport. The final case to check is where the agents type is some θc where c is an unsatisfied clause. In this case, we observe that for none of the types, reporting it leads to an outcome ol for a literal l ∈ c, precisely because the clause is not satisfied in the MINSAT instance. Because also, no type leads to the outcome oc, there is no outcome that the mechanism ever selects that would give the agent utility greater than 1 for type θc, and hence the agent has no incentive to report falsely. This establishes that the agent never has an incentive to misreport. Finally, we show that the goal is reached. If s is the number of satisfied clauses in the MINSAT solution (so that s ≤ K), then the expected value of the designers objective function is |V ||Θ|+s|Θ|+(|C|−s)(|Θ|+1) |Θ| ≥ |V ||Θ|+K|Θ|+(|C|−K)(|Θ|+1) |Θ| = |Θ| + |C|−K |Θ| = G. So there is a solution to the AMD instance. Now suppose there is a solution to the AMD instance, given by an outcome function o. First, suppose there is some v ∈ V such that o(θv) /∈ {o+v, o−v}. The only other outcome that the mechanism is allowed to choose under the IR constraint is o0. This has an objective value of 0, and because the highest value the objective function ever takes is |Θ| + 1, it follows that the maximum expected value of the objective function that could be obtained is at most (|Θ|−1)(|Θ|+1) |Θ| < |Θ| < G, contradicting that this is a solution to the AMD instance. It follows that in the solution to the AMD instance, for every v ∈ V , o(θv) ∈ {o+v, o−v}. We can interpret this as an assignment of truth values to the variables: v is set to true if o(θv) = o+v, and to false if o(θv) = o−v. We claim this assignment is a solution to the MINSAT instance. By the above, for any type θv, the value of the objective function in this mechanism will be |Θ|. For any clause c satisfied by the given assignment, the value of the objective function in the case where the agent reports type θc will be at most |Θ|. (This is because we cannot choose the outcome o∗ for such a type, as in this case the agent would have an incentive to report θv instead, where v is the variable satisfying c in the assignment (so that o(θv) = ol where l occurs in c).) Finally, for any unsatisfied clause c, the maximum value the objective function can take in the case where the agent reports type θc is |Θ| + 1, simply because this is the largest value the function ever takes. It follows that the expected value of the objective function for our mechanism is at most V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ , where s is the number of satisfied 137 clauses. Because our mechanism achieves the goal, it follows that V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ ≥ G, which by simple algebraic manipulations is equivalent to s ≤ K. So there is a solution to the MINSAT instance. Both of our hardness results relied on the constraint that the mechanism should be deterministic. In the next section, we show that the hardness of design disappears when we allow for randomization in the mechanism. 6. RANDOMIZED AMD FOR A SELFINTERESTED DESIGNER IS EASY We now show how allowing for randomization over the outcomes makes the problem of self-interested AMD tractable through linear programming, for any constant number of agents. Theorem 3. Self-interested randomized AMD with a constant number of agents is solvable in polynomial time by linear programming, both with and without payments, both for ex post and ex interim IR, and both for implementation in dominant strategies and for implementation in Bayes-Nash equilibrium-even if the types are correlated. Proof. Because linear programs can be solved in polynomial time [13], all we need to show is that the number of variables and equations in our program is polynomial for any constant number of agents-that is, exponential only in N. Throughout, for purposes of determining the size of the linear program, let T = maxi{|Θi|}. The variables of our linear program will be the probabilities (p(θ1, θ2, . . . , θN ))(o) (at most TN |O| variables) and the payments πi(θ1, θ2, . . . , θN ) (at most NTN variables). (We show the linear program for the case where payments are possible; the case without payments is easily obtained from this by simply omitting all the payment variables in the program, or by adding additional constraints forcing the payments to be 0.) First, we show the IR constraints. For ex post IR, we add the following (at most NTN ) constraints to the LP: • For every i ∈ {1, 2, . . . , N}, and for every (θ1, θ2, . . . , θN ) ∈ Θ1 × Θ2 × . . . × ΘN , we add ( o∈O (p(θ1, θ2, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , θN ) ≥ 0. For ex interim IR, we add the following (at most NT) constraints to the LP: • For every i ∈ {1, 2, . . . , N}, for every θi ∈ Θi, we add θ1,... ,θN γ(θ1, . . . , θN |θi)(( o∈O (p(θ1, θ2, . . . , θN ))(o)u(θi, o))− πi(θ1, θ2, . . . , θN )) ≥ 0. Now, we show the solution concept constraints. For implementation in dominant strategies, we add the following (at most NTN+1 ) constraints to the LP: • For every i ∈ {1, 2, . . . , N}, for every (θ1, θ2, . . . , θi, . . . , θN ) ∈ Θ1 × Θ2 × . . . × ΘN , and for every alternative type report ˆθi ∈ Θi, we add the constraint ( o∈O (p(θ1, θ2, . . . , θi, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , θi, . . . , θN ) ≥ ( o∈O (p(θ1, θ2, . . . , ˆθi, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , ˆθi, . . . , θN ). Finally, for implementation in Bayes-Nash equilibrium, we add the following (at most NT2 ) constraints to the LP: • For every i ∈ {1, 2, ..., N}, for every θi ∈ Θi, and for every alternative type report ˆθi ∈ Θi, we add the constraint θ1,...,θN γ(θ1, ..., θN |θi)(( o∈O (p(θ1, θ2, ..., θi, ..., θN ))(o)u(θi, o)) − πi(θ1, θ2, ..., θi, ..., θN )) ≥ θ1,...,θN γ(θ1, ..., θN |θi)(( o∈O (p(θ1, θ2, ..., ˆθi, ..., θN ))(o)u(θi, o)) − πi(θ1, θ2, ..., ˆθi, ..., θN )). All that is left to do is to give the expression the designer is seeking to maximize, which is: • θ1,...,θN γ(θ1, ..., θN )(( o∈O (p(θ1, θ2, ..., θi, ..., θN ))(o)g(o)) + N i=1 πi(θ1, θ2, ..., θN )). As we indicated, the number of variables and constraints is exponential only in N, and hence the linear program is of polynomial size for constant numbers of agents. Thus the problem is solvable in polynomial time. 7. IMPLICATIONS FOR AN OPTIMAL COMBINATORIAL AUCTION DESIGN PROBLEM In this section, we will demonstrate some interesting consequences of the problem of automated mechanism design for a self-interested designer on designing optimal combinatorial auctions. Consider a combinatorial auction with a set S of items for sale. For any bundle B ⊆ S, let ui(θi, B) be bidder is utility for receiving bundle B when the bidders type is θi. The optimal auction design problem is to specify the rules of the auction so as to maximize expected revenue to the auctioneer. (By the revelation principle, without loss of generality, we can assume the auction is truthful.) The optimal auction design problem is solved for the case of a single item by the famous Myerson auction [18]. However, designing optimal auctions in combinatorial auctions is a recognized open research problem [3, 25]. The problem is open even if there are only two items for sale. (The twoitem case with a very special form of complementarity and no substitutability has been solved recently [1].) Suppose we have free disposal-items can be thrown away at no cost. Also, suppose that the bidders preferences have the following structure: whenever a bidder receives a bundle of items, the bidders utility for that bundle is determined by the best item in the bundle only. (We emphasize that 138 which item is the best is allowed to depend on the bidders type.) Definition 10. Bidder i is said to have best-only preferences over bundles of items if there exists a function vi : Θi × S → R such that for any θi ∈ Θi, for any B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s). We make the following useful observation in this setting: there is no sense in awarding a bidder more than one item. The reason is that if the bidder is reporting truthfully, taking all but the highest valued item away from the bidder will not hurt the bidder; and, by free disposal, doing so can only reduce the incentive for this bidder to falsely report this type, when the bidder actually has another type. We now show that the problem of designing a deterministic optimal auction here is NP-complete, by a reduction from the payment maximizing AMD problem! Theorem 4. Given an optimal combinatorial auction design problem under best-only preferences (given by a set of items S and for each bidder i, a finite type space Θi and a function vi : Θi × S → R such that for any θi ∈ Θi, for any B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s)), designing the optimal deterministic auction is NP-complete, even for a single bidder with a uniform distribution over types. Proof. The problem is in NP because we can nondeterministically generate an allocation rule, and then set the payments using linear programming. To show NP-hardness, we reduce an arbitrary paymentmaximizing deterministic AMD instance, with a single agent and a uniform distribution over types, to the following optimal combinatorial auction design problem instance with a single bidder with best-only preferences. For every outcome o ∈ O in the AMD instance (besides the outcome o0), let there be one item so ∈ S. Let the type space be the same, and let v(θi, so) = ui(θi, o) (where u is as specified in the AMD instance). Let the expected revenue target value be the same in both instances. We show the instances are equivalent. First suppose there exists a solution to the AMD instance, given by an outcome function and a payment function. Then, if the AMD solution chooses outcome o for a type, in the optimal auction solution, allocate {so} to the bidder for this type. (Unless o = o0, in which case we allocate {} to the bidder.) Let the payment functions be the same in both instances. Then, the utility that an agent receives for reporting a type (given the true type) in either solution is the same, so we have incentive compatibility in the optimal auction solution. Moreover, because the type distribution and the payment function are the same, the expected revenue to the auctioneer/designer is the same. It follows that there exists a solution to the optimal auction design instance. Now suppose there exists a solution to the optimal auction design instance. By the at-most-one-item observation, we can assume without loss of generality that the solution never allocates more than one item. Then, if the optimal auction solution allocates item so to the bidder for a type, in the AMD solution, let the mechanism choose outcome o for that type. If the optimal auction solution allocates nothing to the bidder for a type, in the AMD solution, let the mechanism choose outcome o0 for that type. Let the payment functions be the same. Then, the utility that an agent receives for reporting a type (given the true type) in either solution is the same, so we have incentive compatibility in the AMD solution. Moreover, because the type distribution and the payment function are the same, the expected revenue to the designer/auctioneer is the same. It follows that there exists a solution to the AMD instance. Fortunately, we can also carry through the easiness result for randomized mechanisms to this combinatorial auction setting-giving us one of the few known polynomial-time algorithms for an optimal combinatorial auction design problem. Theorem 5. Given an optimal combinatorial auction design problem under best-only preferences (given by a set of items S and for each bidder i, a finite type space Θi and a function vi : Θi × S → R such that for any θi ∈ Θi, for any B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s)), if the number of bidders is a constant k, then the optimal randomized auction can be designed in polynomial time. (For any IC and IR constraints.) Proof. By the at-most-one-item observation, we can without loss of generality restrict ourselves to allocations where each bidder receives at most one item. There are fewer than (|S| + 1)k such allocations-that is, a polynomial number of allocations. Because we can list the outcomes explicitly, we can simply solve this as a payment-maximizing AMD instance, with linear programming. 8. RELATED RESEARCH ON COMPLEXITY IN MECHANISM DESIGN There has been considerable recent interest in mechanism design in computer science. Some of it has focused on issues of computational complexity, but most of that work has strived toward designing mechanisms that are easy to execute (e.g. [20, 15, 19, 9, 12]), rather than studying the complexity of designing the mechanism. The closest piece of earlier work studied the complexity of automated mechanism design by a benevolent designer [5, 6]. Roughgarden has studied the complexity of designing a good network topology for agents that selfishly choose the links they use [21]. This is related to mechanism design, but differs significantly in that the designer only has restricted control over the rules of the game because there is no party that can impose the outcome (or side payments). Also, there is no explicit reporting of preferences. 9. CONCLUSIONS AND FUTURE RESEARCH Often, an outcome must be chosen on the basis of the preferences reported by a group of agents. The key difficulty is that the agents may report their preferences insincerely to make the chosen outcome more favorable to themselves. Mechanism design is the art of designing the rules of the game so that the agents are motivated to report their preferences truthfully, and a desirable outcome is chosen. In a recently emerging approach-called automated mechanism design-a mechanism is computed for the specific preference aggregation setting at hand. This has several advantages, 139 but the downside is that the mechanism design optimization problem needs to be solved anew each time. Unlike earlier work on automated mechanism design that studied a benevolent designer, in this paper we studied automated mechanism design problems where the designer is self-interesteda setting much more relevant for electronic commerce. In this setting, the center cares only about which outcome is chosen and what payments are made to it. The reason that the agents preferences are relevant is that the center is constrained to making each agent at least as well off as the agent would have been had it not participated in the mechanism. In this setting, we showed that designing an optimal deterministic mechanism is NP-complete in two important special cases: when the center is interested only in the payments made to it, and when payments are not possible and the center is interested only in the outcome chosen. These hardness results imply hardness in all more general automated mechanism design settings with a self-interested designer. The hardness results apply whether the individual rationality (participation) constraints are applied ex interim or ex post, and whether the solution concept is dominant strategies implementation or Bayes-Nash equilibrium implementation. We then showed that allowing randomization in the mechanism makes the design problem in all these settings computationally easy. Finally, we showed that the paymentmaximizing AMD problem is closely related to an interesting variant of the optimal (revenue-maximizing) combinatorial auction design problem, where the bidders have best-only preferences. We showed that here, too, designing an optimal deterministic mechanism is NP-complete even with one agent, but designing an optimal randomized mechanism is easy. Future research includes studying automated mechanism design with a self-interested designer in more restricted settings such as auctions (where the designers objective may include preferences about which bidder should receive the good-as well as payments). We also want to study the complexity of automated mechanism design in settings where the outcome and type spaces have special structure so they can be represented more concisely. Finally, we plan to assemble a data set of real-world mechanism design problems-both historical and current-and apply automated mechanism design to those problems. 10. REFERENCES [1] M. Armstrong. Optimal multi-object auctions. Review of Economic Studies, 67:455-481, 2000. [2] K. Arrow. The property rights doctrine and demand revelation under incomplete information. In M. Boskin, editor, Economics and human welfare. New York Academic Press, 1979. [3] C. Avery and T. Hendershott. Bundling and optimal auctions of multiple products. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Multipart pricing of public goods. Public Choice, 11:17-33, 1971. [5] V. Conitzer and T. Sandholm. Complexity of mechanism design. In Proceedings of the 18th Annual Conference on Uncertainty in Artificial Intelligence (UAI-02), pages 103-110, Edmonton, Canada, 2002. [6] V. Conitzer and T. Sandholm. Automated mechanism design: Complexity results stemming from the single-agent setting. In Proceedings of the 5th International Conference on Electronic Commerce (ICEC-03), pages 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer and T. Sandholm. Computational criticisms of the revelation principle. In Proceedings of the ACM Conference on Electronic Commerce (ACM-EC), New York, NY, 2004. Short paper. Full-length version appeared in the AAMAS-03 workshop on Agent-Mediated Electronic Commerce (AMEC). [8] C. dAspremont and L. A. G´erard-Varet. Incentives and incomplete information. Journal of Public Economics, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, and S. Shenker. Sharing the cost of muliticast transmissions. Journal of Computer and System Sciences, 63:21-41, 2001. Early version in Proceedings of the Annual ACM Symposium on Theory of Computing (STOC), 2000. [10] A. Gibbard. Manipulation of voting schemes. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentives in teams. Econometrica, 41:617-631, 1973. [12] J. Hershberger and S. Suri. Vickrey prices and shortest paths: What is an edge worth? In Proceedings of the Annual Symposium on Foundations of Computer Science (FOCS), 2001. [13] L. Khachiyan. A polynomial algorithm in linear programming. Soviet Math. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi, and P. Mirchandani. The minimum satisfiability problem. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, and Y. Shoham. Truth revelation in rapid, approximately efficient combinatorial auctions. Journal of the ACM, 49(5):577-602, 2002. Early version appeared in Proceedings of the ACM Conference on Electronic Commerce (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, and J. R. Green. Microeconomic Theory. Oxford University Press, 1995. [17] E. S. Maskin and J. Riley. Optimal multi-unit auctions. In F. Hahn, editor, The Economics of Missing Markets, Information, and Games, chapter 14, pages 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Optimal auction design. Mathematics of Operation Research, 6:58-73, 1981. [19] N. Nisan and A. Ronen. Computationally feasible VCG mechanisms. In Proceedings of the ACM Conference on Electronic Commerce (ACM-EC), pages 242-252, Minneapolis, MN, 2000. [20] N. Nisan and A. Ronen. Algorithmic mechanism design. Games and Economic Behavior, 35:166-196, 2001. Early version in Proceedings of the Annual ACM Symposium on Theory of Computing (STOC), 1999. [21] T. Roughgarden. Designing networks for selfish users is hard. In Proceedings of the Annual Symposium on Foundations of Computer Science (FOCS), 2001. [22] T. Sandholm. Issues in computational Vickrey auctions. International Journal of Electronic Commerce, 4(3):107-129, 2000. Special Issue on 140 Applying Intelligent Agents for Electronic Commerce. A short, early version appeared at the Second International Conference on Multi-Agent Systems (ICMAS), pages 299-306, 1996. [23] M. A. Satterthwaite. Strategy-proofness and Arrows conditions: existence and correspondence theorems for voting procedures and social welfare functions. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Counterspeculation, auctions, and competitive sealed tenders. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Research problems in combinatorial auctions. Mimeo, version Oct. 29, 2001. 141",
    "original_translation": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141",
    "error_count": 8,
    "keys": {
        "mechanism design": {
            "translated_key": [
                "diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "Diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "Diseño mecánico",
                "diseño mecánico"
            ],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente propuesto, llamado \"diseño mecánico automatizado\", se calcula un mecanismo para el establecimiento de la agregación de preferencias a la mano. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del \"diseño mecánico\" necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el \"diseño mecánico\" automatizado que estudió a un diseñador benevolente, en este artículo estudiamos problemas de \"diseño mecánico\" automatizado donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del \"diseño mecánico\" en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el \"diseño mecánico\" más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El \"diseño mecánico\" clásico proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del \"diseño mecánico\" como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama \"diseño mecánico\" automatizado. El enfoque automatizado del \"diseño mecánico\" tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el \"diseño mecánico\" automatizado requiere que el problema de optimización del \"diseño mecánico\" se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del \"diseño mecánico\" automatizado en el caso de un diseñador interesado. Este es un escenario importante para el \"diseño mecánico\" automatizado debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del \"diseño mecánico\" automatizado, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del \"diseño mecánico\" como el principio de la revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración automatizada de \"diseño mecánico\". Definición 1. En una configuración automatizada de \"diseño mecánico\", se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración automatizada de \"diseño mecánico\" con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo de Łi فارسى Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un \"diseño mecánico\" automatizado, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un \"diseño mecánico\" automatizado, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la verdad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 \"Diseño mecánico automatizado\" Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada de \"diseño mecánico\", • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del \"diseño mecánico\" automatizado para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el \"diseño mecánico\" de la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de la obra anterior estudió la complejidad del \"diseño mecánico\" automatizado por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el \"diseño mecánico\", pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado \"diseño mecánico automatizado\", se calcula un mecanismo para el ajuste específico de la agregación de preferencias a la mano. Esto tiene varias ventajas, 139 pero la desventaja es que el problema de optimización del \"diseño mecánico\" necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el \"diseño mecánico\" automatizado que estudió a un diseñador benevolente, en este artículo estudiamos problemas de \"diseño mecánico\" automatizado donde el diseñador se interesa por un entorno mucho más relevante para el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de \"diseño mecánico\" automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del \"diseño mecánico\" automatizado con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del \"diseño mecánico\" automatizado en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de \"diseño mecánico\" en el mundo real -tanto históricos como actuales- y aplicar un \"diseño mecánico\" automatizado a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del \"diseño mecánico\". En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. \"Diseño mecánico\" automatizado: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Algorítmico \"diseño mecánico\". Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                "diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "Diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico automatizado",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "Diseño mecánico",
                "diseño mecánico"
            ]
        },
        "desirable outcome": {
            "translated_key": "resultado deseable",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un \"resultado deseable\". En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un \"resultado deseable\". En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "manipulability": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        },
        "preference aggregator": {
            "translated_key": "agregador de preferencia",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El \"agregador de preferencia\" generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "individual rationality": {
            "translated_key": "racionalidad individual",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La restricción más común es la de la \"racionalidad individual\" (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que el agente habría sido si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (\"racionalidad individual\"). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de \"racionalidad individual\". Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones de \"racionalidad individual\" (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación de equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "nonmanipulable mechanism": {
            "translated_key": "mecanismo no manipulable",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un \"mecanismo no manipulable\" que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier \"mecanismo no manipulable\". Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un \"mecanismo no manipulable\" cuyo desempeño es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "statistical knowledge": {
            "translated_key": "conocimientos estadísticos",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagine que una empresa crea automáticamente su mecanismo de contratación basado en \"conocimientos estadísticos\" sobre sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "classical mechanism": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        },
        "payment maximizing": {
            "translated_key": "pago maximizado",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, el diseñador se dice que es \"pago maximizado\". En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del \"pago maximizado\" problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "fallback outcome": {
            "translated_key": "resultado de retroceso",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, necesitamos formalizar el concepto del \"resultado de retroceso\". Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un \"resultado de retroceso\" o0 o O donde, para cualquier agente i y cualquier tipo de i • • • •, tenemos ui(­, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "automated mechanism design": {
            "translated_key": [
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automatizado de mecanismos",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automático del mecanismo",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automático de mecanismos",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados"
            ],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente propuesto llamado \"diseño de mecanismos automatizados\" se calcula un mecanismo para el ajuste de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre \"diseño de mecanismos automatizados\" que estudió a un diseñador benevolente, en este trabajo se estudian los problemas de \"diseño de mecanismos automatizados\" donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama \"diseño de mecanismos automatizados\". El enfoque del \"diseño automatizado de mecanismos\" tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el \"diseño de mecanismos automatizados\" requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del \"diseño de mecanismos automatizados\" en el caso de un diseñador interesado. Este es un escenario importante para el \"diseño de mecanismos automatizados\" debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del \"diseño de mecanismos automatizados\", debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de \"diseño de mecanismos automatizados\". Definición 1. En una configuración de \"diseño automático del mecanismo\", se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de \"diseño de mecanismos automatizados\" con una restricción de IR, hay un resultado de retroceso o0 o O donde, para cualquier agente i y cualquier tipo de Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un \"diseño de mecanismos automatizados\", se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un \"diseño de mecanismos automatizados\", se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración de \"diseño automático de mecanismos\", • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del \"diseño de mecanismos automatizados\" para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de la obra anterior estudió la complejidad del \"diseño de mecanismos automatizados\" por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente llamado \"diseño de mecanismos automatizados\" se calcula un mecanismo para el ajuste específico de la agregación de preferencias a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de trabajos anteriores sobre \"diseño de mecanismos automatizados\" que estudiaron a un diseñador benevolente, en este artículo estudiamos los problemas de \"diseño de mecanismos automatizados\" donde el diseñador se interesa por el entorno mucho más relevante para el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes más generales de \"diseño de mecanismos automatizados\" con un diseñador interesado en sí mismo. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del \"diseño de mecanismos automatizados\" con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del \"diseño de mecanismos automatizados\" en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el \"diseño de mecanismos automatizados\" a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automatizado de mecanismos",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automático del mecanismo",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño automático de mecanismos",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados",
                "diseño de mecanismos automatizados"
            ]
        },
        "minsat": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        },
        "self-interested amd": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        },
        "complementarity": {
            "translated_key": "completaridad",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos ítems con una forma muy especial de \"completaridad\" y ninguna sustituibilidad ha sido resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "automate mechanism design": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        },
        "combinatorial auction": {
            "translated_key": "subasta combinatoria",
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Finalmente, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema de diseño óptimo (revenuemaximizing) de \"subasta combinatoria\", donde los postores tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema de diseño particular óptimo (revenue-maximizing) \"subasta combinatoria\". 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una \"subasta combinatoria\" con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema de diseño óptimo de \"subasta combinatoria\" bajo las preferencias de la mejor-única (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : Łi × S → R de tal manera que para cualquier Łi Łi, para cualquier B  S, ui(Łi, B) = maxsŁB vi(Ł Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre tipos, a la siguiente instancia de problema de diseño de \"subasta combinatoria\" óptima con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a través del resultado de facilidad para los mecanismos aleatorios a esta \"subasta combinatoria\" que nos da uno de los pocos algoritmos de tiempo polinomio conocidos para un problema óptimo de diseño de \"subasta combinatoria\". Teorema 5. Dado un problema de diseño óptimo de \"subasta combinatoria\" bajo preferencias de la mejor-única (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi :?i × S → R tal que para cualquier?i??i, para cualquier B  S, ui(?i, B) = maxs?B vi(?i (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño óptimo (revenue-maximizador) de la \"subasta combinatoria\", donde los postores tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": [
                ""
            ]
        },
        "revenue maximization": {
            "translated_key": [],
            "translated_annotated_text": "Diseño Autointeresado de Mecanismos Automatizados e Implicaciones para Subastas Combinatorias Optimas* Vincent Conitzer Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA conitzer@cs.cmu.edu Tuomas Sandholm Carnegie Mellon University 5000 Forbes Avenue Pittsburgh, PA 15213, USA sandholm@cs.cmu.edu La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque propuesto recientemente, denominado diseño automatizado de mecanismos, se calcula un mecanismo para el establecimiento de la agregación de preferencias. Esto tiene varias ventajas, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia del trabajo anterior sobre el diseño de mecanismos automatizados que estudió a un diseñador benevolente, en este artículo estudiamos los problemas de diseño de mecanismos automatizados donde el diseñador es interesado. En este caso, al centro sólo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, mostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. A continuación, mostramos cómo permitir la aleatorización en el mecanismo hace problemas en este ajuste computacionalmente fácil. Por último, mostramos que el problema de AMD maximizante de pago está estrechamente relacionado con una variante interesante del problema óptimo (revenuemaximizing) de diseño de subasta combinatoria, donde los ofertantes tienen las mejores preferencias. Demostramos que aquí, también, diseñar una subasta determinista óptima es NPcomplete, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asunto F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones de Computación]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los ajustes multiagente, a menudo un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. Esos resultados podrían ser posibles presidentes, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes a priori. Más bien, los agentes informan de sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar mal de sus preferencias con el fin de engañar al mecanismo en la selección de un resultado que es más deseable para el agente que el resultado que se seleccionaría si el agente reveló sus preferencias verazmente. Esta manipulación no es deseable porque los mecanismos de agregación de preferencias se adaptan a las preferencias agregadas de una manera socialmente deseable, y si los agentes revelan sus preferencias sin sinceridad, puede elegirse un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en todos los mecanismos de agregación de preferencias. Un resultado seminal negativo, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, hay preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado no importa qué preferencias informen los otros agentes.) Lo que el agregador quisiera hacer es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados en sí mismos estén motivados a informar sus preferencias verazmente, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Este es el escenario clásico del diseño de mecanismos en la teoría del juego. En este artículo, estudiamos el caso en el que el diseñador se interesa por sí mismo, es decir, el diseñador no se preocupa directamente por cómo el out132 se relaciona con las preferencias de los agentes, sino que se ocupa de su propia agenda para la que debe elegirse el resultado, y de maximizar los pagos a sí mismo. Este es el diseño del mecanismo más relevante para el comercio electrónico. En el caso de que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recoger las preferencias de los agentes está clara. Tal vez sea menos obvio por qué deben recogerse cuando el diseñador es interesado en sí mismo y por lo tanto su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites a cómo el diseñador elige el resultado y los pagos. La limitación más común es la de la racionalidad individual (IR), lo que significa que el mecanismo no puede hacer que ningún agente sea peor de lo que habría sido el agente si no hubiera participado en el mecanismo. Por ejemplo, en el establecimiento de un diseño óptimo de subastas, el diseñador (auctioneer) sólo se ocupa de la cantidad de ingresos recaudados, y no per se de lo bien que la asignación del bien (o mercancías) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más que su valoración por el paquete de bienes que se le asignan. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que hace que los agentes razonablemente bien. Por otro lado, el diseñador no necesariamente elegirá un resultado de bienestar social maximizando. Por ejemplo, si el diseñador elige siempre un resultado que maximice el bienestar social con respecto a las preferencias reportadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar mal sus preferencias-y esto puede llevar a que se recauden menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría óptima del diseño de subastas es que a veces el bien se asigna a nadie, incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulación y maximizan algún objetivo. La ventaja de estos mecanismos es que no se basan en información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta Myerson [18] y la subasta multiunidad Maskin-Riley [ Sin embargo, los mecanismos generales también tienen desventajas significativas: • Los mecanismos generales más famosos y más ampliamente aplicables, VCG y dAGVA, sólo maximizan el bienestar social. Si el diseñador es interesado, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo de los diseñadores. • Los mecanismos generales que se centran en un diseñador interesado solo son aplicables en entornos muy restringidos, como Myersons esperaba obtener ingresos maximizando la subasta para vender un solo artículo, y Maskin y Rileys esperaban obtener ingresos maximizando la subasta para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, los mecanismos sólo permiten la maximización del pago. En la práctica, el diseñador también puede estar interesado en el resultado per se. Por ejemplo, un subastador puede importarle qué ofertante recibe el artículo. • A menudo se supone que los pagos paralelos pueden utilizarse para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en el trueque, tales como Recipco, firstbarter.com, BarterOne, e Intagio-side pagos no están permitidos. Además, entre los agentes de software, podría ser más conveniente construir mecanismos que no dependan de la capacidad de hacer pagos, porque muchos agentes de software no tienen la infraestructura para hacer pagos. En cambio, seguimos un enfoque reciente en el que el mecanismo se diseña automáticamente para el problema específico que nos ocupa. Este enfoque aborda todas las desventajas enumeradas anteriormente. Formulamos el problema del diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los tipos posibles de agentes (preferencias) y las distribuciones previas de agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizados. El enfoque automatizado del diseño de mecanismos tiene cuatro ventajas sobre el enfoque clásico del diseño de mecanismos generales. En primer lugar, puede utilizarse incluso en entornos que no satisfacen los supuestos de los mecanismos clásicos (como la disponibilidad de pagos secundarios o que el objetivo es el bienestar social). En segundo lugar, puede permitir eludir los resultados de la imposibilidad (como el teorema de Gibbard-Satterthwaite) que declara que no hay ningún mecanismo que sea deseable en todas las preferencias. Cuando el mecanismo está diseñado para el entorno en cuestión, no importa que no funcione de manera más general. En tercer lugar, puede dar mejores mecanismos (en términos de garantías de no manipulación más fuertes y/o mejores resultados) que los mecanismos clásicos porque el mecanismo capitaliza los detalles del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Habida cuenta de la gran cantidad de información que las partes tienen sobre las demás hoy en día, es probable que este enfoque genere enormes ahorros en relación con los mecanismos clásicos, que en gran medida ignoran esa información. Por ejemplo, imagínese que una empresa crea automáticamente su mecanismo de contratación sobre la base de conocimientos estadísticos acerca de sus proveedores, en lugar de utilizar una subasta clásica de contratación descendente. En cuarto lugar, la carga del diseño se desplaza de los seres humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño de mecanismos se resuelva de nuevo para cada configuración. De ahí que su complejidad computacional se convierta en un tema clave. Investigaciones anteriores han estudiado esta cuestión para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este trabajo se estudia la complejidad computacional del diseño de mecanismos automatizados en el caso de un diseñador interesado. Este es un entorno importante para el diseño automatizado de mecanismos debido a la escasez de mecanismos generales en esta área, y el hecho de que en la mayoría de los entornos de comercio electrónico el diseñador es interesado. También mostramos que este problema está estrechamente relacionado con un problema particular de diseño de subastas combinatoria óptima (revenue-maximizing). 133 El resto de este documento está organizado de la siguiente manera. En la sección 2, justificamos el enfoque en los mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, mostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando el diseñador sólo se preocupa por los pagos hechos a él. En la Sección 5, mostramos que diseñar un mecanismo determinista óptimo es también NP-completo cuando los pagos no son posibles y el diseñador sólo está interesado en el resultado elegido. En la Sección 6, mostramos que un mecanismo óptimo aleatorio puede ser diseñado en tiempo polinomio incluso en el caso general. Finalmente, en la Sección 7, mostramos que para diseñar subastas combinatorias óptimas bajo las mejores preferencias, nuestros resultados en AMD implican que este problema es NP-completo para subastas deterministas, pero fácil para subastas aleatorias. 2. JUSTIFICANDO EL FUNCIONAMIENTO EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan de sus tipos estratégicamente y por lo tanto a veces falsamente, aún alcancen mejores resultados (según el objetivo que utilicemos) que cualquier mecanismo no manipulable. Esto, sin embargo, resulta ser el caso: dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan de sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían reportado estratégicamente al mecanismo original, si sus tipos fueran declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; y por lo tanto, los tipos reportados por la capa de interfaz son los tipos estratégicos que se habrían reportado sin la capa de interfaz, por lo que los resultados son exactamente como lo habrían sido con el mecanismo original. Este argumento es conocido en la literatura del diseño del mecanismo como el principio de revelación [16]. (Hay dificultades computacionales para aplicar el principio de revelación en grandes resultados combinatorios y espacios de tipo [7, 22]. Sin embargo, porque aquí nos enfocamos en resultados y espacios de tipo claramente representados, esto no es una preocupación aquí.) En vista de ello, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Formalizamos ahora la configuración de diseño de mecanismos automatizados. Definición 1. En una configuración automatizada del diseño del mecanismo, se nos da: • un conjunto finito de resultados O; • un conjunto finito de agentes N; • para cada agente i, 1. un conjunto finito de tipos . . × N ), y 3. una función de utilidad ui : ­i × O → R; 1 • Una función objetiva cuya expectativa el diseñador desea maximizar. Hay muchas funciones objetivas posibles que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad tenía por cualquier agente). En ambos casos, el diseñador es benevolente, porque el diseñador, en cierto sentido, está persiguiendo la felicidad colectiva de los agentes. Sin embargo, en este artículo, nos centramos en el caso de un diseñador interesado en sí mismo. Un diseñador interesado se preocupa sólo por el resultado elegido (es decir, al diseñador no le importa cómo el resultado se relaciona con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados), y sobre los pagos netos realizados por los agentes, que fluyen al diseñador. Definición 2. Un diseñador interesado en sí mismo tiene una función objetiva dada por g(o) + N i=1 En el caso donde g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En caso de que los pagos no sean posibles, g constituye la función objetiva por sí sola. Ahora definimos los tipos de mecanismos que se están estudiando. Por el principio de la revelación, podemos limitar la atención a los mecanismos de revelación veraz y directa, donde los agentes informan de sus tipos directamente y nunca tienen un incentivo para informar mal de ellos. Definición 3. Se consideran los siguientes tipos de mecanismo: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o : . . × N → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o : •1 2 ×. . .N → O y para cada agente i, una función de selección de pagos . . × N → R, donde . . , n ) indica el pago efectuado por el agente i cuando los tipos comunicados son ­1,. . . , N. 1 Aunque esto sigue la notación estándar de la teoría del juego [16], el hecho de que el agente tiene tanto una función de utilidad y un tipo es tal vez confuso. Los tipos codifican las diversas preferencias posibles que el agente puede resultar tener, y el tipo de agentes no es conocido por el agregador. La función de utilidad es de conocimiento común, pero debido a que el tipo de agentes es un parámetro en la función de utilidad de agentes, el agregador no puede saber lo que es la utilidad de agentes sin conocer el tipo de agentes. 134 • Un mecanismo aleatorio con pagos consiste en una función de selección de la distribución p : 1 × 2 ×. . . × N → P(O), y para cada agente i, una función de selección de pagos . . Hay dos tipos de restricciones en el diseñador en la construcción del mecanismo. 3.1 Limitaciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente tiene que ser al menos tan grande como la utilidad de los agentes de reserva, es decir, la utilidad que el agente recibiría si no participa en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo-y ninguna participación de agentes puede dañar el objetivo de los diseñadores del mecanismo porque, en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está allí. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes pagaran una cantidad infinita.) Este tipo de restricción se llama restricción IR (racionalidad individual). Existen tres posibles limitaciones de IR: ex ante, ex interim y ex post, dependiendo de lo que el agente sepa sobre su propio tipo y los demás tipos al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera nada en absoluto (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si supiera sólo su propio tipo, pero no los de los demás. Ex post IR significa que el agente siempre participaría incluso si supiera todo el mundo tipo. Definiremos las dos últimas nociones de IR formalmente. En primer lugar, tenemos que formalizar el concepto de los resultados secundarios. Asumimos que cada utilidad de reserva de agentes es cero para cada uno de sus tipos. Esto es sin pérdida de generalidad porque podemos agregar un término constante a una función de utilidad de los agentes (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente de maximización de utilidad esperado [16]. Definición 4. En cualquier configuración de diseño de mecanismos automatizados con una restricción de IR, hay un resultado de retroceso o0 O donde, para cualquier agente i y cualquier tipo Łi Łi, tenemos ui(Łi, o0) = 0. (Además, en el caso de un diseñador interesado, g(o0) = 0.) Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (IR) se define por: • Un mecanismo determinista es IR ex interino si para cualquier agente i, y cualquier tipo Łi  i, tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(?i, o(­1,.,­N ))i(­1,.,­N )] ≥ Un mecanismo al azar es IR ex interino si para cualquier agente i, y cualquier tipo de I+D+i, tenemos E(I+1,..,­i+1,..,­N+1,.,­N+i Eo1,..,­n [ui(I+i, o)i(I+1,.,­N )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier tipo de vector (­1,. . . , n ) • 1 ×. . . × N, tenemos ui(?i, o(?1,. . . ............ . . , N-N) ≥ 0. 2 No aleatorizamos los pagos porque mientras los agentes y el diseñador sean neutrales con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar los pagos. Un mecanismo aleatorio es IR ex post si para cualquier agente i, y cualquier tipo de vector (-1,. . . , n ) • 1 ×. . . × N, tenemos Eo1,.., Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 3.2 Limitaciones de compatibilidad de incentivos El segundo tipo de restricción dice que los agentes nunca deben tener un incentivo para informar mal de su tipo (como se ha justificado anteriormente por el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes, y la implementación en equilibrio Bayes-Nash. Definición 6. Dado un entorno automatizado de diseño de mecanismos, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si la veracidad siempre es óptima incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier tipo de vector (­1,. . . .... . . , n ) • 1 ×. . . × Łi ×. . . En el caso de los mecanismos deterministas, tenemos ui(?i, o(?1,. . . .... . . ............ . . .... . . , n ) ≥ ui(l, o(l1,. . . , i,. . . ............ . . , i,. . . , N). En el caso de los mecanismos aleatorios tenemos Eo1,..,l,..,ln [ui(l, o) - li(l1,. . . .... . . .............. . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, la veracidad es óptima independientemente de lo que los otros agentes informen. Si es óptimo sólo dado que los otros agentes son veraces, y dado que uno no conoce los otros tipos de agentes, tenemos implementación en el equilibrio Bayes-Nash. Definición 7. Dado un ajuste automatizado del diseño del mecanismo, se dice que un mecanismo implementa sus funciones de resultado y pago en el equilibrio de Bayes-Nash si la veracidad siempre es óptima para un agente cuando ese agente todavía no sabe nada sobre los otros tipos de agentes, y los otros agentes están diciendo la verdad. Formalmente, en el caso de cualquier agente i, cualquier tipo de فارسىi i, y cualquier informe de tipo alternativo i i, en el caso de los mecanismos deterministas tenemos E(­1,..,­i−1,­i+1,..,­N )i [ui(­i, o(­1,. . . .... . . , N. ))— (n. . . .... . . , ­N )] ≥ E(­1,..,­i­1,­i+1,..,­N )­i [ui(­i, o(­1,. . . , i,. . . , N. ))— (n. . . , i,. . . , N)]. En el caso de los mecanismos aleatorios tenemos E(­1,..,­i­1,­i+1,..,­N )i Eo­1,..,­i,..,­n [ui(­i, o)­'i(­1,. . . .... . . ......... . . , i,. . . , N)]. Las condiciones relativas a los pagos pueden excluirse en caso de que los pagos no sean posibles. 135 3.3 Diseño automatizado de mecanismos Ahora podemos definir el problema computacional que estudiamos. Definición 8. (AUTOMATED-MECHANISM-DESIGN (AMD)) Se nos da: • una configuración automatizada del diseño del mecanismo, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión Un caso especial interesante es el escenario donde sólo hay un agente. En este caso, el agente informador siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que ex post y ex interim IR sólo difieren en lo que se supone que un agente sabe sobre otros tipos de agentes, los dos conceptos IR coinciden aquí. Además, debido a que la implementación en estrategias dominantes y la implementación en el equilibrio Bayes-Nash sólo difieren en lo que se supone que un agente conoce sobre otros tipos de agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar los resultados de dureza: si probamos la dureza computacional en la configuración de un solo agente, esto implica inmediatamente dureza para ambos conceptos IR, para ambos conceptos de solución, para cualquier número de agentes. 4. PAGO-MAXIMIZACIÓNDETERMINÍSTICA ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la suma esperada de los pagos recaudados de los agentes. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar NPhardness, reducimos el problema del MINSAT. Definición 9 (MINSAT). Se nos da una fórmula en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < C). Se nos pregunta si existe una asignación a las variables en V de tal manera que a lo sumo las cláusulas K en Recientemente se demostró que el MINSAT era NP completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. Pago-máximo determinista AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar la dureza de NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista maximizante de un solo agente. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c { C} {ol : l { L}, donde L es el conjunto de literales, es decir, L = {v : v } V } { v } {v : v } V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(c, ol) =  + 1 para todos los l+L con l+c; u(c, ol) = 0 para todos los l+c; u(c, ol) = 0 para todos los l+c con l+c; u(c, ol) = = 0 para todos los l+ Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € ¬ V, dejar o(­v) = de(v) y η(­v) =. Por cada c C, dejar o(­)c) = oc; dejar η(­)c) =  + 1 si c no está satisfecho en la solución MINSAT, y η(­)c) =  si c está satisfecho. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agente es algún Łv, entonces cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agente es algún tipo de c donde c es una cláusula satisfecha, de nuevo, cualquier otro informe le dará un resultado que no es mejor, para un pago que no es menor, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo además de Łc conduce al resultado oc, reportando cualquier otro tipo dará un resultado con utilidad 0, mientras que todavía forzando un pago de al menos  del agente. Claramente, el agente está mejor informando verazmente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (por lo que s ≤ K), el pago esperado de este mecanismo es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución a la instancia AMD Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o y una función de pago En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. Entonces la utilidad que el agente deriva del resultado dado para este tipo es 0, y por lo tanto, por IR, ningún pago puede ser extraído del agente para este tipo. Porque, de nuevo por IR, el pago máximo que se puede extraer para cualquier otro tipo es  + 1, se deduce que el pago máximo esperado que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. 136 Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo es. Debido a que no puede haber incentivos para que el agente a informar falsamente, para cualquier cláusula c satisfecho por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente es. (Porque si extrajimos más de este tipo, la utilidad de los agentes en este caso sería menos de 1; y si v es la variable satisfaciendo c en la asignación, de modo que o(?v) = ol donde l se produce en c, entonces el agente sería mejor de informar?v en lugar del informe veraz?c, para obtener un resultado vale 1 a él mientras que tiene que pagar a lo sumo. Por último, para cualquier cláusula insatisfecha c, por la restricción IR, el pago máximo que podemos extraer para el tipo correspondiente es  + 1. De ello se deduce que el pago esperado de nuestro mecanismo es a lo sumo V s(Cs)(1), donde s es el número de cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Debido a que AMD maximizante de pago es sólo el caso especial de AMD para un diseñador interesado en el que el diseñador no tiene preferencias sobre el resultado elegido, esto inmediatamente implica dureza para el caso general de AMD para un diseñador interesado en los pagos posibles. Sin embargo, todavía no implica dureza para el caso especial en el que los pagos no son posibles. Demostraremos dureza en este caso en la siguiente sección. 5. MEDICIÓN DETERMINÍSTICA AUTOINTERESTICA SIN PAGO ES DURA En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo de los diseñadores cuando los pagos no son posibles. Demostramos que este problema es difícil incluso en la configuración de un solo agente, mostrando así inmediatamente difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, AMD determinista para un diseñador interesado es NP completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para mostrar dureza NP, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD autointeresada de un solo agente sin pagos. Deje que el tipo de agentes se establezca en la instancia de MINSAT, donde C es el conjunto de cláusulas, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Que el conjunto de resultados sea O = {o0} {oc : c  Col : l  Lo* }, donde L es el conjunto de literales, es decir, L = v : v  V }  v : v  V }. Dejemos que la notación v(l) = v denote que v es la variable correspondiente a la literal l, es decir, l â € € € € € TM v, â v}. Entonces, deje que la función de utilidad de los agentes sea dada por u(­c, ol) = 2 para todos los l • L con l • c; u(­c, ol) = -1 para todos los c • C con c = c; u(­c, o* ) = 1; u(­v, ol) = 1 para todos los l • L con v(l Deje que la función objetiva de los diseñadores sea dada por g(o* ) = 1; g(ol) =  para todos l  L; g(oc) =  para todos c  C. El objetivo de la instancia AMD es G =  + CK , donde K es el objetivo de la instancia MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución a la instancia del MINSAT. Dejemos que la asignación de valores de verdad a las variables en esta solución sea dada por la función f : V → L (donde v(f(v)) = v para todos v • V ). Entonces, para cada v â € V, dejar o(â v) = de (v). Por cada c C que esté satisfecho en la solución de MINSAT, déjese o(­c) = oc; por cada c • C insatisfecho, déjese o(­c) = o*. Es sencillo comprobar que la restricción de IR está satisfecha. Ahora comprobamos que el agente no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de V, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. Si el tipo de agentes es algún tipo de c donde c es una cláusula satisfecha, de nuevo, está obteniendo la máxima utilidad para ese tipo, por lo que no tiene ningún incentivo para informar mal. El caso final a comprobar es donde el tipo de agentes es algún Łc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informar de que conduce a un resultado ol para un literal l â € c, precisamente porque la cláusula no se cumple en la instancia MINSAT. Porque también, ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo siempre selecciona que daría a la utilidad del agente mayor que 1 para el tipo oc, y por lo tanto el agente no tiene ningún incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar mal. Por último, demostramos que se ha alcanzado el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetiva de los diseñadores es V s(Cs)(1)  ≥ V K(CK)(1)  =  + CK  = G. Así que hay una solución Ahora supongamos que hay una solución a la instancia AMD, dada por una función de resultado o. En primer lugar, supongamos que hay algunos v â € V tales que o(?v) /â {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción IR es o0. Esto tiene un valor objetivo de 0, y porque el valor más alto que la función objetiva toma es  + 1, se deduce que el valor máximo esperado de la función objetiva que se podría obtener es a lo sumo (1)(1)  <  < G, contradiciendo que esta es una solución a la instancia AMD. De ello se deduce que en la solución a la instancia de AMD, para cada v â € ¬ V, o(?v) â € {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece a true si o(lv) = o+v, y a false si o(lv) = o−v. Afirmamos que esta asignación es una solución para la instancia del MINSAT. Por el antedicho, para cualquier tipo de Łv, el valor de la función objetiva en este mecanismo será. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetiva en el caso en que los informes del agente tipo Łc será a lo sumo. (Esto se debe a que no podemos elegir el resultado o* para tal tipo, ya que en este caso el agente tendría un incentivo para informar a la v en su lugar, donde v es la variable satisfaciendo c en la asignación (de modo que o(Łv) = ol donde l ocurre en c).) Por último, para cualquier cláusula insatisfecha c, el valor máximo de la función objetivo puede tomar en el caso de que los informes de agente tipo Łc es  + 1, simplemente porque este es el valor más grande que la función toma. De ello se deduce que el valor esperado de la función objetiva para nuestro mecanismo es a lo sumo V s(Cs)(1) فارسى, donde s es el número de 137 cláusulas satisfechas. Debido a que nuestro mecanismo logra la meta, se deduce que V s(Cs)(1)  G, que por manipulaciones algebraicas simples es equivalente a s ≤ K. Así que hay una solución a la instancia MINSAT. Ambos de nuestros resultados de dureza se basan en la limitación de que el mecanismo debe ser determinista. En la siguiente sección, mostramos que la dureza del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. AMD RANDOMIZADA PARA UN DISEÑADOR AUTOINTERESTADO ES FÁCIL Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea tratable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. La DMAE aleatoria auto-interesada con un número constante de agentes es solvable en tiempo polinomio por programación lineal, tanto con y sin pagos, tanto para IR ex post como ex interim, y tanto para implementación en estrategias dominantes como para implementación en equilibrio Bayes-Nash-incluso si los tipos están correlacionados. Prueba. Debido a que los programas lineales pueden ser resueltos en tiempo polinomio [13], todo lo que necesitamos mostrar es que el número de variables y ecuaciones en nuestro programa es polinomio para cualquier número constante de agentes-es decir, exponencial sólo en N. A lo largo, con el fin de determinar el tamaño del programa lineal, dejar T = maxii. Las variables de nuestro programa lineal serán las probabilidades (p(­1, ­2,. . . )(o) (en la mayoría de las variables TN O) y los pagos . . (en la mayoría de las variables NTN). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o añadiendo restricciones adicionales que obligan a los pagos a ser 0.) Primero, mostramos las limitaciones de IR. Para IR ex post, añadimos las siguientes restricciones (como máximo NTN ) al LP: • Por cada i • {1, 2,. . . , N}, y por cada (-1, -2,. . . , n ) 1 × 2 ×. . . × N, añadimos ( o ́O (p(­1, • 2,. . . ......... . . , N-N) ≥ 0. Para IR ex interim, se añaden las siguientes restricciones (en la mayoría de NT) al LP: • Por cada i â € {1, 2,. . . , N}, por cada 'i', añadimos 'l', 'N', 'N', '('1,'. . . , N i)((O)(p(­1, ­­2,. . . , ln)(o)u(l, o))− li(l1, ü2,. . . )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, añadimos las siguientes limitaciones (como máximo NTN+1 ) al LP: • Por cada i • {1, 2,. . . , N}, por cada (­1, ­2,. . . .... . . , n ) 1 × 2 ×. . . × N, y para cada informe de tipo alternativo i  i, añadimos la restricción ( oO (p(1, 2,. . . .... . . ......... . . .... . . , N ) ≥ ( o ́O (p(­*1, ­*2,. . . , i,. . . ......... . . , i,. . . , N). Por último, para la aplicación en el equilibrio Bayes-Nash, añadimos las siguientes limitaciones (en la mayoría de NT2 ) al LP: • Por cada i â € 1, 2,..., N}, por cada â € € € €, y por cada informe de tipo alternativo â € € €, agregamos la restricción â € € € €, € Todo lo que queda por hacer es dar la expresión que el diseñador está tratando de maximizar, que es: • ­1,...,­N γ(­1,...,­N)((­p(­1,­2,­,­i,­N))(o)g(o)) + N i=1­I(­1,­2,­N)). Como hemos indicado, el número de variables y restricciones es exponencial sólo en N, y por lo tanto el programa lineal es de tamaño polinomio para números constantes de agentes. Por lo tanto, el problema es solvable en el tiempo polinomio. 7. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO COMBINATORIO OPTIMAL En esta sección, demostraremos algunas consecuencias interesantes del problema del diseño de mecanismos automatizados para un diseñador interesado en el diseño de subastas combinatorias óptimas. Considere una subasta combinatoria con un conjunto S de artículos para la venta. Para cualquier paquete B  S, let ui(l, B) ser postor es la utilidad para recibir el paquete B cuando el tipo de postores es Łi. El problema óptimo del diseño de la subasta es especificar las reglas de la subasta a fin de maximizar los ingresos esperados para el subastador. (Por el principio de la revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz.) El problema de diseño óptimo de la subasta se resuelve para el caso de un solo artículo por la famosa subasta Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si sólo hay dos artículos en venta. (El caso de dos puntos con una forma muy especial de complementariedad y sin sustituibilidad se ha resuelto recientemente [1].) Supongamos que tenemos artículos de eliminación libre se pueden tirar a la basura sin costo. Además, supongamos que las preferencias de los ofertantes tienen la siguiente estructura: cada vez que un ofertante recibe un paquete de artículos, la utilidad de los ofertantes para ese paquete está determinada por el mejor artículo del paquete solamente. (Enfatizamos que 138 que el artículo es el mejor se permite depender del tipo de ofertantes.) Definición 10. Bidder i se dice que tiene las preferencias de mejor sólo sobre paquetes de elementos si existe una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(i, B) = maxsB vi(i, s). En este contexto, hacemos la siguiente observación útil: no tiene sentido adjudicar a un postor más de un artículo. La razón es que si el concursante está informando con veracidad, quitarle todo el artículo más valorado al concursante no perjudicará al concursante; y, por disposición libre, hacerlo sólo puede reducir el incentivo para que este concursante informe falsamente de este tipo, cuando el concursante realmente tiene otro tipo. Ahora mostramos que el problema de diseñar una subasta óptima determinista aquí es NP-completo, por una reducción del pago maximizando el problema AMD! Teorema 4. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito i y una función vi : i × S → R tal que para cualquier i Łi, para cualquier B  S, ui(Łi, B) = maxsB vi(Łi, s)), el diseño de la subasta Prueba. El problema está en NP porque podemos generar una regla de asignación no determinada, y luego establecer los pagos utilizando la programación lineal. Para mostrar la dureza de NP, reducimos una instancia de AMD determinista de pago arbitrario, con un único agente y una distribución uniforme sobre los tipos, a la siguiente instancia de problema de diseño combinatoria óptima de subastas con un único postor con las mejores preferencias. Para cada resultado o o O en la instancia de AMD (además del resultado o0), deje que haya un elemento así que S. Deje que el espacio de tipo sea el mismo, y deje v(eli, así) = ui(eli, o) (donde u es como se especifica en la instancia de AMD). Que el valor de los ingresos esperados sea el mismo en ambos casos. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución a la instancia AMD, dada por una función de resultado y una función de pago. Entonces, si la solución AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignar {así} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos • al postor.) Deje que las funciones de pago sean las mismas en ambos casos. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución de subasta óptima. Además, como la distribución tipo y la función de pago son las mismas, los ingresos esperados para el subastador/diseñador son los mismos. De ello se deduce que existe una solución a la instancia óptima de diseño de subastas. Ahora supongamos que existe una solución a la instancia óptima de diseño de subastas. Por la observación de casi un elemento, podemos suponer sin pérdida de generalidad que la solución nunca asigna más de un elemento. Entonces, si la solución de subasta óptima asigna el artículo para el postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, deje que el mecanismo elija el resultado o0 para ese tipo. Deje que las funciones de pago sean las mismas. Entonces, la utilidad que un agente recibe para reportar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivo en la solución AMD. Además, debido a que la distribución tipo y la función de pago son los mismos, los ingresos esperados para el diseñador / subastador es el mismo. De ello se deduce que existe una solución a la instancia AMD. Afortunadamente, también podemos llevar a cabo el resultado de facilidad para los mecanismos aleatorios a esta subasta combinatoria setting-dandonos uno de los pocos algoritmos de tiempo polinomio conocidos para un óptimo problema de diseño de subasta combinatoria. Teorema 5. Dado un problema óptimo de diseño de subasta combinatoria bajo las mejores preferencias (dado por un conjunto de elementos S y para cada postor i, un espacio de tipo finito y una función vi : i × S → R de tal manera que para cualquier B  S, ui(l, B) = maxsB vi(l, s)), si el número de postores es una k constante, entonces la subasta aleatoria (Para cualquier restricción IC e IR.) Prueba. Por la observación de casi un elemento, podemos sin pérdida de generalidad limitarnos a las asignaciones donde cada ofertante recibe como máximo un elemento. Hay menos que (S + 1)k tales asignaciones-es decir, un número polinomio de asignaciones. Debido a que podemos enumerar los resultados explícitamente, simplemente podemos resolver esto como una instancia AMD de pago-máxima, con programación lineal. 8. INVESTIGACIÓN RELACIONADA SOBRE LA COMPLEJIDAD EN EL DISEÑO MECANISMO Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Algunos de ellos se han centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo se ha esforzado por diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad del diseño del mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador sólo ha restringido el control sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos secundarios). Además, no hay información explícita sobre las preferencias. 9. CONCLUSIONES E INVESTIGACIÓN FUTURA A menudo, un resultado debe ser elegido sobre la base de las preferencias notificadas por un grupo de agentes. La dificultad clave es que los agentes pueden reportar sus preferencias sin sinceridad para hacer el resultado elegido más favorable a sí mismos. El diseño del mecanismo es el arte de diseñar las reglas del juego para que los agentes estén motivados a informar sus preferencias verazmente, y se elija un resultado deseable. En un enfoque recientemente emergente, llamado diseño automatizado de mecanismos, se calcula un mecanismo para la configuración específica de la agregación de preferencias que se tiene a la mano. Esto tiene varias ventajas, 139, pero la desventaja es que el problema de optimización del diseño de mecanismos necesita ser resuelto de nuevo cada vez. A diferencia de los trabajos anteriores sobre el diseño de mecanismos automatizados que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño de mecanismos automatizados donde el diseñador se interesa mucho más por el comercio electrónico. En este entorno, el centro sólo se preocupa por qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a hacer que cada agente al menos tan bien como el agente habría sido si no hubiera participado en el mecanismo. En este escenario, se demostró que el diseño de un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado sólo en los pagos realizados, y cuando los pagos no son posibles y el centro está interesado sólo en el resultado elegido. Estos resultados de dureza implican dureza en todos los ajustes de diseño de mecanismos automatizados más generales con un diseñador interesado. Los resultados de dureza se aplican tanto si las restricciones individuales de racionalidad (participación) se aplican ex interim o ex post, y si el concepto de solución es la implementación de estrategias dominantes o la implementación del equilibrio Bayes-Nash. Luego mostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos ajustes computacionalmente fácil. Finalmente, demostramos que el problema de AMD maximizante del pago está estrechamente relacionado con una variante interesante del problema de diseño de subastas combinatoria óptima (revenue-maximizador), donde los ofertantes tienen las mejores preferencias. Hemos demostrado que aquí, también, el diseño de un mecanismo determinista óptimo es NP-completo incluso con un agente, pero el diseño de un mecanismo aleatorio óptimo es fácil. La investigación futura incluye el estudio del diseño automatizado de mecanismos con un diseñador interesado en entornos más restringidos como las subastas (donde el objetivo de los diseñadores puede incluir preferencias sobre qué ofertante debe recibir el bien así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde el resultado y los espacios tipo tienen una estructura especial para que puedan ser representados de forma más concisa. Finalmente, planeamos ensamblar un conjunto de datos de problemas de diseño de mecanismos del mundo real -tanto históricos como actuales- y aplicar el diseño automatizado de mecanismos a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Óptimas subastas multiobjeto. Examen de los estudios económicos, 67:45-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y exigir revelación bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. Nueva York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupar y subastas óptimas de múltiples productos. Review of Economic Studies, 67:483-497, 2000. [4] E. H. Clarke. Fijación de precios multiparte de los bienes públicos. Elección pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño del mecanismo. En Actas de la 18a Conferencia Anual sobre Incertidumbre en la Inteligencia Artificial (UAI-02), págs. 103 a 110, Edmonton (Canadá), 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados de la configuración de un solo agente. En Actas de la Quinta Conferencia Internacional sobre Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, USA, 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de la revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Papel corto. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. dAspremont y L. A. G ́erard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou, y S. Shenker. Compartiendo el costo de las transmisiones de muliticast. Revista de Informática y Ciencias del Sistema, 63:21-41, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y rutas más cortas: ¿Qué vale un borde? En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinomio en la programación lineal. Matemáticas soviéticas. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de la satisfacción mínima. SIAM Journal of Discrete Mathematics, 7(2):275-283, 1994. [15] D. Lehmann, L. I. OCallaghan, e Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas, aproximadamente eficientes. Diario de la ACM, 49(5):577-602, 2002. La primera versión apareció en Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston, y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Óptimas subastas multiunidades. En F. Hahn, editor, The Economics of Missing Markets, Information, and Games, capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson. Óptimo diseño de subasta. Matemáticas de la Investigación Operativa, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente viables. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y comportamiento económico, 35:166-196, 2001. Versión inicial en Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Informática (FOCS), 2001. [22] T. Sandholm. Cuestiones en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial en 140 Aplicando Agentes Inteligentes para el Comercio Electrónico. Una breve y temprana versión apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagentes (ICMAS), págs. 299 a 306, 1996. [23] M. A. Satterthwaite. Seguridad estratégica y condiciones de Arrows: teoremas de existencia y correspondencia para los procedimientos de votación y funciones de bienestar social. Journal of Economic Theory, 10:187-217, 1975. [24] W. Vickrey. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatoria. Mimeo, versión 29 de octubre de 2001. 141 ",
            "error": []
        }
    }
}