{
    "original_text": "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept. of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design. However, VCG mechanisms have their limitations. They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function. For many optimization problems, finding the optimal output is computationally intractable. If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful. In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O. In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to. For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property. We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output. In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames. Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1. INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable. The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation. However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents. Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines. The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations. Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP. Some mechanisms other than VCG mechanism are needed to address these issues. Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output. They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem. Auletta et al. [3] studied a similar scheduling problem. They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem. Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods. They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism. The work of Mualem and Nisan [13] is the closest in spirit to our work. They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting. They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems. As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions. More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected. We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type. Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately. In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function. In fact, we do not even require the existence of an objective function. Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property. The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful. We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems. The remainder of the paper is organized as follows. In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games. In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P). A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O. In Section 5, we provide several examples to demonstrate the effectiveness of our general framework. We conclude our paper in Section 6 with some possible future directions. 2. PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain. A standard model for mechanism design is as follows. There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself. For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction. The agents types define the type vector t = (t1, t2, . . . , tn). Each agent i has a set of strategies Ai from which it can choose. For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)). Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents. A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies. For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node. Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O. A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o. Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i. Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti. Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a). Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai. Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i. Sometimes, we write (a−i, bi) as a|i bi. An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i. A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism. An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility. Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti). Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating. A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties. Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11]. The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite. A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i. Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10]. The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function. This makes the mechanism computationally intractable in many cases. Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used. In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n . In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected. Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13]. Hereafter, we make the following further assumptions. 1. The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2. The valuation v(ti, oi) is a publicly known value and is normalized to 0. This assumption is needed to guarantee the IR property. Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative. For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service. Throughout this paper, we will use ci instead of vi in our analysis. All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction. In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game. The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1. The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2. The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function. We even do not require the existence of an objective function. 3. We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism. In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction. In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci. A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ . In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness. Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme. For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0. Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game. Their payment scheme inspired our payment scheme for binary demand game. In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si. They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction. As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability. On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules. In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load. The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load. Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems. Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game. If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output. But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games. The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work. They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12]. They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value. With a simple generalization, we get our conclusion for general binary demand game. They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search. All of their methods required the welfare function associated with the output satisfying bitonic property. Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property. Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction. In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function. Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3. GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful. THEOREM 1. If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ). COROLLARY 2. For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0. THEOREM 3. Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC. The proofs of above theorems are straightforward and thus omitted due to space limit. This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected. Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O. Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)). An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ). This definition is not restricted only to binary demand games. For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1. THEOREM 4. Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1. There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i). When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2. The allocation rule O satisfies MP. 3. There exists a truthful payment scheme P for this binary demand game. PROOF. The proof that Condition 2 implies Condition is straightforward and is omitted here. We then show Condition 3 implies Condition 2. The proof of this is similar to a proof in [13]. To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0. From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i . Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i . When agent i lies its valuation to ci2 , its utility is p1 i − ci1 . Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 . Now consider the scenario when the actual valuation of agent i is ci = ci2 . Its utility is p1 i − ci2 when it reports its true valuation. Similarly, if it lies its valuation to ci1 , its utility is p0 i . Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 . Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 . This inequality implies that ci1 > ci2 , which is a contradiction. We then show Condition 1 implies Condition 3. We prove this by constructing a payment scheme and proving that this payment scheme is truthful. The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0. From condition 1, if Oi(c) = 1 then ci > κi(O, c−i). Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR. In the following we prove that this payment scheme also satisfies IC property. There are two cases here. Case 1: ci < κ(O, c−i). In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0. Now consider the situation when i declares a cost di = ci. If di < κi(O, c−i), then i gets the same payment and utility since it is still selected. If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore. Thus, it has no incentive to lie in this case. Case 2: ci ≥ κ(O, c−i). In this case, when i reveals its true valuation, its payment is 0 and the utility is 0. Now consider the situation when i declares a valuation di = ci. If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected. If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now. Thus, it has no incentive to lie. The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games. The details are omitted here due to space limit. We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O. General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP. If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful. Otherwise, define the payment scheme P as follows. Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i). Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1. THEOREM 5. The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4. COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2. Notice that binary search does not work generally since the valuations of agents may be continuous. We give some general techniques that can help with finding the cut value function under certain circumstances. Our basic approach is as follows. First, we decompose the allocation rule into several allocation rules. Next find the cut value function for each of these new allocation rules. Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions. For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)). Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed. THEOREM 6. With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi . Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property. Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c). PROOF. Assume that ci > ci and Oi(c) = 1. Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1. Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1. This proves that O(c) satisfies MP. The correctness of the cut value function follows directly from Theorem 4. Many algorithms indeed fall into this category. To demonstrate the usefulness of Theorem 6, we discuss a concrete example here. In a network, sometimes we want to deliver a packet to a set of nodes instead of one. This problem is known as multicast. The most commonly used structure in multicast routing is so called shortest path tree (SPT). Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data. Assume that the source node is s and the receivers are Q ⊂ V . For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree. We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P). Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization. We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d). Then the output SPT is defined as W qi∈Q LCP(s,qi) . In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d). The shortest path allocation rule is a utilitarian and satisfies MP. Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c). Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT. THEOREM 7. Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP. Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}. We show that our simple combination generalizes the IF-THENELSE function defined in [13]. For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP. Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively. Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions. By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary. For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category. As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output. Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V . Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0. For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci. We want to find a vertex cover with the minimum weight. Hence, the objective function to be implemented is utilitarian. To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16]. Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules. Many algorithms have been proposed in the literature to approximate the optimal solution. In this paper, we use a 2-approximation algorithm given in [16]. For the sake of completeness, we briefly review this algorithm here. The algorithm is round-based. Each round selects some vertices and discards some vertices. For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover. To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2). Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c). Output: A vertex cover V . 1: Set V = ∅. For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V . If w(j) = 0, add j to V . Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property. Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum. For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario. Typically, a round-based output can be characterized as follows (Algorithm 3). DEFINITION 2. An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 . We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8. A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent. PROOF. Consider an agent i and fixed c−i. We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci. Assume that i is selected in round r with cost ci. Then under cost di, if agent i is selected in a round before r, our claim holds. Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property. Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP. This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n . Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively. Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function. For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1. Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ). Here we updates the cost and setting of the game. Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output. For the example of vertex cover, it is the union of nodes selected in all rounds. Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U. Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ. Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k. Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value. If the round-based output satisfies monotonicity property, the cut-value always exists. We then show how to find the cut value for a selected agent k in Algorithm 4. The correctness of Algorithm 4 is straightforward. To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given. Now we consider the vertex cover problem. For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge. The output satisfies MP. For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected. It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5. Algorithm 5 Compute Cut Value for MVC. Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2. Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG). However, some algorithms cannot be decomposed in the way described in subsection 4.1. Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated. Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm). Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm). For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)). Let us see a concrete example of these combinations. Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V . The Steiner tree problem is to find a set of links with minimum total cost to connect Q. One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H). In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c). The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST. More details will be given in Section 5.2. DEFINITION 3. Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)). The allocation rule of the above definition can be interpreted as follows. An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c). For simplicity, we will use O ◦ F to denote the output of this compound binary demand game. Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property. To study when O ◦F satisfies MP, several necessary definitions are in order. DEFINITION 4. Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1. When Oi(c) = 0, H(c) does not increase over ci. 2. When Oi(c) = 1, H(c) does not decrease over ci. DEFINITION 5. Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0. LEMMA 1. For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1. From the definition of the strong monotonicity property, we have Lemma 1 directly. We now can give a sufficient condition when O ◦ F satisfies the monotonicity property. THEOREM 9. If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP. PROOF. Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1. Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c). There are two scenarios, which will be studied one by one as follows. One scenario is that index k is not chosen by the output function O. From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1. If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci. Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1). Consequently, we have ψj i (c ) = 1. From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1. The other scenario is that index k is chosen by the output function O. First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1. Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c). Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c). Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof. This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output. Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1. Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property. When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y. For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent. In this paper, we assume that given any y, we can find such x in polynomial time. Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i. Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j. THEOREM 10. Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF. In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases. For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused. First, if di < κi then (O ◦ F)i(c|i di) = 1. Without loss of generality, we assume that κi = κi,j for some j. Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi). Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected. Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1. Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk. Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞). In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0. Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1. Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1. Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1. This implies that Fj(c|i di) < τj. Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}. This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction. This finishes our proof. In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian. Thus, we can compute the inverse of F−1 j efficiently. Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive. However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13]. Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare. If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP. From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP. Further, the cut value of the MAX combination can be found by Algorithm 6. As we will show in Section 5, the complex combination can apply to some more complicated problems. 5. CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci. Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn). We want to find a subset of agents D such that U ⊆ S i∈D Si. The selected subsets is called the set cover for U. The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized. Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost. It is well-known that finding the optimal solution is NP-hard. In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem. For the completeness of presentation, we review their method here. Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n). Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge. Here, we consider a more general case in which the type of an agent is (Si, ci). In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si. This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint. We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful. Obviously, the set cover problem is a binary demand game. For the moment, we assume that agent i wont be able to lie about Si. We will drop this assumption later. We show how to design a truthful mechanism by applying our general framework. 1. Check the monotonicity property: The output of Algorithm 7 is a round-based output. Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents. Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents. Consequently, agent i is still selected in round r, which means the output of round r satisfies MP. Now we look into the updating rules. For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent. Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2. Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4. First, we set ci = ∞ and apply Algorithm 7. Let ir be the agent selected in round r and T−i r+1 be the corresponding set. Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |. Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0. We now consider the scenario when agent i can lie about Si. Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si. We argue that agent i will not lie about its elements Si. Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |. Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si. Thus, lying its set as Si will not increase the cut value for each round. Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei. The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V . For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents. The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H). It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20]. The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17]. Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20]. Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q. Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0. The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned. Hereafter, let LST(G) be the final tree constructed using the above method. It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism. We then show how to design a truthful payment scheme using our general framework. Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence. Thus, from Theorem 8, the roundbased output LST satisfies MP. In round r, the cut value for a link ei can be obtained by using the VCG mechanism. Now we set ci = ∞ and execute Algorithm 8. Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞. Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi. Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}. Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used. Assume that Q is the set of receivers, including the sender. Assume that the nodes in a node-weighted graph are all agents. The virtual minimum spanning tree is constructed as follows. Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected. The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism. We then show how to design a truthful mechanism based on the framework we described. 1. Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|. In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|. We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP. From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2. Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST. Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T). Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP. Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|. Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞). Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector. Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST. It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|. Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|. The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3. We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction. In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi. A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ . Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅. Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows. First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids. The first bid is granted. Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted. If it does, it is denied. They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai. It is easy to verify the output of the greedy algorithm is a round-based output. Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after. This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence. In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai. Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all. Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i. Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise. This payment scheme is exactly the same as the payment scheme in [12]. 6. CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game. We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist. We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time. We further presented several general composition-based techniques to compute P efficiently for various allocation rules O. Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time. In this paper, we have concentrated on how to compute P in polynomial time. Our algorithms do not necessarily have the optimal running time for computing P given O. It would be of interest to design algorithms to compute P in optimal time. We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time. Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game. Many works [12, 13] in the mechanism design literature are in this direction. We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given. It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme. In this paper, we have studied mechanism design for binary demand games. However, some problems cannot be directly formulated as binary demand games. The job scheduling problem in [2] is such an example. For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner. It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games. Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ . The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist. Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7. REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents. In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents. In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem. Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods. Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra. On Dominant Strategy Mechanisms. Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games. In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract). In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing. In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J. Characterization of satisfactory mechanisms for the revelation of preferences for public goods. Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y. Truth revelation in approximately efficient combinatorial auctions. Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract. In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design. In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs. In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even. A local ratio theorem for approximating the weighted vertex cover problem. Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985. Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A. Improved steiner tree approximation in graphs. In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. An 11/6-approximation algorithm for the network Steiner problem. Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A. An approximate solution for the steiner problem in graphs. Math. Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders. Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y. Truthful low-cost unicast in selfish wireless networks. In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z. Design multicast protocols for non-cooperative networks. IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks. ACM MobiCom, 2005. 222",
    "original_translation": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222",
    "error_count": 14,
    "keys": {
        "truthful mechanism": {
            "translated_key": [
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo auténtico",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un ",
                " usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo fiel"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de \"mecanismo verdadero\". Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un \"mecanismo verdadero\" M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un \"mecanismo de verdad\" para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio una m-aproximación \"mecanismo de verdad\", donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un \"mecanismo de verdad\". El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un \"mecanismo de verdad\" M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de la monotonicidad es una condición necesaria y suficiente para la existencia de un \"mecanismo verdadero\" M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un \"mecanismo verdadero\" que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un \"mecanismo de verdad\" eficiente para la subasta combinatoria. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dieron un \"mecanismo auténtico\" para subastas combinatorias con agentes de parámetros únicos que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo \"mecanismo de verdad\" debería tener curvas de trabajo decrecientes w y que el pago veraz debería ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de problemas Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del \"mecanismo verdadero\", sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un \"mecanismo de verdad\" si la regla de asignación satisface una cierta propiedad monotonica. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un \"mecanismo de verdad\" usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un \"mecanismo de verdad\" mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un \"mecanismo verdadero\" basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un \"mecanismo de verdad\" eficiente para la subasta combinatoria. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este trabajo, hemos estudiado cómo diseñar un \"mecanismo de verdad\" M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O satisfacer al MP es una condición necesaria y suficiente para que exista un \"mecanismo verdadero\" M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo suposiciones leves sobre las valoraciones si existe un \"mecanismo verdadero\" M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un \"mecanismo fiel\" aproximado para subastas combinatorias con agentes de parámetros únicos. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo auténtico",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un ",
                " usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo de verdad",
                "mecanismo de verdad",
                "mecanismo verdadero",
                "mecanismo verdadero",
                "mecanismo fiel"
            ]
        },
        "binary demand game": {
            "translated_key": [
                "juego de demanda binario",
                "juego de demanda binarias",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de la demanda binaria",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un ",
                " basado en un método de salida O. General Framework 1 Truthful mechanism design for a ",
                " Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "juego de demanda binario",
                "O",
                "O",
                "J",
                "J",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binaria"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un \"juego de demanda binario\", mostramos que un mecanismo veraz M = (O, P) existe para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binarias Un \"juego de demanda binarias\" es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un \"juego de demanda binaria\", si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solvable por VCG mientras que no hay restricción en la función objetiva para un \"juego de demanda binario\". 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un \"juego de demanda binario\", mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un \"juego de demanda binario\". Su esquema de pago inspiró nuestro esquema de pago para \"juego de demanda binaria\". En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un \"juego de demanda binario\". Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para general \"juego de la demanda binaria\". Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el \"juego de demanda binaria\" estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un \"juego de demanda binario\" G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Fijo la configuración S para un \"juego de demanda binario\", si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un \"juego de demanda binaria\", presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar el ajuste S, c-i en un \"juego de demanda binario\" G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero sistema de pago P para este \"juego de demanda binario\". Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un \"juego de demanda binario\" basado en un método de salida O. General Framework 1 Truthful mechanism design for a \"binary demand game\" Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un \"juego de demanda binario\", asumir que hay reglas de asignación m O1, O2, · · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Fijo el ajuste S de un \"juego de demanda binario\", asumir que hay m métodos de salida O1, O2, · · ·, Om satisfacer MP, y (Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del \"juego de demanda binario\" es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro \"juego de demanda binario\" con la configuración S y la regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este compuesto \"juego de demanda binaria\". Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta fija es un \"juego de demanda binaria\". Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este trabajo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un \"juego de demanda binario\". Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de la investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un determinado \"juego de demanda binario\". Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado \"juego de demanda binaria\" tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un \"juego de demanda binaria\" a juegos de demanda no binaria. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "juego de demanda binario",
                "juego de demanda binarias",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de la demanda binaria",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un ",
                " basado en un método de salida O. General Framework 1 Truthful mechanism design for a ",
                " Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "juego de demanda binario",
                "O",
                "O",
                "J",
                "J",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binaria",
                "juego de demanda binario",
                "juego de demanda binario",
                "juego de demanda binaria",
                "juego de demanda binaria"
            ]
        },
        "vickrey-clarke-grove": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ]
        },
        "objective function": {
            "translated_key": [
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una \"función objetiva\" utilitaria (o afín), y su salida debe optimizar la \"función objetiva\". Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la \"función objetiva\" utilitaria, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una \"función objetiva\" utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una \"función objetiva\" g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la \"función objetiva\". De hecho, ni siquiera exigimos la existencia de una \"función objetiva\". Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afines) donde la \"función objetiva\" es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y el conjunto de posibles salidas se supone que es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la \"función objetiva\" en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una \"función objetiva\" utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una \"función objetiva\" g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La \"función objetiva\" es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la \"función objetiva\" para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una \"función objetiva\", mientras que un mecanismo VCG sólo utiliza la salida que optimiza la \"función objetiva\". Ni siquiera requerimos la existencia de una \"función objetiva\". 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la \"función objetiva\" g(o, c), si existe, es continua con respecto al costo ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente es binaria y la regla de asignación satisface una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la \"función objetiva\". Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la \"función objetiva\" a implementar es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de \"función objetiva\" f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una \"función objetiva\" g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de \"función objetiva\" F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la \"función objetiva\" fj y fj es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P iÃ3D ci, que es la \"función objetiva\" a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva",
                "función objetiva"
            ]
        },
        "composition-based technique": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ]
        },
        "combination": {
            "translated_key": [
                "combinación",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de \"combinación\" incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple \"combinación\" generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple \"combinación\" de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir el MAX \"combinación\" en [13]. Suponga que A1 y A2 son dos reglas de asignación para la subasta combinatoria de una sola mente, luego la \"combinación\" MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos que la \"combinación\" MAX(A1, A2) también satisface MP. Además, el valor de corte de la \"combinación\" MAX se puede encontrar en Algoritmo 6. Como veremos en la Sección 5, la compleja \"combinación\" puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Buscar el valor de corte: Aviso VMST es la \"combinación\" de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "combinación",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación",
                "combinación"
            ]
        },
        "selfish wireless network": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ]
        },
        "mechanism design": {
            "translated_key": [
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. Marco general 1 Verdadero ",
                " para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. La familia de los mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el verdadero \"diseño mecánico\". Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco de un \"diseño mecánico\" algorítmico y aplicaron mecanismos VCG a algunos problemas fundamentales en la informática, incluyendo caminos más cortos, árboles mínimos y programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de \"diseño mecánico\" cuyas salidas optimizan la función utilitaria objetiva, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el \"diseño mecánico\" es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el \"diseño mecánico\" es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la salida del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el \"diseño mecánico\" es el mecanismo generalizado de Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de \"diseño mecánico\" se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. Marco general 1 Verdadero \"diseño mecánico\" para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura del \"diseño mecánico\" están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el \"diseño mecánico\" para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Algorítmico \"diseño mecánico\". En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. Marco general 1 Verdadero ",
                " para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico"
            ]
        },
        "pricing": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "pricing"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. \"pricing\" multiparte de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "pricing"
            ]
        },
        "monotonicity property": {
            "translated_key": [
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la ",
                " de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "monotonicidad propiedad",
                "propiedad de monotonicidad",
                "O",
                "O",
                "J",
                "J",
                "propiedad de monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de monotonicidad",
                "monotonicidad propiedad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta \"propiedad de monotonicidad\". Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta \"propiedad de la monotonicidad\" de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta \"propiedad de la monotonicidad\" en un escenario de subasta de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta \"propiedad de monotonicidad\". La \"propiedad de la monotonicidad\" sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta \"propiedad de la monotonicidad\" es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la \"propiedad de la monotonicidad\" de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta \"propiedad de monotonicidad\". Teorema 4 también depende de la \"propiedad de la monotonicidad\", pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente es binaria y la regla de asignación satisface una cierta \"propiedad de monotonicidad\"; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este artículo es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta \"propiedad de la monotonicidad\". 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la \"propiedad de la monotonicidad\" de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación de m O1, O2, · · ·, Om satisfacer la \"monotonicidad propiedad\", y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la \"propiedad de monotonicidad\". Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la \"propiedad de monotonicidad\". Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la \"propiedad de monotonicidad\", el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O â € F como salida si y sólo si satisface la \"propiedad de monotonicidad\". Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función \"monotonicidad propiedad\", si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la fuerte \"propiedad de la monotonicidad\" si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. De la definición de la fuerte \"propiedad de la monotonicidad\", tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € F satisface la \"propiedad de la monotonicidad\". Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la \"propiedad de la monotonicidad\" y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la \"propiedad de monotonicidad\". Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la \"propiedad de la monotonicidad\" de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la \"propiedad de monotonicidad\": La salida de Algoritmo 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la \"propiedad de la monotonicidad\": Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde el Teorema 9, la regla de asignación VMST satisface la \"propiedad de monotonicidad\". 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la ",
                " de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "monotonicidad propiedad",
                "propiedad de monotonicidad",
                "O",
                "O",
                "J",
                "J",
                "propiedad de monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de monotonicidad",
                "monotonicidad propiedad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad",
                "propiedad de la monotonicidad",
                "propiedad de monotonicidad"
            ]
        },
        "cut value function": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la ",
                " bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. Siguiente encontrar la ",
                " para cada una de estas nuevas reglas de asignación. Entonces, calculamos la ",
                " original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la ",
                " combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "función de valor de corte",
                "función de valor de corte",
                "función de valor de corte",
                "función de valor de corte",
                "(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la ",
                " cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Para probar la corrección de la ",
                " calculada por Algoritmo 6, probamos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la "
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la \"función de valor de corte\" bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. Siguiente encontrar la \"función de valor de corte\" para cada una de estas nuevas reglas de asignación. Entonces, calculamos la \"función de valor de corte\" original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la \"función de valor de corte\" combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la \"función de valor de corte\" sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Por lo tanto, a partir del Teorema 6, SPT también satisface MP, y el vector de \"función de valor de corte\" para SPT puede calcularse como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de \"función de valor de corte\" para el camino más corto LCP( En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la \"función de valor de corte\" para O es \"(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la \"función de valor de corte\" cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Para probar la corrección de la \"función de valor de corte\" calculada por Algoritmo 6, probamos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la \"función de valor de corte\" para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la ",
                " bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. Siguiente encontrar la ",
                " para cada una de estas nuevas reglas de asignación. Entonces, calculamos la ",
                " original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la ",
                " combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "función de valor de corte",
                "función de valor de corte",
                "función de valor de corte",
                "función de valor de corte",
                "(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la ",
                " cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Para probar la corrección de la ",
                " calculada por Algoritmo 6, probamos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la "
            ]
        },
        "selfish agent": {
            "translated_key": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J"
            ]
        },
        "price": {
            "translated_key": [
                "precio",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "precio"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un juego de demanda binaria, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un juego de demanda binaria, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un juego de demanda binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con \"precio\" privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de la demanda binaria. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un juego de demanda binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el juego de demanda binaria general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el juego de demanda binaria estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un juego de demanda binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un juego de demanda binaria, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un juego de demanda binaria G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este juego de demanda binaria. Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un juego de demanda binario, asumir que hay reglas de asignación m O1, O2, · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un juego de demanda binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfaciendo MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) satisface Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro juego de demanda binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este juego de demanda binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un juego de demanda binaria. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente I quiere comprar un subconjunto Si  S con el máximo \"precio\" mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un juego de demanda binario dado. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado juego de demanda binaria tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "precio",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un juego de demanda binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian demand game Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "O",
                "O",
                "J",
                "J",
                "precio"
            ]
        },
        "demand game": {
            "translated_key": [
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un ",
                " binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian ",
                " Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "juego de demanda",
                "O",
                "O",
                "J",
                "J",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda"
            ],
            "translated_annotated_text": "Hacia mecanismos veraces para juegos de demanda binarias: Un marco general Ming-Yang Kao ∗ Dept. de Ciencias de la Computación Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. de Informática Instituto de Tecnología de Illinois Chicago, IL, EE.UU. xli@cs.iit.edu WeiZhao Wang Dept. Instituto de Tecnología de Informática de Illinois Chicago, IL, USA wangwei4@iit.edu RESUMEN La familia de mecanismos de Vickrey-Clarke-Groves (VCG) es sin duda el logro más célebre en el diseño de mecanismos veraces. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Sólo se aplican a problemas de optimización con una función objetiva utilitaria (o afín), y su salida debe optimizar la función objetiva. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos VCG a algoritmos de tiempo polinomio que se aproximan a la solución óptima, los mecanismos resultantes pueden dejar de ser veraces. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un verdadero esquema de pago no VCG que sea computacionalmente manejable para una regla de asignación O dada. En este artículo, centramos nuestra atención en juegos de demanda binaria en los que los agentes sólo acciones disponibles son para participar en el juego o no. Para estos problemas, demostramos que existe un mecanismo veraz M = (O, P) con un método de pago adecuado P if la regla de asignación O satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar tal P. Proponemos además varias técnicas generales basadas en la composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P puede ser computada a través o/y combinaciones, combinaciones basadas en ronda, y algunas combinaciones más complejas de las salidas de subjuegos. Categorías y Descriptores de Temas F.2 [Análisis de algoritmos y complejidad de problemas]: General; J.4 [Ciencias Sociales y Conductuales]: Economía; K.4.4 [Computadora y Sociedad]: Comercio Electrónico Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y fiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos donde los agentes son egoístas en lugar de altruistas, es más razonable asumir que estos agentes son racionales - maximizar sus propias ganancias - de acuerdo con la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño de mecanismos algorítmicos y aplicaron mecanismos VCG a algunos problemas fundamentales de la informática, incluidos los caminos más cortos, los árboles mínimos que se extienden y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño de mecanismos cuyas salidas optimizan la función de objetivo utilitario, que es simplemente la suma de todas las valoraciones de los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias; incluso para aquellos problemas con una función objetiva utilitaria, a veces es imposible encontrar la salida óptima en tiempo polinomio a menos que P=NP. Se necesitan otros mecanismos distintos del mecanismo VCG para abordar estas cuestiones. Archer y Tardos [2] estudiaron un problema de programación donde es NP-Hard para encontrar la salida óptima. Señalaron que una cierta propiedad de la monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al. [3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos de verdad determinista (2 + )-aproximación para cualquier número fijo de máquinas y varios mecanismos de verdad (1 + ) para algunas restricciones duras NP de su problema de programación. Lehmann et al. [12] estudió la subasta combinatoria única y dio un mecanismo de m-aproximación veraz, donde m es el número de mercancías. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el más cercano en espíritu a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una cierta propiedad de monotonicidad en un escenario de subastas de mente única. También mostraron cómo utilizar MAX y IF-THEN-ELSE para combinar las salidas de subproblemas. Como se muestra en este artículo, las combinaciones MAX y IF-THEN-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en tiempo polinomio bajo supuestos leves. Más en general, estudiamos cómo diseñar mecanismos veraces para juegos de demanda binarias donde la asignación de un agente se selecciona o no se selecciona. También suponemos que las valoraciones 213 de los agentes no están relacionadas, es decir, la valoración de un agente sólo depende de su propia asignación y tipo. Recordemos que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un sistema de pago P. Anteriormente, a menudo se asume que hay una función objetiva g y una regla de asignación O, que optimiza g exactamente o aproximadamente. A diferencia de los mecanismos VCG, no se requiere que la asignación optimice la función objetiva. De hecho, ni siquiera se requiere la existencia de una función objetiva. Dada cualquier regla de asignación O para un \"juego de demanda\" binario, mostramos que existe un mecanismo veraz M = (O, P) para el juego si y sólo si O satisface una cierta propiedad de monotonicidad. La propiedad de la monotonicidad sólo garantiza la existencia de un sistema de pago P tal que (O, P) es veraz. Complementamos este teorema de existencia con un marco general para diseñar tal esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subjuegos a través de los operadores o y y; a través de combinaciones redondas; o a través de resultados intermedios, que pueden ser ellos mismos calculados a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos los preliminares y trabajos anteriores, definimos los juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que O satisfacer una cierta propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). A continuación, en la sección 4 se propone un marco para calcular el pago P en tiempo polinomio para varios tipos de normas de asignación O. En la sección 5, proporcionamos varios ejemplos para demostrar la eficacia de nuestro marco general. Concluimos nuestro trabajo en la Sección 6 con algunas posibles direcciones futuras. 2. PRELIMINARIOS 2.1 Diseño de Mecanismos Como se suele hacer en las literaturas sobre el diseño de algoritmos o protocolos con insumos de agentes individuales, en la economía neoclásica adoptamos el supuesto de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviarán del protocolo sólo si la desviación mejora su ganancia. Un modelo estándar para el diseño de mecanismos es el siguiente. Hay n agentes 1,. . . , n y cada agente i tiene alguna información privada ti, llamado su tipo, sólo conocido por sí mismo. Por ejemplo, el tipo ti puede ser el costo en el que incurra el agente para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el tipo vector t = (t1, t2,. . . , tn). Cada agente i tiene un conjunto de estrategias Ai de la que puede elegir. Para cada vector de entrada a = (a1,. . . , a) donde el agente i juega la estrategia ai Ai, el mecanismo M = (O, P) calcula una salida o = O(a) y un vector de pago p(a) = (p1(a),. . . , pn(a)). Aquí el pago pi(·) es el dinero dado al agente i y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración para el juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que el juego comience y no dependen de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento unicast [14], la configuración consiste en la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este artículo, a menos que se mencione explícitamente lo contrario, la configuración S del juego es fija y sólo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v(ti, o) asigna una cantidad monetaria al agente i para cada posible salida o. Todo sobre un juego S, M, incluyendo la configuración S, la regla de asignación O y el sistema de pago P, es de conocimiento público excepto el agente es real tipo ti, que es información privada al agente i. Dejar ui(ti, o) denotar la utilidad del agente i en el resultado del juego o, dadas sus preferencias ti. Aquí, siguiendo una suposición común en la literatura, asumimos que la utilidad para el agente i es cuasi-lineal, es decir, ui(ti, o) = v(ti, o) + Pi(a). Que ai ai = (a1, · · ·, ai−1, ai, ai+1, · · ·, an), es decir, cada agente j = i juega una acción aj excepto que el agente i juega ai. Que a-i = (a1, · ·, ai−1, ai+1, · · ·, an) denote las acciones de todos los agentes excepto i. A veces, escribimos (a-i, bi) como ai bi. Un ai acción se llama dominante para i si (débilmente) maximiza la utilidad de i para todas las estrategias posibles b-i de otros agentes, es decir, ui(ti, O(b-i, ai)) ≥ ui(ti, O(b-i, ai)) para todos ai = ai y b-i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones a disposición de cada agente son reportar su tipo privado de manera veraz o falsa al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa de su tipo ti verazmente, entonces maximizará su utilidad. Entonces, en un mecanismo de revelación directa que satisfaga a IC, el sistema de pago debe satisfacer la propiedad que, para cada agente i, v(ti, O(t)) + pi(t) ≥ v(ti, O(ti ti)) + pi(ti ti). Otro requisito común en la literatura para el diseño de mecanismos es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades IC e IR. El resultado positivo más importante en el diseño de mecanismos es el mecanismo generalizado Vickrey-Clarke-Groves (VCG) de Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetiva es utilitaria g(o, t) = P i v(ti, o) (es decir, la suma de todas las valoraciones de agentes) y se asume que el conjunto de posibles salidas es finito. Un mecanismo de revelación directa M = (O(t), P(t)) pertenece a la familia VCG si (1) la asignación O(t) maximiza P i v(ti, o), y (2) el pago al agente i es pi(t) = P j=i vj(tj, O(t))+ hi (t-i), donde hi () es una función arbitraria de t-i. Bajo supuestos leves, los mecanismos VCG son las únicas implementaciones veraces para problemas utilitarios [10]. La regla de asignación de un mecanismo VCG es necesaria para maximizar la función objetiva en el rango de la función de asignación. Esto hace el mecanismo computacionalmente intratable en muchos casos. Además, la sustitución de un algoritmo óptimo para calcular la salida por un algoritmo de aproximación generalmente conduce a mecanismos falsos si se utiliza un esquema de pago VCG. En este trabajo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetiva utilitaria. 2.2 Juegos de demanda binarias Un \"juego de demanda\" binario es un juego G = (S, M), donde M = (O, P) y el rango de O es {0, 1}n. En otras palabras, la salida es un vector de n-tuple O(t) = (O1(t), O2(t),. . . , On(t)), donde Oi(t) = 1 (respectivamente, 0) significa que el agente i es (respectivamente, no es) seleccionado. Ejemplos de juegos de demanda binaria incluyen: unicast [14, 22, 9] y multicast [23, 24, 8] (generalmente construcción de subgráficos seleccionando algunos enlaces/nodos para satisfacer alguna propiedad), ubicación de la instalación [7], y una cierta subasta [12, 2, 13]. En lo sucesivo, haremos las siguientes suposiciones adicionales. 1. La valoración de los agentes no está correlacionada, es decir, v(ti, o) es una función de v(ti, oi) sólo se denota como v(ti, oi). 2. La valoración v(ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Así, a lo largo de su trabajo, sólo consideramos estos mecanismos de revelación directa en los que cada agente sólo necesita revelar su valoración vi = v(ti, 1). 214 Tenga en cuenta que en las solicitudes en las que los agentes que prestan servicios y reciben pagos, por ejemplo, unicast y la programación del trabajo, la valoración vi de un agente i suele ser negativa. Para la comodidad de la presentación, definimos el costo del agente como ci = −v(ti, 1), es decir, le cuesta al agente i ci prestar el servicio. A lo largo de este trabajo, vamos a utilizar ci en lugar de vi en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar mediante la fijación de ci a negativo, como en la subasta. En un \"juego de demanda\" binario, si queremos optimizar una función objetiva g(o, t), entonces lo llamamos una optimización binaria \"juego de demanda\". Las principales diferencias entre los juegos de demanda binaria y los problemas que pueden ser resueltos por los mecanismos VCG son: 1. La función objetiva es utilitaria (o problema de maximización afín) para un problema solucionable por VCG mientras que no hay restricción en la función objetiva para un \"juego de demanda\" binario. 2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetiva, mientras que un mecanismo VCG sólo utiliza la salida que optimiza la función objetiva. Ni siquiera necesitamos la existencia de una función objetiva. 3. Asumimos que las valoraciones de los agentes no están correlacionadas en un \"juego de demanda\" binario, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo VCG. En este trabajo, suponemos por conveniencia técnica que la función objetiva g(o, c), si existe, es continua con respecto a los costes ci, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación. 2.3 Trabajo anterior Lehmann et al. [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, cada agente i (1 ≤ i ≤ n) sólo quiere comprar un subconjunto Si  S con precio privado ci. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. En [12], se supone que el conjunto de mercancías asignadas a un agente i es Si o فارسى, que se conoce como exactitud. Lehmann et al. dio un algoritmo de asignación basado en ronda codicioso, basado en el rango ai Si1/2, que tiene una relación de aproximación  m, donde m es el número de mercancías en S. Basado en el algoritmo de aproximación, dieron un esquema de pago veraz. Para una regla de asignación que satisfaga (1) exactitud: el conjunto de bienes asignados a un agente i es Si o •; (2) monotonicidad: proponer más dinero para menos bienes no puede hacer que un postor pierda su oferta, propusieron un plan de pago veraz como sigue: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta; (2) cobrar a un postor perdedor 0. Note que la suposición de exactitud revela que la subasta de una sola mente es de hecho un \"juego de demanda\" binario. Su esquema de pago inspiró nuestro esquema de pago para el \"juego de demanda\" binario. En [1], Archer et al. estudió las subastas combinatoria donde múltiples copias de muchos artículos diferentes están a la venta, y cada postor i desea sólo un subconjunto Si. Diseñaron un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para subastas combinatoria con agentes de un solo parámetro que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente veraz en el sentido de que es veraz con alta probabilidad 1 −, donde es una probabilidad de error. Por el contrario, en este trabajo, estudiamos cómo diseñar un mecanismo determinista que sea veraz basado en algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios donde cada agente de información privada se expresa naturalmente por un único número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi lineal t · w, donde t es el privado por costo unitario y w es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debe tener curvas de trabajo decrecientes w y que el pago veraz debe ser Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Utilizando este modelo, Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluyendo minimizar el lapso, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de Observe cuando la carga de los problemas es w = {0, 1}, es de hecho un \"juego de demanda\" binario. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes w implica exactamente la propiedad de la monotonicidad de la salida. Pero note que su prueba se basa en gran medida en la suposición de que la salida es una función continua del costo, por lo tanto su conclusión no puede aplicarse directamente a los juegos de demanda binarias. El papel de Ahuva Mualem y Noam Nisan [13] está más cerca en espíritu de nuestro trabajo. Afirmaron claramente que sólo discutimos una clase limitada de postores, oferentes de mente única, que fue introducida por [12]. Demostraron que todos los mecanismos veraces deben tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una simple generalización, obtenemos nuestra conclusión para el \"juego de demanda\" binario general. Ellos propusieron varios métodos de combinación incluyendo MAX, construcción de IF-THEN-ELSE para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la propiedad bitónica satisfactoria de salida. Distinción entre nuestras contribuciones y los resultados anteriores: Se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de una sola mente, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta propiedad monotonicity. El teorema 4 también depende de la propiedad de la monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de una sola mente. Además, el \"juego de demanda\" binario estudiado aquí es diferente de las IPs de embalaje tradicionales: sólo se requiere que la asignación a cada agente es binario y la regla de asignación satisface una cierta propiedad de monotonicidad; no ponemos ninguna restricción a la función objetiva. Además, el objetivo principal de este documento es diseñar algunas técnicas generales para encontrar el sistema de pago veraz para una regla de asignación dada O satisfacer una cierta propiedad de monotonicidad. 3. ENFOQUES GENERALES 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos necesitan satisfacer para ser veraces. Teorema 1. Si un mecanismo M = (O, P) satisface IC, entonces Łi, si Oi(ti ti1 ) = Oi(ti ti2 ), entonces pi(ti ti1 ) = pi(ti ti2 ). COROLLARY 2. Para cualquier mecanismo a prueba de estrategia para un \"juego de demanda\" binario G con ajuste S, si fijamos el costo c-i de todos los agentes que no sean i, el pago a agente i es una constante p1 i si Oi(c) = 1, y es otra constante p0 i si Oi(c) = 0. Teorema 3. Corregido el ajuste S para un \"juego de demanda\" binario, si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P ) con el mismo método de salida O y pi(c) = pi(c) − Las pruebas de los teoremas superiores son directas y por lo tanto omitidas debido al límite de espacio. Este teorema implica que para los juegos de demanda binarios siempre podemos normalizar el pago a un agente i de tal manera que el pago al agente es 0 cuando no está seleccionado. En lo sucesivo, sólo estudiaremos los sistemas de pago normalizados. 215 3.2 Existencia de mecanismos a prueba de estrategias Aviso, dada la configuración S, un problema de diseño de mecanismos se compone de dos partes: la regla de asignación O y un sistema de pago P. En este documento, dada una regla de asignación O centramos nuestra atención en cómo diseñar un sistema de pago veraz basado en O. Dada la regla de asignación O para un \"juego de demanda\" binario, presentamos en primer lugar una condición suficiente y necesaria para la existencia de un sistema de pago veraz P. DEFINICIÓN 1 (MONOTA PROPIEDAD NO AUMENTO (MP)). Se dice que un método de salida O satisface la propiedad monotona sin aumento si para cada agente i y dos de sus posibles costos ci1 < ci2, Oi(ci ci2 ) ≤ Oi(ci ci1 ). Esta definición no se limita sólo a los juegos de demanda binarias. Para los juegos de demanda binaria, esta definición implica que si Oi(ci ci2 ) = 1 entonces Oi(ci ci1 ) = 1. Teorema 4. Fijar la configuración S, c-i en un \"juego de demanda\" binario G con la regla de asignación O, las tres condiciones siguientes son equivalentes: 1. Existe un valor de Oi(O, c-i)(que llamaremos un valor de corte, de tal manera que Oi(c) = 1 si ci <?i(O, c-i) y Oi(c) = 0 si ci >?i(O, c-i). Cuando la ci = O, c-i, Oi(c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. En lo sucesivo, no vamos a considerar el escenario de desempate en nuestras pruebas. 2. La regla de asignación O satisface al MP. 3. Existe un verdadero esquema de pago P para este binario \"juego de demanda\". Prueba. La prueba de que la Condición 2 implica Condición es directa y se omite aquí. Luego mostramos que la Condición 3 implica la Condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente i y dos vectores de valoración ci ci1 y ci ci2, donde ci1 < ci2, Oi(ci ci2 ) = 1 y Oi(ci ci1 ) = 0. De corolario 2, sabemos que pi(ci ci1 ) = p0 i y pi(ci ci2 ) = p1 i. Ahora fijar c-i, la utilidad para i cuando ci = ci1 es ui(ci1 ) = p0 i. Cuando el agente i miente su valoración a ci2, su utilidad es p1 i − ci1. Puesto que M = (O, P) es veraz, tenemos p0 i > p1 i − ci1. Ahora considere el escenario cuando la valoración real del agente i es ci = ci2. Su utilidad es p1 i − ci2 cuando reporta su verdadera valoración. Del mismo modo, si se basa en su valoración a ci1, su utilidad es p0 i. Puesto que M = (O, P) es veraz, tenemos p0 i < p1 i − ci2. En consecuencia, tenemos p1 i −ci2 > p0 i > p1 i −ci1. Esta desigualdad implica que ci1 > ci2, que es una contradicción. Luego mostramos que la Condición 1 implica Condición 3. Lo demostramos construyendo un sistema de pago y demostrando que este sistema de pago es veraz. El esquema de pago es: Si Oi(c) = 1, entonces el agente i recibe pago pi(c) = O, c-i; de lo contrario recibe pago pi(c) = 0. De la condición 1, si Oi(c) = 1 entonces ci > Łi(O, c-i). Por lo tanto, su utilidad es la de \"i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un \"juego de demanda\" binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian \"demand game\" Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término \"O\", c) para denotar un vector de n-tuple (-O, c-1), \"O, c-2),. . . , n(O, c-n)). Aquí, el valor de corte para el agente i cuando la regla de asignación es O y los costos c-i de todos los demás agentes son fijos. Teorema 6. Con un ajuste fijo S de un \"juego de demanda\" binario, asumir que hay reglas de asignación m O1, O2, · · · ·, Om satisfacer la propiedad de monotonicidad, y (Oi, c) es el vector de valor de corte para Oi. Entonces la regla de asignación O(c) = Wm i=1 Oi (c) satisface la propiedad de monotonicidad. Por otra parte, el valor de corte de O es el término \"O\" (O, c) = máxm i=1(Oi, c)} Aquí significa \"O\" (O, c) = máxm i=1(Oi, c)}, \"J\" [1, n], \"J\" (O, c-j) = máxm i=1j(Oi Prueba. Supongamos que ci > ci y Oi(c) = 1. Sin pérdida de generalidad, suponemos que Ok i (c) = 1 para algunos k, 1 ≤ k ≤ m. De la suposición de que Ok i (c) satisface MP, obtenemos que 216 Ok i (ci ci) = 1. Así, Oi(ci ci) = Wm j=1 Oj (c) = 1. Esto demuestra que O(c) satisface a MP. La corrección de la función de valor de corte sigue directamente del Teorema 4. Muchos algoritmos de hecho caen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multicast. La estructura más utilizada en el enrutamiento multicast se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, c), donde V es el conjunto de nodos, y el vector c es el costo real de los nodos reenviando los datos. Supongamos que el nodo de origen es s y los receptores son Q â € V. Para cada receptor qi Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP(s, qi, d), de la fuente s a qi bajo el perfil de costo reportado d. La unión de todos estos caminos más cortos forma el árbol de ruta más corto. A continuación, utilizamos General Framework 1 para diseñar el sistema de pago veraz P cuando se utiliza la estructura SPT como salida para multicast, es decir, diseñamos un mecanismo M = (SPT, P). Tenga en cuenta que los mecanismos VCG no se pueden aplicar aquí, ya que el SPT no es una maximización afín. Definimos LCP(s,qi) como la asignación corresponde a la ruta LCP(s, qi, d), es decir, LCP (s,qi) k (d) = 1 si y solo si el nodo vk está en LCP(s, qi, d). A continuación, la salida SPT se define como W qiÃ3Q LCP(s,qi). En otras palabras, SPTk(d) = 1 si y sólo si qk se selecciona en algunos LCP(s, qi, d). La regla de asignación de ruta más corta es una utilitaria y satisface a MP. Así, a partir del Teorema 6, SPT también satisface MP, y el vector de función de valor de corte para SPT se puede calcular como فارسى(SPT, c) = maxqi-Q فارسى(LCP(s,qi), c), donde فارسى(LCP(s,qi), c) es el vector de función de valor de corte para la ruta más corta LCP(s, qi, c En consecuencia, el sistema de pago anterior es veraz y el mínimo entre todos los sistemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Corregido el ajuste S de un \"juego de demanda\" binario, asumir que hay m métodos de salida O1, O2, · · ·, Om satisfacer MP, y ( Oi, c) son las funciones de valor de corte respectivamente para Oi donde i = 1, 2, · ·, m. A continuación, la regla de asignación O(c) = Vm i=1 Oi (c) Por otra parte, la función de valor de corte para O es فارسى(O, c) = mimm i=1(Oi, c)}. Demostramos que nuestra simple combinación generaliza la función IF-THENELSE definida en [13]. Para un agente i, asumir que hay dos reglas de asignación O1 y O2 que satisfacen MP. Dejemos que las funciones de valor de corte para O1, O2, C−i, sean las funciones de valor de corte para O1, O2 respectivamente. Entonces la función Oi(c) de IF-THEN-ELSE es en realidad Oi(c) = [(ci ≤ Mediante la aplicación de los teoremas 6 y 7, sabemos que la regla de asignación O satisface al MP y, por consiguiente, a la letra i), c-i) = máx{min{i(O1, c-i)+ 4.2 Asignaciones Round-Based Algunos algoritmos de aproximación son Round-Based, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costos si es necesario. Por ejemplo, varios algoritmos de aproximación para la cobertura de vértice de peso mínimo [19], conjunto independiente de peso máximo, cubierta de peso mínimo [4] y árbol Steiner [18] de peso mínimo entran en esta categoría. Como ejemplo, discutimos el problema de la cubierta vértice ponderada mínima (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida basada en redondo. Dado un gráfico G = (V, E), donde los nodos v1, v2,. . . , vn son los agentes y cada agente vi tiene un peso ci, queremos encontrar un conjunto de nodos V  V tal que para cada borde (u, v) E al menos uno de u y v está en V. Tal V se llama una cubierta vértice de G. La valoración de un nodo i es −ci si se selecciona; de lo contrario su valoración es 0. Para un subconjunto de nodos V-V, definimos su peso como c(V) = P i-V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetiva que se ha de llevar a cabo es utilitaria. Para utilizar el mecanismo VCG, necesitamos encontrar la cubierta vértice con el peso mínimo, que es NP-duro [16]. Puesto que estamos interesados en mecanismos que se pueden calcular en tiempo polinomio, debemos utilizar reglas de asignación computables de tiempo polinomio. Muchos algoritmos han sido propuestos en la literatura para aproximar la solución óptima. En este artículo, utilizamos un algoritmo de 2-aproximación dado en [16]. En aras de la integridad, repasamos brevemente este algoritmo aquí. El algoritmo es de base redonda. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo i, w(i) se inicializa a su peso ci, y cuando w(i) cae a 0, i se incluye en la cubierta de vértice. Para aclarar la presentación, decimos que un borde (i1, j1) es lexicográficamente menor que el borde (i2, j2) si (1) min(i1, j1) < min(i2, j2), o (2) min(i1, j1) = min(i2, j2) y max(i1, j1) < max(i2, j2). Algoritmo 2 Entrada mínima aproximada de cubierta del vértice ponderado: Un gráfico ponderado del nodo G = (V, E, c). Salida: Una cubierta de vértice V. 1: Conjunto V = فارسى. Para cada i-V, set w(i) = ci. 2: mientras que V no es una cubierta de vértice hacer 3: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 4: Dejar m = min(w(i), w(j)). 5: Actualizar w(i) a w(i) − m y w(j) a w(j) − m. 6: Si w(i) = 0, añadir i a V. Si w(j) = 0, añádase j a V. Note, seleccionar un borde usando el orden lexicográfico es mutial para garantizar la propiedad de la monotonicidad. Algoritmo 2 produce una cubierta de vértice V cuyo peso está a menos de 2 veces de lo óptimo. Para mayor comodidad, utilizamos VC(c) para denotar la cubierta vértice calculada por Algoritmo 2 cuando el vector de costo de los vértices es c. Debajo generalizamos Algoritmo 2 a un escenario más general. Por lo general, una salida de base redonda se puede caracterizar como sigue (algoritmo 3). DEFINICIÓN 2. Una regla de actualización Ur se dice que cruza independientemente si, para cualquier agente i no seleccionado en la ronda r, (1) Sr+1 y cr+1 −i no dependen de cr j (2) para cr −i, cr i1 ≤ cr i2 implica que cr+1 i1 ≤ cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz usando una regla de asignación basada en ronda A. THEOREM 8. Una salida basada en redondo A, con el marco definido en Algoritmo 3, satisface MP si los métodos de salida O satisfacen MP y todas las reglas de actualización Ur son independientes del cruce. Prueba. Considere un agente i y c-i fijo. Demostramos que cuando se selecciona un agente i con costo ci, entonces también se selecciona con costo di < ci. Asumir que i se selecciona en redondo r con costo ci. Entonces bajo costo di, si el agente i es seleccionado en una ronda antes de r, nuestra reclamación se mantiene. De lo contrario, considere en redondo r. Claramente, el ajuste Sr y los costos de todos los demás agentes son los mismos que si el agente que tenía costo ci ya que no se selecciona en las rondas anteriores debido a la propiedad crossindependent. Dado que i se selecciona en redondo r con costo ci, i también se selecciona en redondo r con di < ci debido a la razón de que O satisface MP. Esto termina la prueba. 217 Algoritmo 3 A A Asignación General de Base Redonda Regla A 1: Establecer r = 0, c0 = c, y G0 = G inicialmente. 2: repetir 3: Calcular una salida o utilizando un algoritmo determinista O : Sr × cr → {0, 1}n. Aquí o, cr y Sr son la regla de asignación, vector de costo y configuración de juego en el juego Gr, respectivamente. Observación: O es a menudo un algoritmo codicioso simple como la selección de los agentes que minimizan alguna función utilitaria. Para el ejemplo de cubierta de vértice, O siempre seleccionará el nodo de peso ligero en el borde lexicográficamente menos descubierto (i, j). 4: Let r = r + 1. Actualizar el juego Gr−1 para obtener un nuevo juego Gr con la configuración Sr y costo vector cr de acuerdo con alguna regla Ur : Or−1 × (Sr−1, cr−1 ) → (Sr, cr ). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de cubierta vértice, la regla de actualización disminuirá el peso de los vértices i y j por min(w(i), w(j)). 5: hasta que se encuentre una salida válida 6: Devuelve la unión del conjunto de jugadores seleccionados de cada ronda como la salida final. Para el ejemplo de cubierta de vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte calculado para la entrada de algoritmos de base redonda: Una salida de base redonda A, un juego G1 = G, y un vector de función U de actualización. Salida: El valor de corte x para el agente k. 1: Establecer r = 0 y ck =. Recordemos que el valor de • es un valor que puede garantizar Ak = 0 cuando un agente reporta el costo de •. 2: repetir 3: Calcular una salida o utilizar un algoritmo determinista basado en la fijación de Sr utilizando la regla de asignación O : Sr ×cr → {0, 1}n. 4: Encuentre el valor de corte para el agente k basado en la regla de asignación O para los costes cr −k. Let r = Łk(O, cr −k) ser el valor de corte. 5: Establecer r = r + 1 y obtener un nuevo juego Gr de Gr−1 y o de acuerdo con la regla de actualización Ur. 6: Let cr ser el nuevo vector de costo para el juego Gr. 7: hasta que se encuentre una salida válida. 8: Que gi(x) sea el costo de ci k cuando el vector de costo original es ck x. 9: Encontrar el valor mínimo x tal que 8  : g1(x) ≥ 1; g2(x) ≥ 2;... gt−1(x) ≥ t−1; gt(x) ≥ t. Aquí, t es el número total de rondas. 10: Salida el valor x como el valor de corte. Si la salida basada en redondo satisface la propiedad de monotonicidad, el valor de corte siempre existe. A continuación, mostramos cómo encontrar el valor de corte para un agente seleccionado k en Algorithm 4. La corrección del Algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte r para cada ronda r se puede calcular en tiempo polinomio; (2) podemos resolver la ecuación gr(x) = r para encontrar x en tiempo polinomio cuando se dan el vector de costo c-i y b. Ahora consideramos el problema de la cubierta vértice. Para cada ronda r, seleccionamos un vértice con el menor peso y que es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el agente i, actualizamos su costo a cr i − cr j iff edge (i, j) se selecciona. Es fácil verificar que esta regla de actualización es independiente del cruce, por lo que podemos aplicar Algoritmo 4 para calcular el valor de corte para el juego de cubierta de conjunto como se muestra en Algoritmo 5. Algoritmo 5 Calcula valor de corte para MVC. Entrada: Un gráfico ponderado de nodo G = (V, E, c) y un nodo k seleccionado por Algorithm 2. Salida: El valor de corte Łk(V C, c−k). 1: Para cada i â € V, set w(i) = ci. 2: Set w(k) = ­, pk = 0 y V =. 3: mientras que V no es una cubierta de vértice hacer 4: Elija un borde descubierto (i, j) con el orden lexicográfico menos entre todos los bordes descubiertos. 5: Set m = min(w(i), w(j)). 6: Actualizar w(i) = w(i) − m y w(j) = w(j) − m. 7: Si w(i) = 0, añadir i a V; de lo contrario añadir j a V. 8: Si i == k o j == k entonces set pk = pk + m. 9: Salida pk como el valor de corte Łk (V C, c−k). 4.3 Combinaciones complejas En la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del \"juego de demanda\" binario es una simple combinación de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación presentamos una forma más compleja de combinar las reglas de asignación, y como cabe esperar, la forma de encontrar el valor de corte también es más complicada. Supongamos que hay n agentes 1 ≤ i ≤ n con el vector de coste c, y hay m binary demand juegos Gi con funciones objetivas fi(o, c), ajuste Si y regla de asignación?i donde i = 1, 2, · · ·, m. Hay otro \"juego de demanda\" binario con ajuste S y regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · Let f be the function vector (f1, f2, · · ·, fm), • be the astribution rule vector (­1, •2, · ·, •m ) and ∫ be the setting vector (­1, S2, · ·, Sm). Para la simplicidad de la notación, definimos Fi(c) = fi(­i (c), c), para cada 1 ≤ i ≤ m, y F(c) = (F1(c), F2(c), · · ·, Fm(c)). Veamos un ejemplo concreto de estas combinaciones. Considere un grafo ponderado de enlace G = (V, E, c), y un subconjunto de q nodos Q  V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una manera de encontrar una aproximación del árbol Steiner es la siguiente: (1) construimos un gráfico completo virtual H usando Q como sus vértices, y el costo de cada borde (i, j) es el costo de LCP(i, j, c) en el gráfico G; (2) construimos el árbol de extensión mínimo de H, denotado como MST(H); (3) se selecciona un borde de G si se selecciona en algunos LCP(i, j En este juego, definimos q(q − 1)/2 juegos Gi,j, donde i, j+ Q, con funciones objetivas fi,j(o, c) siendo el costo mínimo de 218 conectando i y j en el gráfico G, configurando Si siendo la gráfica G original y la regla de asignación es LCP(i, j, c). El juego G corresponde al juego MST en el gráfico H. El costo del par q(q − 1)/2 rutas más cortas define el vector de entrada d = (d1, d2, · · ·, dm) para el juego MST. En la sección 5.2 figurarán más detalles. DEFINICIÓN 3. Dada una regla de asignación O y la configuración S, un vector de función objetivo f, un vector de regla de asignación La regla de asignación de la definición anterior puede interpretarse de la siguiente manera. Un agente i se selecciona si y sólo si hay un j tal que (1) i se selecciona en j (c), y (2) la regla de asignación O seleccionará index j bajo el perfil de costes F(c). Para la simplicidad, utilizaremos O-F para denotar la salida de este \"juego de demanda\" binario compuesto. Tenga en cuenta que existe un sistema de pago veraz usando O-F como salida si y sólo si satisface la propiedad de monotonicidad. Para estudiar cuando O â € TM F satisface MP, varias definiciones necesarias están en orden. DEFINICIÓN 4. Función Monotonicidad Propiedad (FMP) Dada una función objetiva g y una regla de asignación O, una función H(c) = g(O(c), c) se dice que satisface la función propiedad de monotonicidad, si, dada c-i fija, satisface: 1. Cuando Oi(c) = 0, H(c) no aumenta sobre ci. 2. Cuando Oi(c) = 1, H(c) no disminuye sobre ci. DEFINICIÓN 5. Propiedad de la monotonicidad fuerte (SMP) Se dice que una regla de asignación O satisface la propiedad de la monotonicidad fuerte si O satisface MP, y para cualquier agente i con Oi(c) = 1 y agente j = i, Oi(cj cj) = 1 si cj ≥ cj o Oj(cj cj) = 0. LEMMA 1. Para una regla de asignación dada O satisfacer SMP y vectores de costes c, c con ci = ci, si Oi(c) = 1 y Oi(c) = 0, entonces debe existir j = i tal que cj < cj y Oj(c) = 1. A partir de la definición de la propiedad de la monotonicidad fuerte, tenemos Lemma 1 directamente. Ahora podemos dar una condición suficiente cuando O â € ¢ F satisface la propiedad de la monotonicidad. Teorema 9. Si el valor de Fi cumple con el valor de FMP, el valor de la salida de O cumple con el valor de SMP, el valor de O cumple con el valor de F. Prueba. Suponiendo que para costo vector c tenemos (O F)i(c) = 1, debemos probar para cualquier costo vector c = ci ci con ci < ci, (O F)i(c) = 1. Notando que (O • F)i(c) = 1, sin pérdida de generalidad, suponemos que Ok(F(c)) = 1 y •k i (c) = 1 para algún índice 1 ≤ k ≤ m. Ahora considere la salida O con el vector de costo F(c)k Fk(c). Hay dos escenarios, que serán estudiados uno por uno de la siguiente manera. Un escenario es que el índice k no es elegido por la función de salida O. A partir de Lemma 1, debe existir j = k de tal manera que Fj(c) < Fj(c) (1) Oj(F(c)k Fk(c)) = 1 (2) Entonces demostramos que el agente i será seleccionado en la salida ­j (c), es decir, ­j i (c) = 1. Si no lo es, ya que ­j (c) satisface MP, tenemos ­j i (c) = ­j i (c) = 0 de ci < ci. Dado que Fj satisface FMP, sabemos Fj(c) ≥ Fj(c), que es una contradicción con la desigualdad (1). Consecuentemente, tenemos j i (c ) = 1. A partir de la Ecuación (2), el hecho de que el índice k no es seleccionado por la regla de asignación O y la definición de SMP, tenemos Oj(F(c)) = 1, Por lo tanto, el agente i es seleccionado por O â F debido a Oj(F(c)) = 1 y â j i (c) = 1. El otro escenario es que el índice k es elegido por la función de salida O. En primer lugar, el agente i se elige en k (c) ya que la salida k (c) satisface la propiedad de monotonicidad y ci < ci y k i (c) = 1. En segundo lugar, ya que la función Fk satisface FMP, sabemos que Fk(c) ≤ Fk(c). Recuerde que la salida O satisface el SMP, así podemos obtener Ok(F(c)) = 1 del hecho de que Ok(F(c)k Fk(c)) = 1 y Fk(c) ≤ Fk(c). Consecuentemente, el agente i también será seleccionado en la salida final O.» F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta O • F. A continuación, se discute cómo encontrar el valor de corte para esta salida. A continuación, le daremos un algoritmo para calcular el valor de O F cuando el valor de O satisface el valor de SMP, el valor de O satisface el valor de MP, y el valor de 3 para el valor de c-i fijo, el valor de Fj(c) es una constante, digamos hj, cuando el valor de C (c) = 0, y el valor de Fj(c) aumenta cuando el valor de C (c) = Tenga en cuenta que aquí hj se puede calcular fácilmente mediante la configuración de ci = فارسى ya que Łj satisface la propiedad de monotonicidad. Cuando se le da i y c-i fijo, definimos (Fi j )-1 (y) como la x más pequeña tal que Fj(ci x) = y. Para simplificar, denotamos (Fi j )-1 como F−1 j si no se produce confusión cuando i es un agente fijo. En este artículo, asumimos que dado cualquier y, podemos encontrar tal x en tiempo polinomio. Algoritmo 6 Encontrar valor de corte para el método compuesto O • F Entrada: regla de asignación O, vector de función objetivo F y vector de función inversa F−1 = {F−1 1, · ·, F−1 m }, vector de regla de asignación • y c−i fijo. Salida: Valor de corte para el agente i basado en O â € F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas â € j (ci). 3: Compute hj = Fj(ci Ł). 4: Use h = (h1, h2, · · ·, hm) como entrada para la función de salida O. Denote 7: El valor de corte para i es ­i(O • F, c−i) = máxm j=1 •i, j. Teorema 10. Algoritmo 6 calcula el valor de corte correcto para el agente i basado en la regla de asignación O • F. PROOF. Con el fin de demostrar la corrección de la función de valor de corte calculado por Algoritmo 6, demostramos los dos casos siguientes. Para nuestra comodidad, usaremos i para representar a i(O  F, c−i) si no hay confusión causada. En primer lugar, si di < Łi entonces (O  F)i(ci di) = 1. Sin la pérdida de la generalidad, suponemos que i = i,j para algunos j. Puesto que la función Fj satisface FMP y j i (ci di) = 1, tenemos Fj(ci di) < Fj(Łi). Note di < i,j, de la definición de i,j = F−1 j (minj, hj}) tenemos (1) j i (ci di) = 1, (2) Fj(ci di) < ♥j debido al hecho de que Fj(x) es una función no decreciente cuando j es seleccionada. Por lo tanto, de la propiedad de la monotonicidad de O y Łj es el valor de corte para la salida O, tenemos Oj(hj Fj(ci di)) = 1. (3) Si Oj(ci di)) = 1 entonces (OF)i(ci di) = 1. De lo contrario, dado que O satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que Ok(F(ci di)) = 1 y Fk(ci di) < hk. Nota Fk(ci di) < hk implica que i se selecciona en k (ci di) desde hk = Fk(cii فارسى). En otras palabras, el agente i se selecciona en O.F. 219 En segundo lugar, si di ≥ Łi(O • F, c−i) entonces (O • F)i(ci di) = 0. Asumir, por el bien de la contradicción, que (O F)i(ci di) = 1. Entonces existe un índice 1 ≤ j ≤ m de tal manera que Oj(F(ci di)) = 1 y j i (ci di) = 1. Recuerde que hk ≥ Fk(ci di) para cualquier k. Así, del hecho de que O satisface SMP, al cambiar el vector de costo de F(ci di) a hj Fj(ci di), todavía tenemos Oj(hj Fj(ci di)) = 1. Esto implica que Fj(ci di) < Łj. Combinando la desigualdad anterior y el hecho de que Fj(ci ci di) < hj, tenemos Fj(ci di) < min{hj, Łj}. Esto implica di < F−1 j (min{hj, que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación de la función fj y fj implementa la función objetiva es utilitaria. Por lo tanto, podemos calcular la inversa de F−1 j de manera eficiente. Otra cuestión es que parece que las condiciones cuando podemos aplicar Algoritmo 6 son restrictivas. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para subasta combinatoria de una sola mente, luego la combinación MAX(A1, A2) devuelve la asignación con el mayor bienestar. Si los algoritmos A1 y A2 satisfacen MP y FMP, la operación max(x, y) que devuelve el elemento más grande de x e y satisface SMP. De Teorema 9 obtenemos esa combinación MAX(A1, A2) también satisface MP. Además, el valor de corte de la combinación MAX se puede encontrar en Algorithm 6. Como veremos en la sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados. 5. EJEMPLOS CONCRETOS 5.1 Cubierta de conjunto En el problema de cubierta de conjunto, hay un conjunto U de elementos m necesarios para ser cubiertos, y cada agente 1 ≤ i ≤ n puede cubrir un subconjunto de elementos Si con un costo ci. Let S = {S1, S2, · · ·, Sn} y c = (c1, c2, · ·, cn). Queremos encontrar un subconjunto de agentes D de tal manera que U  S  Si. Los subconjuntos seleccionados se llaman la cubierta de conjunto para U. La eficiencia social de la salida D se define como P ióD ci, que es la función objetiva a minimizar. Claramente, este es un mecanismo utilitario y por lo tanto VCG se puede aplicar si podemos encontrar el subconjunto de S que cubre U con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-hard. En [4], se ha propuesto un algoritmo de relación de aproximación de Hm y se ha demostrado que esta es la mejor relación posible para el problema de la cubierta fija. Para la exhaustividad de la presentación, revisamos su método aquí. Algoritmo 7 Cover Juego de Codicia (GSC) Entrada: Agente es subconjunto Si cubierto y costo ci. (1 ≤ i ≤ n). Salida: Un conjunto de agentes que pueden cubrir todos los elementos. 1: Inicializar r = 1, T0 = 2: mientras que R = U hacer 3: Encontrar el conjunto Sj con la densidad mínima cj Sj −Tr. 4: Set Tr+1 = Tr S Sj y R = R S j. 5: r = r + 1 6: Salida R. Dejar GSC(S) ser los conjuntos seleccionados por el Algoritmo 7.Note que el conjunto de salida es una función de S y c. Algunos trabajos asumen que el tipo de un agente podría ser ci, es decir, Si se supone que es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, ci). En otras palabras, asumimos que cada agente no sólo puede mentir sobre su costo ci, sino que también puede mentir sobre el conjunto Si. Este problema se parece ahora a la subasta combinatoria con un único postor de mente estudiado en [12], pero con las siguientes diferencias: en el problema de la cubierta de conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras que en la subasta combinatoria los conjuntos elegidos son disjuntos. Podemos demostrar que el mecanismo M = (GSC, PV CG ), utilizando Algorithm 7 para encontrar una cubierta de conjunto y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la cubierta de conjunto es un \"juego de demanda\" binario. Por el momento, asumimos que el agente no será capaz de mentir sobre Si. Dejaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz mediante la aplicación de nuestro marco general. 1. Compruebe la propiedad monotonicity: La salida de Algorithm 7 es una salida basada en redondo. Así, para un agente i, primero nos centramos en la salida de una ronda r. En la ronda r, si i es seleccionado por Algoritmo 7, entonces tiene la proporción mínima ci Si−Tr entre todos los agentes restantes. Ahora considere el caso cuando i miente su costo a ci < ci, obviamente ci Si−Tr es todavía mínimo entre todos los agentes restantes. En consecuencia, el agente i sigue siendo seleccionado en la ronda r, lo que significa que la salida de la ronda r satisface MP. Ahora nos fijamos en las reglas de actualización. Para cada ronda, sólo actualizamos el Tr+1 = Tr S Sj y R = R S j, que es obviamente cross-independiente. Por lo tanto, mediante la aplicación de Teorema 8, sabemos que la salida de Algoritmo 7 satisface MP. 2. Encuentre el valor de corte: Para calcular el valor de corte para el agente i con el vector de costo fijo c-i, seguimos los pasos en Algoritmo 4. En primer lugar, establecemos ci = فارسى y aplicamos Algoritmo 7. Dejar que el agente seleccionado en la ronda r y T-i r+1 sea el conjunto correspondiente. Entonces el valor de corte de r es r = cir Sir − T-i r  · Si − T-i r. Recuerde que la regla de actualización sólo actualiza la configuración del juego, pero no el costo del agente, por lo que tenemos gr(x) = x ≥ r para 1 ≤ r ≤ t. Por lo tanto, el valor de corte final para el agente i es Łi(GSC, c−i) = max r { cir Sir − T−i r  · Si − T Ahora consideramos el escenario cuando agente puedo mentir sobre Si. Supongamos que el agente no puede mentir hacia arriba, es decir, sólo puede reportar un conjunto Si  Si. Argumentamos que agente no mentiré sobre sus elementos Si. Observe que el valor de corte calculado para la ronda r es r = cir Sir −T −i r  · Si − T−i r. Obviamente Si − T−i r  ≤ Si − T−i r  para cualquier Si  Si. Por lo tanto, la mentira de su conjunto como Si no aumentará el valor de corte para cada ronda. Así que mentir sobre Si no mejorará agente es utilidad. 5.2 Link Weighted Steiner Trees Considere cualquier red de enlaces ponderados G = (V, E, c), donde E = {e1, e2, · · ·, em} son el conjunto de enlaces y ci es el peso del enlace ei. El problema del árbol link weighted Steiner es encontrar un árbol enraizado en un nodo de origen que abarque un conjunto dado de nodos Q = {q1, q2, · · ·, qk} V. Para simplificar, suponemos que qi = vi, para 1 ≤ i ≤ k. Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H  G se llama el peso de H, denotado como (H). Es NP-difícil encontrar el costo mínimo multicast árbol cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinomio actualmente tiene relación de aproximación 1 + ln 3 2 [17]. Aquí revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encontrar LinkWesighted SteinerTree (LST) Entrada: Red G = (V, E, c) donde c es el vector de costo para el conjunto de enlaces E. Nodo fuente s y receptor set Q. Salida: Un árbol LST enraizado en s y que abarcaba todos los receptores. 1: Establecer r = 1, G1 = G, Q1 = Q y s1 = s. 2: repetir 3: En el gráfico Gr, encontrar el receptor, decir qi, que es más cercano a la fuente s, es decir, LCP(s, qi, c) tiene el menor costo entre las rutas más cortas de s a todos los receptores en Qr. 4: Seleccione todos los enlaces en LCP(s), qi, c) como enlaces de relé y establecer su costo a 0. El nuevo gráfico se denota como Gr+1. 5: Establecer tr como qi y Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi y r = r + 1. 7: hasta que todos los receptores estén extendidos. Después, deje que LST(G) sea el árbol final construido usando el método anterior. Se muestra en [24] que el mecanismo M = (LST, pV CG ) no es veraz, donde pV CG es el pago calculado sobre la base del mecanismo VCG. A continuación, mostramos cómo diseñar un sistema de pago veraz utilizando nuestro marco general. Observe que la salida Pr, para cualquier ronda r, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, a partir de Teorema 8, la salida LST de base redonda satisface MP. En redondo r, el valor de corte para un enlace ei se puede obtener utilizando el mecanismo VCG. Ahora establecemos ci = فارسى y ejecutamos Algoritmo 8. Que w-i r (ci) sea el coste de la ruta Pr(ci) seleccionada en la rth ronda y Πi r(ci) sea la ruta más corta seleccionada en la r ronda si el coste de ci se establece temporalmente en. Entonces el valor de corte para la ronda r es r = wi r(c-i) − i r(c-i) donde i r(c-i) es el costo de la ruta Πi r(c-i) excluyendo el nodo vi. Utilizando Algoritmo 4, obtenemos el valor de corte final para el agente i: (LST, c-i) = maxr{ r}. Por lo tanto, el pago a un link ei es?i(LST, c-i) si su coste reportado es di <?i(LST, d-i); de lo contrario, su pago es 0. 5.3 Árboles minimales virtuales Para conectar el conjunto dado de receptores al nodo de origen, además del árbol Steiner construido por los algoritmos descritos anteriormente, también se utiliza a menudo un árbol mínimo virtual. Supongamos que Q es el conjunto de receptores, incluido el remitente. Supongamos que los nodos en un gráfico ponderado por nodo son todos agentes. El árbol de extensión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: para todos los pares de receptores qi, qj â € TM Q do 2: Calcular la ruta de menor costo LCP(qi, qj, d). 3: Construya un grafo K(d) completo de enlace virtual usando Q como su conjunto de nodos, donde el qiqj enlace corresponde a la ruta de menor costo LCP(qi, qj, d), y su peso es w(qiqj) = LCP(qi, qj, d). 4: Construir el árbol de extensión mínimo en K(d), denotado como V MST(d). 5: para cada enlace virtual qiqj en V MST(d) do 6: Encuentre la ruta de menor costo LCP(qi, qj, d) correspondiente en la red original. 7: Marque los agentes en LCP(qi, qj, d) seleccionados. El mecanismo M = (V MST, pV CG ) no es veraz [24], donde el pago pV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos. 1. Compruebe la propiedad de la monotonicidad: Recuerde que en el gráfico completo K(d), el peso de un enlace qiqj es LCP(qi, qj, d). En otras palabras, definimos implícitamente Q(Q − 1)/2 funciones fi,j, para todos los i < j y qi Q y qj Q, con fi,j(d) = LCP(qi, qj, d). Podemos mostrar que la función fi,j(d) = LCP(qi, qj, d) satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad. 2. Encuentre el valor de corte: Aviso VMST es la combinación de MST y función fi,j, por lo que el valor de corte para VMST se puede calcular basado en Algoritmo 6 de la siguiente manera. (a) Dado un enlace ponderado gráfico completo K(d) en Q, debemos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol extenso T y un par de terminales p y q, claramente hay un camino único que los conecta en T. Denotamos este camino como ΠT (p, q), y el borde con la longitud máxima en este camino como LE(p, q, T). Por lo tanto, el valor de corte puede ser representado como Łk(MST, d) = LE(qi, qj, MST(dk فارسى)) (b) Encontramos la función valor-costo para LCP. Asumir vk LCP(qi, qj, d), entonces la función valor-costo es xk = yk − LCPvk (qi, qj, dk 0). Aquí, LCPvk (qi, qj, d) es la ruta de menor costo entre qi y qj con nodo vk en esta ruta. c) Eliminar vk y calcular el valor K(dk فارسى). Establecer h(i,j) = LCP(qi, qj, d )) para cada par de nodo i = j y dejar que h = {h(i,j)} sea el vector. Entonces es fácil demostrar que Ł(i,j) = LE(qi, qj, MST(h(i,j)) es el valor de corte para el VMST de salida. Es fácil verificar que min{h(i,j), فارسى(i,j)} = LE(qi, qj, MST(h). Por lo tanto, sabemos que el k (V MST, d) es LE(qi, qj, MST(h) LCPvk (qi, qj, dk 0). El valor de corte para el agente k es el siguiente: (V MST, d−k) = max0≤i,j≤r Łij k (V MST, d−k). 3. Pagamos a un agente k (V MST, d-k) si y sólo si k está seleccionado en V MST (d); de lo contrario lo pagamos 0. 5.4 Subastas combinatorias Lehmann y otros [12] estudió cómo diseñar un mecanismo de verdad eficiente para la subasta combinatoria de mente única. En una subasta combinatoria individual, hay un conjunto de artículos S a vender y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente i quiere comprar un subconjunto Si  S con precio máximo mi. Un único postor i declara una oferta bi = Si, ai con Si  S y ai R+. Dos ofertas Si, ai y Sj, aj conflicto si Si â € Sj =. Dadas las ofertas b1, b2, · · ·, bn, dieron un algoritmo round-based codicioso como sigue. En primer lugar las ofertas se ordenan por algún criterio ( ai Si1/2 se utiliza en[12]) en un orden creciente y dejar L ser la lista de ofertas ordenadas. Se concede la primera oferta. A continuación, el algoritmo examina cada oferta de L en orden y concede la oferta si no entra en conflicto con cualquiera de las ofertas previamente concedidas. Si lo hace, se niega. Demostraron que este sistema de asignación codicioso utilizando criterio ai Si1/2 se aproxima a la asignación óptima dentro de un factor de m, donde m es el número de mercancías en S. En los escenarios de subasta, tenemos ci = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida de base redonda. Recuerde que después de que el postor j es seleccionado para la ronda r, cada postor tiene conflicto 221 con j no será seleccionado en las rondas después. Esto equivale a actualizar el costo de cada ofertante que tiene conflicto con j a 0, lo que satisface la independencia de cruce. Además, en cualquier ronda, si el postor i es seleccionado con ai entonces todavía será seleccionado cuando declara ai > ai. Así, para cada ronda, satisface MP y el valor de corte es Si1/2 · ajr Sjr 1/2 donde jr es el postor seleccionado en la ronda r si no consideramos el agente i en absoluto. Aviso ajr Sjr 1/2 no aumenta cuando aumenta la ronda r, por lo que el valor de corte final es Si1/2 · aj Sj 1/2 donde bj es la primera oferta que se ha negado pero habría sido seleccionado si no sólo para la presencia de postor i. Así, el pago por agente i es Si1/2 · aj Sj 1/2 si ai ≥ Si1/2 · aj Sj 1/2, y 0 de otra manera. Este régimen de pagos es exactamente el mismo que el régimen de pagos de [12]. 6. CONCLUSIONES En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un \"juego de demanda\" binario. Primero demostramos que la regla de asignación O que satisface al parlamentario es una condición necesaria y suficiente para que exista un mecanismo veraz M. A continuación, formulamos un marco general para diseñar el pago P tal que el mecanismo M = (O, P) es veraz y computable en tiempo polinomio. Presentamos además varias técnicas generales basadas en la composición para calcular P eficientemente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para técnicas basadas en la composición de computación P en tiempo polinomio. En este artículo, nos hemos concentrado en cómo calcular P en tiempo polinomio. Nuestros algoritmos no tienen necesariamente el tiempo de ejecución óptimo para la computación P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos hecho algunos progresos en esta dirección de investigación en [22] proporcionando un algoritmo para calcular los pagos para unicast en un gráfico ponderado nodo en el tiempo óptimo O (n log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación O satisfacer MP con una buena relación de aproximación para un determinado \"juego de demanda\" binario. Muchas obras [12, 13] en la literatura de diseño de mecanismos están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar normas de asignación con buenas relaciones de aproximación de tal manera que un determinado \"juego de demanda\" binario tenga un sistema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño de mecanismos para juegos de demanda binaria. Sin embargo, algunos problemas no pueden ser formulados directamente como juegos de demanda binaria. El problema de la programación del trabajo en [2] es un ejemplo. Para este problema, existe un sistema de pago veraz P para una regla de asignación O si y sólo si la carga de trabajo asignada por O es monotónica de cierta manera. Es de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un \"juego de demanda\" binario a juegos de demanda no binarias. Hacia esta dirección de investigación, el teorema 4 se puede extender a una regla general de asignación O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo supuestos leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Queremos agradecer a Rakesh Vohra, Tuomas Sandholm y a los críticos anónimos por sus útiles comentarios y discusiones. 7. REFERENCIAS [1] A. ARCHER, C. PAPADIMITRIOU, K. T., Y TARDOS, E. Un mecanismo veraz aproximado para subastas combinatorias con agentes de un solo parámetro. En ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., Y TARDOS, E. Mecanismos veraces para agentes de un parámetro. En Actas de la 42a edición del IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., Y PERSIANO, P. Planes de aproximación veraz determinantes para la programación de máquinas relacionadas. [4] CHVATAL, V. Una heurística codiciosa para el problema de la cubierta del set. Matemáticas de la investigación de operaciones 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart precios de bienes públicos. Public Choice (1971), 17-33. [6] R. Muller, y R. V. Vohra. Sobre los mecanismos de la estrategia dominante. Documento de trabajo, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Mecanismos de participación en la financiación de los gastos a prueba de estrategias para los juegos de cubierta fija y de ubicación de instalaciones. En ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Aproximación y colusión en la repartición de costos multicast (abstracto). En la Conferencia Económica de la ACM (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., Y SHENKER, S. Un mecanismo basado en BGP para enrutamiento de bajo costo. En las actas del Simposio de 2002 de la ACM sobre principios de la computación distribuida. (2002), pp. 173-182. [10] VERDE, J., Y LAFFONT, J.J. Caracterización de mecanismos satisfactorios para la revelación de preferencias por bienes públicos. Econometrica (1977), 427-438. [11] GROVES, T. Incentivos en equipos. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., Y SHOHAM, Y. Revelación de la verdad en subastas combinatoria aproximadamente eficientes. Diario de ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful aproximation mechanism for restrict combinatorial subastas: extended abstract. En 18a Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana para la Inteligencia Artificial, pp. 379-384. [14] NISAN, N., Y RONEN, A. Diseño de mecanismos algorítmicos. En Proc. 31o Anual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Mejores algoritmos de aproximación para el problema de cubierta vértice en gráficos e hipergrafías. En Actas del 11o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, págs. 329 a 337, 2000. [16] R. Bar-Yehuda y S. Even. Un teorema de proporción local para aproximar el problema de la cubierta vértice ponderada. Anales de Matemáticas Discretas, Volumen 25: Análisis y Diseño de Algoritmos para Problemas Combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] ROBINS, G., Y ZELIKOVSKY, A. Mejora de la aproximación del árbol de steiner en gráficos. En Actas de la XI edición anual de ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. Un algoritmo de aproximación 11/6 para el problema Steiner de la red. Algoritmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cubierta de vértice, y problemas de empaquetado del conjunto, Matemáticas Aplicadas Discreta, 6:243-254, 1983. [20] TAKAHASHI, H., y MATSUYAMA, A. Una solución aproximada para el problema de steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577. [21] VICKREY, W. Contraespeculación, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37. [22] WANG, W., Y LI, X.-Y. Verdadero unicast de bajo costo en redes inalámbricas egoístas. En la 4a. Transacciones de IEEE en Computación Móvil (2005), a aparecer. [23] WANG, W., LI, X.-Y., Y Sun, Z. Diseño de protocolos multicast para redes no cooperativas. IEEE INFOCOM 2005, a aparecer. [24] WANG, W., LI, X.-Y., Y WANG, Y. Truthful multicast en redes inalámbricas egoístas. ACM MobiCom, 2005. 222 ",
            "error": [
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "i(O, c-i) − ci > 0, lo que implica que el sistema de pago satisface el IR. En lo siguiente demostramos que este sistema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: ci < Ł(O, c-i). En este caso, cuando yo declara su verdadero costo ci, su utilidad es Łi(O, c−i) − ci > 0. Ahora considere la situación cuando i declara un costo di = ci. Si di < Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía está seleccionado. Si di > Łi(O, c-i), entonces su utilidad se convierte en 0 ya que ya no está seleccionado. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: ci ≥ (O, c-i). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando i declara una valoración di = ci. Si di > Łi(O, c-i), entonces yo recibe el mismo pago y utilidad ya que todavía no está seleccionado. Si di ≤ Łi(O, c-i), entonces su utilidad se convierte en Łi(O, c-i) − ci ≤ 0 ya que está seleccionado ahora. Por lo tanto, no tiene ningún incentivo para mentir. La equivalencia de la propiedad de la monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz usando O se puede extender a juegos más allá de los juegos de demanda binarias. Los detalles se omiten aquí debido al límite de espacio. Ahora se resume el proceso para diseñar un esquema de pago veraz para un ",
                " binario basado en un método de salida O. General Framework 1 Truthful mechanism design for a binarian ",
                " Etapa 1: Compruebe si la regla de asignación O satisface a MP. Si no lo hace, entonces no existe un sistema de pago P tal que el mecanismo M = (O, P) sea veraz. De lo contrario, definir el sistema de pago P de la siguiente manera. Etapa 2: Sobre la base de la regla de asignación O, encontrar el valor de corte de Oi(O, c-i) para el agente i tal que Oi(ci di) = 1 cuando di < Oi(O, c-i), y Oi(ci di) = 0 cuando di > Oi(O, c-i). Etapa 3: El pago por agente i es 0 si Oi(c) = 0; el pago es Łi(O, c-i) si Oi(c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los sistemas de pago veraz utilizando O como salida. 4. COMPUTANDO FUNCIONES DE VALOR DE CORTE Para encontrar el sistema de pago veraz utilizando el Marco General 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor de corte bajo ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación encontrar la función de valor de corte para cada una de estas nuevas reglas de asignación. Entonces, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación. 4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función de valor de corte combinando múltiples reglas de asignación con conjunciones o disconjunciones. Para la simplicidad, dada una regla de asignación O, usaremos el término ",
                ", c) para denotar un vector de n-tuple (-O, c-1), ",
                "juego de demanda",
                "O",
                "O",
                "J",
                "J",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda",
                "juego de demanda"
            ]
        }
    }
}