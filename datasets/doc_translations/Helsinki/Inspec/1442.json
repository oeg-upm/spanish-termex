{
    "original_text": "Using constructed types in C++ unions The C++ Standard states that a union type cannot have a member with a nontrivial constructor or destructor. While at first this seems unreasonable, further thought makes it clear why this is the case: The crux of the problem is that unions dont have built-in semantics for denoting when a member is the current member of the union. Therefore, the compiler cant know when its appropriate to call constructors or destructors on the union members. Still, there are good reasons for wanting to use constructed object types in a union. For example, you might want to implement a scripting language with a single variable type that can either be an integer, a string, or a list. A union is the perfect candidate for implementing such a composite type, but the restriction on constructed union members may prevent you from using an existing string or list class (for example, from the STL) to provide the underlying functionality. Luckily, a feature of C++ called placement new can provide a workaround",
    "original_translation": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución",
    "error_count": 3,
    "keys": {
        "C++ Standard": {
            "translated_key": "C++ Standard",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El \"C++ Standard\" establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "union type": {
            "translated_key": "tipo de unión",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un \"tipo de unión\" no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "constructors": {
            "translated_key": "constructores",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a los \"constructores\" o destructores de los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "destructors": {
            "translated_key": "destructores",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar constructores o \"destructores\" a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "union members": {
            "translated_key": [
                "miembros de la unión",
                "miembros del sindicato"
            ],
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a los constructores o destructores en los \"miembros de la unión\". Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los \"miembros del sindicato\" construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                "miembros de la unión",
                "miembros del sindicato"
            ]
        },
        "scripting language": {
            "translated_key": "lenguaje de scripting",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un \"lenguaje de scripting\" con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "placement new": {
            "translated_key": "placement new",
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada \"placement new\" puede proporcionar una solución ",
            "error": [
                ""
            ]
        },
        "C++ language": {
            "translated_key": [],
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": []
        },
        "type theory": {
            "translated_key": [],
            "translated_annotated_text": "Uso de tipos construidos en uniones C++ El estándar C++ establece que un tipo de unión no puede tener un miembro con un constructor o destructor no trivial. Aunque al principio esto parece irrazonable, un pensamiento más profundo deja claro por qué es así: El quid del problema es que los sindicatos no tienen una semántica integrada para denotar cuando un miembro es el miembro actual del sindicato. Por lo tanto, el compilador no sabe cuándo es apropiado llamar a constructores o destructores a los miembros del sindicato. Sin embargo, hay buenas razones para querer utilizar tipos de objetos construidos en una unión. Por ejemplo, es posible que desee implementar un lenguaje de scripting con un único tipo de variable que puede ser un entero, una cadena o una lista. Un sindicato es el candidato perfecto para implementar tal tipo compuesto, pero la restricción sobre los miembros del sindicato construidos puede impedirle usar una clase de cadena o lista existente (por ejemplo, del STL) para proporcionar la funcionalidad subyacente. Por suerte, una característica de C++ llamada colocación nueva puede proporcionar una solución ",
            "error": []
        }
    }
}