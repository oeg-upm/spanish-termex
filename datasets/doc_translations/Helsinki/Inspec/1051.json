{
    "original_text": "Faking it: simulating dependent types in Haskell Dependent types reflect the fact that validity of data is often a relative notion by allowing prior data to affect the types of subsequent data. Not only does this make for a precise type system, but also a highly generic one: both the type and the program for each instance of a family of operations can be computed from the data which codes for that instance. Recent experimental extensions to the Haskell type class mechanism give us strong tools to relativize types to other types. We may simulate some aspects of dependent typing by making counterfeit type-level copies of data, with type constructors simulating data constructors and type classes simulating datatypes. This paper gives examples of the technique and discusses its potential",
    "original_translation": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial",
    "error_count": 6,
    "keys": {
        "dependent types": {
            "translated_key": "tipos dependientes",
            "translated_annotated_text": "Fingirlo: simular \"tipos dependientes\" en los tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "Haskell": {
            "translated_key": "Haskell",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en los tipos dependientes de \"Haskell\" refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo \"Haskell\" nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "data validity": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "precise type system": {
            "translated_key": "sistema de tipo preciso",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un \"sistema de tipo preciso\", sino también un altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "type class mechanism": {
            "translated_key": "mecanismo de clase de tipo",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales del \"mecanismo de clase de tipo\" de Haskell nos dan fuertes herramientas para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "dependent typing": {
            "translated_key": "mecanografía dependiente",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de \"mecanografía dependiente\" haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "counterfeit type-level copies": {
            "translated_key": "copias falsas a nivel de tipo",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la mecanografía dependiente haciendo \"copias falsas a nivel de tipo\" de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "type constructors": {
            "translated_key": "constructores de tipo",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con \"constructores de tipo\" simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "data constructors": {
            "translated_key": "constructores de datos",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando \"constructores de datos\" y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "datatypes": {
            "translated_key": "tipos de datos",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando \"tipos de datos\". Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "functional programming": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "data structures": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "functional languages": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "type theory": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        }
    }
}