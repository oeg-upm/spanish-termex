{
    "original_text": "High-level language support for user-defined reductions The optimized handling of reductions on parallel supercomputers or clusters of workstations is critical to high performance because reductions are common in scientific codes and a potential source of bottlenecks. Yet in many high-level languages, a mechanism for writing efficient reductions remains surprisingly absent. Further, when such mechanisms do exist, they often do not provide the flexibility a programmer needs to achieve a desirable level of performance. In this paper, we present a new language construct for arbitrary reductions that lets a programmer achieve a level of performance equal to that achievable with the highly flexible, but low-level combination of Fortran and MPI. We have implemented this construct in the ZPL language and evaluate it in the context of the initialization of the NAS MG benchmark. We show a 45 times speedup over the same code written in ZPL without this construct. In addition, performance on a large number of processors surpasses that achieved in the NAS implementation showing that our mechanism provides programmers with the needed flexibility",
    "original_translation": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria",
    "error_count": 5,
    "keys": {
        "parallel supercomputers": {
            "translated_key": "superordenadores paralelos",
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en \"superordenadores paralelos\" o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": [
                ""
            ]
        },
        "clusters of workstations": {
            "translated_key": "clusters de estaciones de trabajo",
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o \"clusters de estaciones de trabajo\" es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": [
                ""
            ]
        },
        "reductions": {
            "translated_key": "reducciones",
            "translated_annotated_text": "Soporte lingüístico de alto nivel para \"reducciones\" definidas por el usuario El manejo optimizado de \"reducciones\" en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las \"reducciones\" son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir \"reducciones\" eficientes sigue sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para \"reducciones\" arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": [
                ""
            ]
        },
        "parallel programming": {
            "translated_key": [],
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": []
        },
        "scientific computing": {
            "translated_key": [],
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": []
        },
        "language construct": {
            "translated_key": "construcción lingüística",
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva \"construcción lingüística\" para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": [
                ""
            ]
        },
        "parallel languages": {
            "translated_key": [],
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": []
        },
        "program compilers": {
            "translated_key": [],
            "translated_annotated_text": "Soporte lingüístico de alto nivel para reducciones definidas por el usuario El manejo optimizado de reducciones en superordenadores paralelos o grupos de estaciones de trabajo es fundamental para un alto rendimiento porque las reducciones son comunes en los códigos científicos y una posible fuente de cuellos de botella. Sin embargo, en muchos idiomas de alto nivel, un mecanismo para escribir reducciones eficientes sigue estando sorprendentemente ausente. Además, cuando existen esos mecanismos, a menudo no proporcionan la flexibilidad que un programador necesita para lograr un nivel deseable de rendimiento. En este artículo, presentamos una nueva construcción de lenguaje para reducciones arbitrarias que permite a un programador alcanzar un nivel de rendimiento igual al alcanzable con la combinación altamente flexible, pero de bajo nivel, de Fortran y MPI. Hemos implementado este constructo en el lenguaje ZPL y lo evaluamos en el contexto de la inicialización del punto de referencia NAS MG. Mostramos una velocidad de 45 veces sobre el mismo código escrito en ZPL sin esta construcción. Además, el rendimiento en un gran número de procesadores supera el alcanzado en la implementación del NAS, lo que demuestra que nuestro mecanismo proporciona a los programadores la flexibilidad necesaria ",
            "error": []
        }
    }
}