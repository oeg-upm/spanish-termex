{
    "original_text": "Run-time data-flow analysis Parallelizing compilers have made great progress in recent years. However, there still remains a gap between the current ability of parallelizing compilers and their final goals. In order to achieve the maximum parallelism, run-time techniques were used in parallelizing compilers during last few years. First, this paper presents a basic run-time privatization method. The definition of run-time dead code is given and its side effect is discussed. To eliminate the imprecision caused by the run-time dead code, backward data-flow information must be used. Proteus Test, which can use backward information in run-time, is then presented to exploit more dynamic parallelism. Also, a variation of Proteus Test, the Advanced Proteus Test, is offered to achieve partial parallelism. Proteus Test was implemented on the parallelizing compiler AFT. In the end of this paper the program fpppp.f of Spec95fp Benchmark is taken as an example, to show the effectiveness of Proteus Test",
    "original_translation": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test",
    "error_count": 5,
    "keys": {
        "run-time data flow analysis": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        },
        "parallelizing compilers": {
            "translated_key": [
                "paralelizar compiladores",
                "compiladores paralelos"
            ],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue habiendo una brecha entre la capacidad actual de \"paralelizar compiladores\" y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en \"compiladores paralelos\". En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                "paralelizar compiladores",
                "compiladores paralelos"
            ]
        },
        "run-time privatization method": {
            "translated_key": "método de privatización en tiempo de ejecución",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este artículo presenta un \"método de privatización en tiempo de ejecución\" básico. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                ""
            ]
        },
        "run-time dead code": {
            "translated_key": [
                "código muerto de tiempo de ejecución",
                "código muerto en tiempo de ejecución"
            ],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de \"código muerto de tiempo de ejecución\" y se discute su efecto secundario. Para eliminar la imprecisión causada por el \"código muerto en tiempo de ejecución\", se debe utilizar información de flujo de datos atrasado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                "código muerto de tiempo de ejecución",
                "código muerto en tiempo de ejecución"
            ]
        },
        "backward data-flow information": {
            "translated_key": "información de flujo de datos hacia atrás",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe usar \"información de flujo de datos hacia atrás\". Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                ""
            ]
        },
        "Proteus Test": {
            "translated_key": "Proteus Test",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. \"Proteus Test\", que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de \"Proteus Test\", el \"Proteus Test\" avanzado, para lograr un paralelismo parcial. \"Proteus Test\" fue implementado en el compilador paralelizado AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de \"Proteus Test\" ",
            "error": [
                ""
            ]
        },
        "dynamic parallelism": {
            "translated_key": "paralelismo dinámico",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar más \"paralelismo dinámico\". Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                ""
            ]
        },
        "data flow analysis": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        },
        "parallelising compilers": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de Proteus Test, la Advanced Proteus Test, para lograr un paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. Al final de este artículo el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        }
    }
}