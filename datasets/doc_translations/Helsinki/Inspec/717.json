{
    "original_text": "A network simplex algorithm with O(n) consecutive degenerate pivots We suggest a pivot rule for the primal simplex algorithm for the minimum cost flow problem, known as the network simplex algorithm. Due to degeneracy, cycling may occur in the network simplex algorithm. The cycling can be prevented by maintaining strongly feasible bases proposed by Cunningham (1976); however, if we do not impose any restrictions on the entering variables, the algorithm can still perform an exponentially long sequence of degenerate pivots. This phenomenon is known as stalling. Researchers have suggested several pivot rules with the following bounds on the number of consecutive degenerate pivots: m, n/sup 2/, k(k + 1)/2, where n is the number of nodes in the network, m is the number of arcs in the network, and k is the number of degenerate arcs in the basis. (Observe that k <or= n.) In this paper, we describe an anti-stalling pivot rule that ensures that the network simplex algorithm performs at most k consecutive degenerate pivots. This rule uses a negative cost augmenting cycle to identify a sequence of entering variables",
    "original_translation": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada",
    "error_count": 5,
    "keys": {
        "network simplex algorithm": {
            "translated_key": [
                "algoritmo simplex de red",
                "algoritmo simplex de red",
                "algoritmo simplex de la red",
                "algoritmo simplex red"
            ],
            "translated_annotated_text": "Un \"algoritmo simplex de red\" con O(n) pivotes consecutivos degenerados Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costes mínimos, conocido como el \"algoritmo simplex de red\". Debido a la degeneración, el ciclismo puede ocurrir en el \"algoritmo simplex de la red\". El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el \"algoritmo simplex red\" realiza como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                "algoritmo simplex de red",
                "algoritmo simplex de red",
                "algoritmo simplex de la red",
                "algoritmo simplex red"
            ]
        },
        "degenerate pivots": {
            "translated_key": [
                "degenerar pivotes",
                "pivos degenerados",
                "pivotes degenerados",
                "pivotes degenerados"
            ],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) consecutivos \"degenerar pivotes\" Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo todavía puede realizar una secuencia exponencialmente larga de \"pivos degenerados\". Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de \"pivotes degenerados\" consecutivos: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k consecutivos \"pivotes degenerados\". Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                "degenerar pivotes",
                "pivos degenerados",
                "pivotes degenerados",
                "pivotes degenerados"
            ]
        },
        "minimum cost flow problem": {
            "translated_key": "problema de flujo de coste mínimo",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el \"problema de flujo de coste mínimo\", conocido como algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "degeneracy": {
            "translated_key": "degeneración",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la \"degeneración\", el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "cycling": {
            "translated_key": "ciclismo",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el \"ciclismo\" puede ocurrir en el algoritmo simplex de la red. El \"ciclismo\" se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo todavía puede realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "stalling": {
            "translated_key": "estacionamiento",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como \"estacionamiento\". Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-\"estacionamiento\" que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "anti-stalling pivot rule": {
            "translated_key": "regla de pivote antiestacionario",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una \"regla de pivote antiestacionario\" que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "negative cost augmenting cycle": {
            "translated_key": "ciclo de aumento de costes negativo",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un \"ciclo de aumento de costes negativo\" para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "computational complexity": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        },
        "minimisation": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        },
        "trees (mathematics)": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        }
    }
}