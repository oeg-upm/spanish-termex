{
    "original_text": "Minimizing weighted number of early and tardy jobs with a common due window involving location penalty Studies a single machine scheduling problem to minimize the weighted number of early and tardy jobs with a common due window. There are n non-preemptive and simultaneously available jobs. Each job will incur an early (tardy) penalty if it is early (tardy) with respect to the common due window under a given schedule. The window size is a given parameter but the window location is a decision variable. The objective of the problem is to find a schedule that minimizes the weighted number of early and tardy jobs and the location penalty. We show that the problem is NP-complete in the ordinary sense and develop a dynamic programming based pseudo-polynomial algorithm. We conduct computational experiments, the results of which show that the performance of the dynamic algorithm is very good in terms of memory requirement and CPU time. We also provide polynomial time algorithms for two special cases",
    "original_translation": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales",
    "error_count": 5,
    "keys": {
        "early jobs": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "tardy jobs": {
            "translated_key": "tardeados",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y \"tardeados\" y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "common due window": {
            "translated_key": "ventana común debida",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una \"ventana común debida\" que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una \"ventana común debida\". Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la \"ventana común debida\" bajo un horario dado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "single machine scheduling problem": {
            "translated_key": "problema de programación de una sola máquina",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un \"problema de programación de una sola máquina\" para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "decision variable": {
            "translated_key": "variable de decisión",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una \"variable de decisión\". El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "location penalty": {
            "translated_key": "pena de ubicación",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común que implica \"pena de ubicación\" Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la \"pena de ubicación\". Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "NP-complete problem": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "dynamic programming": {
            "translated_key": "programación dinámica",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en la \"programación dinámica\". Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "pseudo-polynomial algorithm": {
            "translated_key": "algoritmo seudo-polinomio",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos una programación dinámica basada en \"algoritmo seudo-polinomio\". Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "computational complexity": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "minimisation": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "production control": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        }
    }
}