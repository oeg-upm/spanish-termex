{
    "original_text": "Minimizing weighted number of early and tardy jobs with a common due window involving location penalty Studies a single machine scheduling problem to minimize the weighted number of early and tardy jobs with a common due window. There are n non-preemptive and simultaneously available jobs. Each job will incur an early (tardy) penalty if it is early (tardy) with respect to the common due window under a given schedule. The window size is a given parameter but the window location is a decision variable. The objective of the problem is to find a schedule that minimizes the weighted number of early and tardy jobs and the location penalty. We show that the problem is NP-complete in the ordinary sense and develop a dynamic programming based pseudo-polynomial algorithm. We conduct computational experiments, the results of which show that the performance of the dynamic algorithm is very good in terms of memory requirement and CPU time. We also provide polynomial time algorithms for two special cases",
    "original_translation": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales",
    "error_count": 7,
    "keys": {
        "early jobs": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "tardy jobs": {
            "translated_key": "tardy",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y <br>tardy</br> con una ventana común con penalización de ubicación Estudios de un único problema de programación de máquinas para minimizar el número ponderado de trabajos tempranos y <br>tardy</br> con una ventana común. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un horario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación.  Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "common due window": {
            "translated_key": [
                "common due",
                "common due",
                "common debido"
            ],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana <br>common due</br> que implique penalización de ubicación Estudios de un único problema de programación de máquinas para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana <br>common due</br>. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana <br>common debido</br> bajo un horario dado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                "common due",
                "common due",
                "common debido"
            ]
        },
        "single machine scheduling problem": {
            "translated_key": "problema de programación de una sola máquina",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un <br>problema de programación de una sola máquina</br> para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida.  Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "decision variable": {
            "translated_key": "decision",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado, pero la ubicación de la ventana es una variable <br>decision</br>. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "location penalty": {
            "translated_key": [
                "location penality",
                "location"
            ],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común que incluye <br>location penality</br> Estudia un único problema de programación de máquinas para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un horario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de <br>location</br>. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                "location penality",
                "location"
            ]
        },
        "NP-complete problem": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "dynamic programming": {
            "translated_key": "programación dinámica",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en <br>programación dinámica</br>. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "pseudo-polynomial algorithm": {
            "translated_key": "pseudo-polinomio",
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo de programación dinámica basado en <br>pseudo-polinomio</br>. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": [
                ""
            ]
        },
        "computational complexity": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "minimisation": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        },
        "production control": {
            "translated_key": [],
            "translated_annotated_text": "Minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida que implica penalidad de ubicación Estudios un problema de programación de una sola máquina para minimizar el número ponderado de trabajos tempranos y tardíos con una ventana común debida. Hay n trabajos no preventivos y simultáneamente disponibles. Cada trabajo incurrirá en una penalización temprana (tarde) si es temprano (tarde) con respecto a la ventana común debida bajo un horario determinado. El tamaño de la ventana es un parámetro dado pero la ubicación de la ventana es una variable de decisión. El objetivo del problema es encontrar un calendario que minimice el número ponderado de trabajos tempranos y tardíos y la penalización de ubicación. Demostramos que el problema es NP-completo en el sentido ordinario y desarrollamos un algoritmo pseudo-polinomio basado en programación dinámica. Realizamos experimentos computacionales, cuyos resultados muestran que el rendimiento del algoritmo dinámico es muy bueno en términos de necesidad de memoria y tiempo de CPU. También proporcionamos algoritmos de tiempo polinomio para dos casos especiales ",
            "error": []
        }
    }
}