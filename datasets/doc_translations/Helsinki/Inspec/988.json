{
    "original_text": "A new merging algorithm for constructing suffix trees for integer alphabets A new approach for constructing a suffix tree T/sub s/ for a given string S is to construct recursively a suffix tree T/sub o/ for odd positions, construct a suffix, tree T/sub e/ for even positions from T/sub o/ and then merge T/sub o/ and T/sub e/ into T/sub s/. To construct suffix trees for integer alphabets in linear time had been a major open problem on index data structures. Farach used this approach and gave the first linear-time algorithm for integer alphabets. The hardest part of Farachs algorithm is the merging step. In this paper we present a new and simpler merging algorithm based on a coupled BFS (breadth-first search). Our merging algorithm is more intuitive than Farachs coupled DFS (depth-first search) merging, and thus it can be easily extended to other applications",
    "original_translation": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones",
    "error_count": 5,
    "keys": {
        "merging algorithm": {
            "translated_key": "algoritmo de fusión",
            "translated_annotated_text": "Un nuevo \"algoritmo de fusión\" para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena dada S es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares desde T/sub o/ y luego fusionar T/sub o/ y T/sub e/ Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un nuevo y más simple \"algoritmo de fusión\" basado en una BFS acoplada (búsqueda de primer orden). Nuestro \"algoritmo de fusión\" es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda de profundidad-primera), y por lo tanto se puede extender fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "recursive construction": {
            "translated_key": [],
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": []
        },
        "index data structures": {
            "translated_key": "estructuras de datos de índice",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en \"estructuras de datos de índice\". Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "coupled BFS": {
            "translated_key": "BFS acoplada",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en una \"BFS acoplada\" (búsqueda en primer plano). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "breadth-first search": {
            "translated_key": "búsqueda de primer orden",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (\"búsqueda de primer orden\"). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "suffix trees": {
            "translated_key": "árboles sufijos",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir \"árboles sufijos\" para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares desde T/sub o/ y luego fusionar T/sub o/ y T/sub e Construir \"árboles sufijos\" para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "integer alphabets": {
            "translated_key": "alfabetos enteros",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para \"alfabetos enteros\" Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares desde T/sub o/ y luego fusionar T/sub o/ y T/sub e/ Construir árboles sufijos para \"alfabetos enteros\" en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índices. Farach utilizó este enfoque y dio el primer algoritmo de tiempo lineal para \"alfabetos enteros\". La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "linear time": {
            "translated_key": "tiempo lineal",
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en \"tiempo lineal\" había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "computational complexity": {
            "translated_key": [],
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": []
        },
        "merging": {
            "translated_key": "fusión",
            "translated_annotated_text": "Un nuevo algoritmo de \"fusión\" para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares desde T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de la \"fusión\". En este artículo presentamos un algoritmo de \"fusión\" nuevo y más simple basado en un BFS acoplado (búsqueda en primer plano). Nuestro algoritmo de \"fusión\" es más intuitivo que Farachs acoplado DFS (profundidad-primera búsqueda) \"fusión\", y por lo tanto se puede ampliar fácilmente a otras aplicaciones ",
            "error": [
                ""
            ]
        },
        "string matching": {
            "translated_key": [],
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": []
        },
        "tree data structures": {
            "translated_key": [],
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": []
        },
        "tree searching": {
            "translated_key": [],
            "translated_annotated_text": "Un nuevo algoritmo de fusión para construir árboles sufijos para alfabetos enteros Un nuevo enfoque para construir un árbol sufijo T/sub s/ para una cadena S dada es construir recursivamente un árbol sufijo T/sub o/ para posiciones impares, construir un sufijo, árbol T/sub e/ para posiciones pares de T/sub o/ y luego fusionar T/sub o/ y T/sub e/ en T/sub Construir árboles sufijos para alfabetos enteros en tiempo lineal había sido un gran problema abierto en las estructuras de datos de índice. Farach usó este enfoque y dio el primer algoritmo de tiempo lineal para alfabetos enteros. La parte más difícil del algoritmo de Farachs es el paso de fusión. En este artículo presentamos un algoritmo de fusión nuevo y más simple basado en un BFS acoplado (búsqueda de primer orden). Nuestro algoritmo de fusión es más intuitivo que la fusión DFS acoplada a Farachs (búsqueda en profundidad) y por lo tanto puede extenderse fácilmente a otras aplicaciones ",
            "error": []
        }
    }
}