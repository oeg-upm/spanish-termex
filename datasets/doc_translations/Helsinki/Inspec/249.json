{
    "original_text": "Randomized two-process wait-free test-and-set We present the first explicit, and currently simplest, randomized algorithm for two-process wait-free test-and-set. It is implemented with two 4-valued single writer single reader atomic variables. A test-and-set takes at most 11 expected elementary steps, while a reset takes exactly 1 elementary step. Based on a finite-state analysis, the proofs of correctness and expected length are compressed into one table",
    "original_translation": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla",
    "error_count": 11,
    "keys": {
        "randomized two-process wait-free test-and-set": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "randomized algorithm": {
            "translated_key": "aleatorio explícito y actualmente más simple",
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo <br>aleatorio explícito y actualmente más simple</br> para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": [
                ""
            ]
        },
        "4-valued single writer single reader atomic variables": {
            "translated_key": "4-valoradas de un solo escritor y lector único",
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas <br>4-valoradas de un solo escritor y lector único</br>. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": [
                ""
            ]
        },
        "expected elementary steps": {
            "translated_key": "pasos elementales esperados",
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 <br>pasos elementales esperados</br>, mientras que un reinicio toma exactamente 1 paso elemental.  Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": [
                ""
            ]
        },
        "finite-state analysis": {
            "translated_key": "finite-state",
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis <br>finite-state</br>, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": [
                ""
            ]
        },
        "correctness proofs": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "symmetry breaking": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "asynchronous distributed protocols": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "fault-tolerance": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "shared memory": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "wait-free read/write registers": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "distributed algorithms": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "message passing": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "randomised algorithms": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        },
        "theorem proving": {
            "translated_key": [],
            "translated_annotated_text": "Test-and-set de dos procesos aleatorios sin espera Presentamos el primer algoritmo aleatorio explícito, y actualmente más simple, para test-and-set de dos procesos sin espera. Se implementa con dos variables atómicas de un solo lector de 4 valores. Un test-and-set toma como máximo 11 pasos elementales esperados, mientras que un reinicio toma exactamente 1 paso elemental. Sobre la base de un análisis de estado finito, las pruebas de corrección y longitud esperada se comprimen en una sola tabla ",
            "error": []
        }
    }
}