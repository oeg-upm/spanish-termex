{
    "original_text": "Handles and exception safety, Part 1. A simple handle class Every C++ program that uses inheritance must manage memory somehow. The most obvious way to do so is directly, but programmers who create complicated data structures often have trouble figuring out what parts of those data structures are safe to delete when. The classical method of dealing with such complexity is to hide it in a class. Such classes are typically called handles; the idea is to attach a handle object to another object that contains the actual data. The simplest form of a handle, which we have discussed in this article, is one in which each handle object corresponds to a single object from the inheritance hierarchy. Such handles are straightforward to use and to implement and tend to be intrinsically exception safe in almost all respects. The one exception hazard in such a class is typically the assignment operator. Assignment operators often test for self-assignment to avoid aliasing problems. As Herb Sutter has observed (2000), programs that need such tests are almost always exception unsafe. By rewriting the assignment operator, we ensure that we do not do anything irrevocable until the possibility of throwing an exception has passed. This strategy ensures that if an exception occurs while our assignment operator is executing, we do not corrupt the rest of our system",
    "original_translation": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema",
    "error_count": 7,
    "keys": {
        "handles": {
            "translated_key": [
                "handles",
                "manejos"
            ],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente \"handles\"; la idea es adjuntar un objeto manillar a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Tales \"manejos\" son fáciles de usar y de implementar y tienden a ser intrínsecamente la excepción segura en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                "handles",
                "manejos"
            ]
        },
        "assignment operator": {
            "translated_key": [
                "operador de la asignación",
                "operador de asignación",
                "operador de asignación"
            ],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el \"operador de la asignación\". Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el \"operador de asignación\", nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro \"operador de asignación\" está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                "operador de la asignación",
                "operador de asignación",
                "operador de asignación"
            ]
        },
        "self-assignment": {
            "translated_key": "auto-asignación",
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban para \"auto-asignación\" para evitar alias problemas. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                ""
            ]
        },
        "aliasing problems": {
            "translated_key": "problemas de aliasing",
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban para auto-asignación para evitar \"problemas de aliasing\". Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                ""
            ]
        },
        "exception": {
            "translated_key": "excepción",
            "translated_annotated_text": "Mangos y seguridad de \"excepción\", Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Tales mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente \"excepción\" seguro en casi todos los aspectos. El único peligro de \"excepción\" en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre \"excepción\" inseguros. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que haya pasado la posibilidad de lanzar una \"excepción\". Esta estrategia asegura que si una \"excepción\" ocurre mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                ""
            ]
        },
        "C++ program": {
            "translated_key": "programa C++",
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada \"programa C++\" que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                ""
            ]
        },
        "inheritance hierarchy": {
            "translated_key": "jerarquía de herencia",
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la \"jerarquía de herencia\". Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                ""
            ]
        },
        "C++ language": {
            "translated_key": [],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": []
        },
        "exception handling": {
            "translated_key": [],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": []
        },
        "inheritance": {
            "translated_key": [
                "herencia",
                "heredancia"
            ],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza \"herencia\" debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de \"heredancia\". Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": [
                "herencia",
                "heredancia"
            ]
        },
        "object-oriented programming": {
            "translated_key": [],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": []
        },
        "storage management": {
            "translated_key": [],
            "translated_annotated_text": "Manijas y seguridad de excepción, Parte 1. Una clase de manejo simple Cada programa C++ que utiliza la herencia debe manejar la memoria de alguna manera. La forma más obvia de hacerlo es directamente, pero los programadores que crean estructuras de datos complicadas a menudo tienen problemas para averiguar qué partes de esas estructuras de datos son seguras de eliminar cuando. El método clásico de lidiar con tal complejidad es esconderla en una clase. Tales clases se llaman típicamente manijas; la idea es adjuntar un objeto de manija a otro objeto que contiene los datos reales. La forma más simple de un mango, que hemos discutido en este artículo, es una en la que cada objeto manejable corresponde a un único objeto de la jerarquía de la herencia. Estos mangos son fáciles de usar y de implementar y tienden a ser intrínsecamente seguros en casi todos los aspectos. El único peligro de excepción en tal clase es típicamente el operador de la asignación. Los operadores de asignación a menudo prueban la auto-asignación para evitar problemas de alias. Como ha observado Herb Sutter (2000), los programas que necesitan tales pruebas son casi siempre una excepción insegura. Al reescribir el operador de la asignación, nos aseguramos de que no hagamos nada irrevocable hasta que la posibilidad de lanzar una excepción haya pasado. Esta estrategia asegura que si se produce una excepción mientras nuestro operador de asignación está ejecutando, no corrompemos el resto de nuestro sistema ",
            "error": []
        }
    }
}