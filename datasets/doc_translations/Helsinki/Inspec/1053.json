{
    "original_text": "A static semantics for Haskell This paper gives a static semantics for Haskell 98, a non-strict purely functional programming language. The semantics formally specifies nearly all the details of the Haskell 98 type system, including the resolution of overloading, kind inference (including defaulting) and polymorphic recursion, the only major omission being a proper treatment of ambiguous overloading and its resolution. Overloading is translated into explicit dictionary passing, as in all current implementations of Haskell. The target language of this translation is a variant of the Girard-Reynolds polymorphic lambda calculus featuring higher order polymorphism. and explicit type abstraction and application in the term language. Translated programs can thus still be type checked, although the implicit version of this system is impredicative. A surprising result of this formalization effort is that the monomorphism restriction, when rendered in a system of inference rules, compromises the principal type property",
    "original_translation": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo",
    "error_count": 6,
    "keys": {
        "static semantics": {
            "translated_key": "static semántica",
            "translated_annotated_text": "A <br>static semántica</br> para Haskell Este artículo da una <br>static semántica</br> para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "Haskell 98": {
            "translated_key": "Haskell 98",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para <br>Haskell 98</br>, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo <br>Haskell 98</br>, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión mayor un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "nonstrict purely functional programming language": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "formal specification": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "type system": {
            "translated_key": "type",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema Haskell 98 <br>type</br>, incluyendo la resolución de sobrecargas, inferencias (incluyendo incumplimientos) y recursiones polimórficas, siendo la única omisión mayor un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "overloading": {
            "translated_key": "sobrecarga",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de <br>sobrecarga</br>, inferencia de tipo (incluyendo defaulting) y recursión polimórfica, siendo la única omisión importante un tratamiento adecuado de la carga ambigua<br>sobrecarga</br> y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "kind inference": {
            "translated_key": "kind",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de la sobrecarga, la inferencia <br>kind</br> (incluyendo el incumplimiento) y la recursión polimórfica, siendo la única omisión mayor un tratamiento adecuado de la sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "polymorphic recursion": {
            "translated_key": " recursión polimórfica",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias de tipo (incluyendo defaulting) y <br> recursión polimórfica</br>, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "explicit dictionary passing": {
            "translated_key": "explicit passing",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce al diccionario <br>explicit passing</br>, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "polymorphic lambda calculus": {
            "translated_key": "polymorphic lambda calculus",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante de la Girard-Reynolds <br>polymorphic lambda calculus</br> con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "higher order polymorphism": {
            "translated_key": "polimorfismo de orden superior",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con <br>polimorfismo de orden superior</br>. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "explicit type abstraction": {
            "translated_key": " abstracción explícita de tipo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y <br> abstracción explícita de tipo</br> y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "term language": {
            "translated_key": "term",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y la abstracción y aplicación explícitas de tipo en el lenguaje <br>term</br>. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "type checking": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "monomorphism restriction": {
            "translated_key": "restricción del monomorfismo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la <br>restricción del monomorfismo</br>, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad de tipo principal.  ",
            "error": [
                ""
            ]
        },
        "inference rules": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia <br>, compromete la propiedad principal de tipo ",
            "error": []
        },
        "functional languages": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "lambda calculus": {
            "translated_key": "lambda",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico Girard-Reynolds <br>lambda</br> con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "programming language semantics": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo polimórfico de Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        }
    }
}