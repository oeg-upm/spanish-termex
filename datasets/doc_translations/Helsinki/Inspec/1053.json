{
    "original_text": "A static semantics for HaskellThis paper gives a static semantics for Haskell 98, a non-strict purely\tfunctional programming language. The semantics formally specifies\tnearly all the details of the Haskell 98 type system, including the\tresolution of overloading, kind inference (including defaulting) and\tpolymorphic recursion, the only major omission being a proper treatment\tof ambiguous overloading and its resolution. Overloading is translated\tinto explicit dictionary passing, as in all current implementations of\tHaskell. The target language of this translation is a variant of the\tGirard-Reynolds polymorphic lambda calculus featuring higher order\tpolymorphism. and explicit type abstraction and application in the term\tlanguage. Translated programs can thus still be type checked, although\tthe implicit version of this system is impredicative. A surprising\tresult of this formalization effort is that the monomorphism\trestriction, when rendered in a system of inference rules, compromises\tthe principal type property",
    "original_translation": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
    "error_count": 9,
    "keys": {
        "static semantics": {
            "translated_key": "semántica estática",
            "translated_annotated_text": "Una \"semántica estática\" para HaskellEste artículo da una \"semántica estática\" para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "Haskell 98": {
            "translated_key": "Haskell 98",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para \"Haskell 98\", un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema tipo \"Haskell 98\", incluyendo la resolución de sobrecargas, inferencias (incluyendo incumplimientos) y recursiones polimórficas, siendo la única omisión mayor un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "nonstrict purely functional programming language": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "formal specification": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "type system": {
            "translated_key": "sistema de tipo",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del \"sistema de tipo\" Haskell 98, incluyendo la resolución de sobrecarga, inferencia amable (incluyendo incumplimiento) y recursión polimórfica, siendo la única omisión mayor un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "overloading": {
            "translated_key": "sobrecarga",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de la \"sobrecarga\", inferencia de tipo (incluyendo incumplimiento) y recursión polimórfica, la única omisión importante es un tratamiento adecuado de la \"sobrecarga\" ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "kind inference": {
            "translated_key": "inferencia amable",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecarga, \"inferencia amable\" (incluyendo incumplimiento) y recursión polimórfica, la única omisión importante es un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "polymorphic recursion": {
            "translated_key": "recurrencia polimórfica",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecarga, inferencia amable (incluyendo incumplimiento) y \"recurrencia polimórfica\", la única omisión importante es un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "explicit dictionary passing": {
            "translated_key": "pasar diccionario explícito",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en \"pasar diccionario explícito\", como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "polymorphic lambda \tcalculus": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "higher order polymorphism": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "explicit type abstraction": {
            "translated_key": "abstracción explícita de tipo",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y \"abstracción explícita de tipo\" y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "term \tlanguage": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "type checking": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "monomorphism restriction": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "inference rules": {
            "translated_key": "reglas de inferencia",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción monomorfista, cuando se traduce en un sistema de \"reglas de inferencia\", compromete la propiedad principal tipo ",
            "error": ""
        },
        "functional languages": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "lambda calculus": {
            "translated_key": "lambda cálculo",
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del \"lambda cálculo\" polimórfico Girard-Reynolds con un polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": ""
        },
        "programming language semantics": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para HaskellEste artículo ofrece una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        }
    }
}