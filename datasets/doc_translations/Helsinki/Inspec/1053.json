{
    "original_text": "A static semantics for Haskell This paper gives a static semantics for Haskell 98, a non-strict purely functional programming language. The semantics formally specifies nearly all the details of the Haskell 98 type system, including the resolution of overloading, kind inference (including defaulting) and polymorphic recursion, the only major omission being a proper treatment of ambiguous overloading and its resolution. Overloading is translated into explicit dictionary passing, as in all current implementations of Haskell. The target language of this translation is a variant of the Girard-Reynolds polymorphic lambda calculus featuring higher order polymorphism. and explicit type abstraction and application in the term language. Translated programs can thus still be type checked, although the implicit version of this system is impredicative. A surprising result of this formalization effort is that the monomorphism restriction, when rendered in a system of inference rules, compromises the principal type property",
    "original_translation": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo",
    "error_count": 5,
    "keys": {
        "static semantics": {
            "translated_key": "semántica estática",
            "translated_annotated_text": "Una \"semántica estática\" para Haskell Este artículo da una \"semántica estática\" para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "Haskell 98": {
            "translated_key": "Haskell 98",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para \"Haskell 98\", un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema tipo \"Haskell 98\", incluyendo la resolución de sobrecargas, inferencias (incluyendo incumplimientos) y recursiones polimórficas, siendo la única omisión mayor un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "nonstrict purely functional programming language": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "formal specification": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "type system": {
            "translated_key": "sistema de tipo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del \"sistema de tipo\" Haskell 98, incluyendo la resolución de sobrecarga, inferencia amable (incluyendo incumplimiento) y recursión polimórfica, siendo la única omisión mayor un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "overloading": {
            "translated_key": "sobrecarga",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de la \"sobrecarga\", inferencia de tipo (incluyendo incumplimiento) y recursión polimórfica, la única omisión importante es un tratamiento adecuado de la \"sobrecarga\" ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "kind inference": {
            "translated_key": "inferencia amable",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecarga, \"inferencia amable\" (incluyendo incumplimiento) y recursión polimórfica, la única omisión importante es un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "polymorphic recursion": {
            "translated_key": "recurrencia polimórfica",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecarga, inferencia amable (incluyendo incumplimiento) y \"recurrencia polimórfica\", la única omisión importante es un tratamiento adecuado de sobrecarga ambigua y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "explicit dictionary passing": {
            "translated_key": "pasar diccionario explícito",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en \"pasar diccionario explícito\", como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "polymorphic lambda calculus": {
            "translated_key": "polymorphic lambda cálculo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante de la Girard-Reynolds \"polymorphic lambda cálculo\" con el polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "higher order polymorphism": {
            "translated_key": "polimorfismo de orden superior",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con \"polimorfismo de orden superior\". y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "explicit type abstraction": {
            "translated_key": "abstracción explícita de tipo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y \"abstracción explícita de tipo\" y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "term language": {
            "translated_key": "lenguaje de término",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el \"lenguaje de término\". Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "type checking": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "monomorphism restriction": {
            "translated_key": "restricción monomorfista",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la \"restricción monomorfista\", cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "inference rules": {
            "translated_key": "reglas de inferencia",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción monomorfista, cuando se traduce en un sistema de \"reglas de inferencia\", compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "functional languages": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        },
        "lambda calculus": {
            "translated_key": "lambda cálculo",
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del \"lambda cálculo\" polimórfico Girard-Reynolds con un polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": [
                ""
            ]
        },
        "programming language semantics": {
            "translated_key": [],
            "translated_annotated_text": "Una semántica estática para Haskell Este artículo da una semántica estática para Haskell 98, un lenguaje de programación puramente funcional no estricto. La semántica especifica formalmente casi todos los detalles del sistema de tipo Haskell 98, incluyendo la resolución de sobrecargas, inferencias (incluyendo defaulting) y recursiones polimórficas, siendo la única omisión importante un tratamiento adecuado de sobrecargas ambiguas y su resolución. La sobrecarga se traduce en diccionario explícito pasando, como en todas las implementaciones actuales de Haskell. El lenguaje objetivo de esta traducción es una variante del cálculo Lambda polimórfico Girard-Reynolds con polimorfismo de orden superior. y explícitamente tipo abstracción y aplicación en el término lenguaje. Por lo tanto, los programas traducidos todavía pueden ser revisados por tipo, aunque la versión implícita de este sistema es impredicativa. Un resultado sorprendente de este esfuerzo de formalización es que la restricción del monomorfismo, cuando se traduce en un sistema de reglas de inferencia, compromete la propiedad principal tipo ",
            "error": []
        }
    }
}