{
    "original_text": "A network simplex algorithm with O(n) consecutive degenerate pivots We suggest a pivot rule for the primal simplex algorithm for the minimum cost flow problem, known as the network simplex algorithm. Due to degeneracy, cycling may occur in the network simplex algorithm. The cycling can be prevented by maintaining strongly feasible bases proposed by Cunningham (1976); however, if we do not impose any restrictions on the entering variables, the algorithm can still perform an exponentially long sequence of degenerate pivots. This phenomenon is known as stalling. Researchers have suggested several pivot rules with the following bounds on the number of consecutive degenerate pivots: m, n/sup 2/, k(k + 1)/2, where n is the number of nodes in the network, m is the number of arcs in the network, and k is the number of degenerate arcs in the basis. (Observe that k <or= n.) In this paper, we describe an anti-stalling pivot rule that ensures that the network simplex algorithm performs at most k consecutive degenerate pivots. This rule uses a negative cost augmenting cycle to identify a sequence of entering variables",
    "original_translation": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada",
    "error_count": 6,
    "keys": {
        "network simplex algorithm": {
            "translated_key": " con pivotes degenerados consecutivos O(n) Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de coste mínimo, conocido como algoritmo simplex de red <br>. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red <br> ",
            "translated_annotated_text": "Un algoritmo simplex de red <br> con pivotes degenerados consecutivos O(n) Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de coste mínimo, conocido como algoritmo simplex de red <br>. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red <br> </br>. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Observe que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red <br> realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "degenerate pivots": {
            "translated_key": [
                "degenerate pivots",
                "degenerados",
                "degenerados",
                "degenerate pivotes"
            ],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) consecutivos <br>degenerate pivots</br> Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de coste mínimo, conocido como algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo todavía puede realizar una secuencia exponencialmente larga de pivotes <br>degenerados</br>. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos <br>degenerados</br>: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote antiestacionamiento que asegura que el algoritmo simplex de red realice como máximo k consecutivos <br>degenerate pivotes</br>. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                "degenerate pivots",
                "degenerados",
                "degenerados",
                "degenerate pivotes"
            ]
        },
        "minimum cost flow problem": {
            "translated_key": "problema de flujo de costo mínimo",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el <br>problema de flujo de costo mínimo</br>, conocido como el algoritmo simplex de red.  Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "degeneracy": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración <br>, el ciclo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        },
        "cycling": {
            "translated_key": "cycling",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, <br>cycling</br> puede ocurrir en el algoritmo simplex de red. El <br>cycling</br> se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo todavía puede realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "stalling": {
            "translated_key": [
                "stall",
                "estacionamiento"
            ],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como <br>stall</br>. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-<br>estacionamiento</br> que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                "stall",
                "estacionamiento"
            ]
        },
        "anti-stalling pivot rule": {
            "translated_key": "regla de pivote anti-estacionamiento",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una <br>regla de pivote anti-estacionamiento</br> que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos.  Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "negative cost augmenting cycle": {
            "translated_key": "negativo",
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes <br>negativo</br> para identificar una secuencia de variables de entrada ",
            "error": [
                ""
            ]
        },
        "computational complexity": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        },
        "minimisation": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        },
        "trees (mathematics)": {
            "translated_key": [],
            "translated_annotated_text": "Un algoritmo simplex de red con O(n) pivotes degenerados consecutivos Sugerimos una regla de pivote para el algoritmo simplex primario para el problema de flujo de costo mínimo, conocido como el algoritmo simplex de red. Debido a la degeneración, el ciclismo puede ocurrir en el algoritmo simplex de la red. El ciclismo se puede evitar manteniendo bases fuertemente viables propuestas por Cunningham (1976); sin embargo, si no imponemos ninguna restricción a las variables entrantes, el algoritmo puede todavía realizar una secuencia exponencialmente larga de pivotes degenerados. Este fenómeno se conoce como estancamiento. Los investigadores han sugerido varias reglas de pivote con los siguientes límites en el número de pivotes consecutivos degenerados: m, n/sup 2/, k(k + 1)/2, donde n es el número de nodos en la red, m es el número de arcos en la red, y k es el número de arcos degenerados en la base. (Obsérvese que k <or= n.) En este artículo, describimos una regla de pivote anti-estacionamiento que asegura que el algoritmo simplex de red realice como máximo k pivotes degenerados consecutivos. Esta regla utiliza un ciclo de aumento de costes negativo para identificar una secuencia de variables de entrada ",
            "error": []
        }
    }
}