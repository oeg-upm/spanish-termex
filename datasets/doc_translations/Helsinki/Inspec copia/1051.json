{
    "original_text": "Faking it: simulating dependent types in Haskell Dependent types reflect the fact that validity of data is often a relative notion by allowing prior data to affect the types of subsequent data. Not only does this make for a precise type system, but also a highly generic one: both the type and the program for each instance of a family of operations can be computed from the data which codes for that instance. Recent experimental extensions to the Haskell type class mechanism give us strong tools to relativize types to other types. We may simulate some aspects of dependent typing by making counterfeit type-level copies of data, with type constructors simulating data constructors and type classes simulating datatypes. This paper gives examples of the technique and discusses its potential",
    "original_translation": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial",
    "error_count": 7,
    "keys": {
        "dependent types": {
            "translated_key": "dependientes",
            "translated_annotated_text": "Fingiéndolo: simular tipos <br>dependientes</br> en tipos dependientes de Haskell reflejan el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos previos afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "Haskell": {
            "translated_key": "Los tipos dependientes reflejan el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos previos afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase <br>Haskell",
            "translated_annotated_text": "Fingiéndolo: simular tipos dependientes en <br>Los tipos dependientes reflejan el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos previos afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase <br>Haskell</br> nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "data validity": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "precise type system": {
            "translated_key": "preciso",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo <br>preciso</br>, sino también uno altamente genérico: tanto el tipo como el programa para cada instancia de una familia de operaciones pueden calcularse a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "type class mechanism": {
            "translated_key": "type class",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase Haskell <br>type class</br> nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "dependent typing": {
            "translated_key": "dependent typing",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de <br>dependent typing</br> haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "counterfeit type-level copies": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la mecanografía dependiente haciendo copias a nivel de tipo <br> de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "type constructors": {
            "translated_key": " de tipo",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores <br> de tipo</br> simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "data constructors": {
            "translated_key": "constructores de datos",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando <br>constructores de datos</br> y clases de tipo simulando tipos de datos.  Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "datatypes": {
            "translated_key": "datatypes",
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando <br>datatypes</br>. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": [
                ""
            ]
        },
        "functional programming": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "data structures": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "functional languages": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        },
        "type theory": {
            "translated_key": [],
            "translated_annotated_text": "Fingirlo: simular tipos dependientes en tipos dependientes de Haskell refleja el hecho de que la validez de los datos es a menudo una noción relativa al permitir que los datos anteriores afecten a los tipos de datos posteriores. Esto no sólo hace que para un sistema de tipo preciso, sino también uno altamente genérico: tanto el tipo y el programa para cada instancia de una familia de operaciones se puede calcular a partir de los datos que codifican para esa instancia. Las recientes extensiones experimentales al mecanismo de clase tipo Haskell nos dan herramientas fuertes para relativizar tipos a otros tipos. Podemos simular algunos aspectos de la escritura dependiente haciendo copias falsas a nivel de tipo de datos, con constructores de tipo simulando constructores de datos y clases de tipo simulando tipos de datos. Este artículo da ejemplos de la técnica y discute su potencial ",
            "error": []
        }
    }
}