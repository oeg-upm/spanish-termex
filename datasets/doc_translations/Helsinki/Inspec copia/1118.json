{
    "original_text": "Run-time data-flow analysis Parallelizing compilers have made great progress in recent years. However, there still remains a gap between the current ability of parallelizing compilers and their final goals. In order to achieve the maximum parallelism, run-time techniques were used in parallelizing compilers during last few years. First, this paper presents a basic run-time privatization method. The definition of run-time dead code is given and its side effect is discussed. To eliminate the imprecision caused by the run-time dead code, backward data-flow information must be used. Proteus Test, which can use backward information in run-time, is then presented to exploit more dynamic parallelism. Also, a variation of Proteus Test, the Advanced Proteus Test, is offered to achieve partial parallelism. Proteus Test was implemented on the parallelizing compiler AFT. In the end of this paper the program fpppp.f of Spec95fp Benchmark is taken as an example, to show the effectiveness of Proteus Test",
    "original_translation": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test",
    "error_count": 6,
    "keys": {
        "run-time data flow analysis": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        },
        "parallelizing compilers": {
            "translated_key": [
                "paralelizadores",
                " "
            ],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de los compiladores <br>paralelizadores</br> y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en compiladores paralelizados <br> </br>. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                "paralelizadores",
                " "
            ]
        },
        "run-time privatization method": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        },
        "run-time dead code": {
            "translated_key": [
                "run-time dead code",
                "run-time dead"
            ],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de <br>run-time dead code</br> y se discute su efecto secundario. Para eliminar la imprecisión causada por el código <br>run-time dead</br>, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                "run-time dead code",
                "run-time dead"
            ]
        },
        "backward data-flow information": {
            "translated_key": "backward",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe usar la información de flujo de datos <br>backward</br>. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                ""
            ]
        },
        "Proteus Test": {
            "translated_key": "Proteus Test",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. <br>Proteus Test</br>, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, se ofrece una variación de <br>Proteus Test</br>, el Advanced <br>Proteus Test</br>, para lograr un paralelismo parcial. <br>Proteus Test</br> fue implementado en el compilador paralelizador AFT. Al final de este artículo se toma como ejemplo el programa fpppp.f de Spec95fp Benchmark, para mostrar la efectividad de <br>Proteus Test</br> ",
            "error": [
                ""
            ]
        },
        "dynamic parallelism": {
            "translated_key": "dinámico",
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta para explotar más paralelismo <br>dinámico</br>. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": [
                ""
            ]
        },
        "data flow analysis": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        },
        "parallelising compilers": {
            "translated_key": [],
            "translated_annotated_text": "Análisis de flujo de datos en tiempo de ejecución Paralelizar compiladores ha hecho grandes progresos en los últimos años. Sin embargo, sigue existiendo una brecha entre la capacidad actual de paralelizar los compiladores y sus objetivos finales. Para lograr el máximo paralelismo, durante los últimos años se utilizaron técnicas de tiempo de ejecución en la paralelización de compiladores. En primer lugar, este documento presenta un método básico de privatización en tiempo de ejecución. Se da la definición de código muerto de tiempo de ejecución y se discute su efecto secundario. Para eliminar la imprecisión causada por el código muerto en tiempo de ejecución, se debe utilizar información de flujo de datos retrógrado. Proteus Test, que puede utilizar información retrógrada en tiempo de ejecución, se presenta entonces para explotar un paralelismo más dinámico. Además, una variación de Proteus Test, el Test Proteus avanzado, se ofrece para lograr el paralelismo parcial. Proteus Test fue implementado en el compilador paralelizador AFT. En el final de este documento el programa fpppp.f de Spec95fp Benchmark se toma como un ejemplo, para mostrar la eficacia de Proteus Test ",
            "error": []
        }
    }
}