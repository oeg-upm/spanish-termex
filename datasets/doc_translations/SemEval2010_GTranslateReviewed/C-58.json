{
    "id": "C-58",
    "original_text": "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information. To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures. We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication. Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1. INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications. Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11]. We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services. For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability. Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information. In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo. A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability. To be used as a basic building block, a SDIMS should have four properties. First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes. Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time. Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines). Second, the system should have flexibility to accommodate a broad range of applications and attributes. For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often. An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes. Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes. Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications. Third, a SDIMS should provide administrative isolation. In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy. A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently. Fourth, the system must be robust to node failures and disconnections. A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur. We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs). Astrolabe [38] is a robust information management system. Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy. It provides a general interface for installing new aggregation functions and provides eventual consistency on its data. Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree. This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information. This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes. Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes. Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes. It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node. Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects. It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs. At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS. However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication? The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1. We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type. This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2. We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3. We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4. We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both. We have built a prototype of SDIMS. Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures. This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS. For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness. Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree. Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions. In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications. In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS. In Section 5, we detail the implementation of our prototype system. Section 6 addresses the issue of adaptation to the topological reconfigurations. In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks. Section 8 details the related work, and Section 9 summarizes our contribution. 2. AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38]. Our aggregation abstraction is defined across a tree spanning all nodes in the system. Each physical node in the system is a leaf and each subtree represents a logical group of nodes. Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department). An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root. We describe how to form such trees in a later section. Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress). The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows. For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists. Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name). Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i. For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property. Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values. Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe. Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3. FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation. The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated. While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements. In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe. This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes. In Figure 1, we illustrate both extreme strategies and an intermediate strategy. Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state. Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves. The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value. Finally, the level-i ancestor sends the result down the tree to the issuing node. In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants. In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values. Also, a leaf satisfies a probe for a level-i aggregate using purely local data. In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent. This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf. Finally, notice that other strategies exist. In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels. A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction. An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision. Note that the read-to-write ratio of the attributes that applications install vary extensively. For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often. An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes. Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes. SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations. With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree. Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree. The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function. The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy. The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity. The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system. The arguments for this operation are listed in Table 1. The attrType argument denotes the type of attributes on which this aggregation function is invoked. Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime. The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj. The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node. The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility. In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree. Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType. This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application. The complete argument set for the probe operation is shown in Table 2. Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute. In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2). Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity. When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A. Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe. The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6. When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function. A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency. But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe. This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation. In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child. We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4. SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas. First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system. Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems. In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name. Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces. For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file. A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file. Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6]. Supporting sparse names within a type provides at least two advantages. First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes. Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes. Given this abstraction, scalably mapping attributes to DHTs is straightforward. DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk. Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees. In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes. Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain. Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient. To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1. Path Locality: Search paths should always be contained in the smallest possible domain. 2. Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain. Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency. For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value. Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node. If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry. We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property. Also the corresponding aggregation tree is shown. L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space. This process continues until the destination node appears in the leaf set, after which the message is routed directly. Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key. Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties. As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id. Our ADHTs routing table differs from Pastrys in two ways. First, each node maintains a separate leaf set for each domain of which it is a part. Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary. Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits). Additional details about the ADHT algorithm are available in an extended technical report [44]. Properties. Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels. Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes. We experimentally quantify the additional routing costs in Section 7. In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain. Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type. Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain. The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes. This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data. Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X? For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5. Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part. In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)). An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)). This computation is illustrated in the Figure 5. Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain. For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))). Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure. It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5. PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values. Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3. In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X.. Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node. We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34]. We refer an (attribute type, attribute name) tuple as an attribute key. As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]). To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors. This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function. Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1). Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here. For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i. These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes. Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26]. Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples. A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors. Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4). So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation. Level-0 differs slightly from other levels. Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB. This local MIB stores information about the local nodes state inserted by local applications via update() calls. We envision various sensor programs and applications insert data into local MIB. For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node. Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table. An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name. Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain. The outstanding probes table maintains temporary information regarding in-progress probes. Given these data structures, it is simple to support the three API functions described in Section 3.1. Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type. Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain. Then, the request is flooded down the tree and installed on all intermediate and leaf nodes. Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key. Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero. Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children. Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree. As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree. In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB. In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4. In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree. In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i). Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it. Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf. For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value. A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires. The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level. At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe. Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute. We implement a lease-based mechanism for dynamic adaptation. A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children. A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent. Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values. We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism. Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions. Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6. ROBUSTNESS In large scale systems, reconfigurations are common. Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time. During reconfigurations, a probe might return a stale value for two reasons. First, reconfigurations lead to incorrectness in the previous aggregate values. Second, the nodes needed for aggregation to answer the probe become unreachable. Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication. Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily. Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links. Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas. We provide two mechanisms for replication in time. First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time. Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter. Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild. On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated. If parent is not null, then aggregation functions and already existing data are lazily transferred in the background. Any new updates, installs, and probes for this prefix are sent to the parent immediately. On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated. On newChild(child, prefix), the AML layer creates space in its data structures for this child. Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration. Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration. Probes that complete or start between points 2 and 8 may return stale answers. On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system. Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations. In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data. Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7). Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents. In our system, however, all internal nodes have to be replicated along with the root. In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system. By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate. For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach. With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios. Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root. However, note that this technique is not appropriate in some cases. An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication. If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7. EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed. In all experiments, we use static up and down values and turn off dynamic adaptation. Our evaluation supports four main conclusions. First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios. For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000. Second, our system is scalable with respect to both nodes and attributes. In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach. Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property. Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates. In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3. We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters. We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes. Simulations with other sizes of networks with different branching factors reveal similar results. This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies. Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up. Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads. Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes. Figure 9 demonstrates the SDIMSs scalability with nodes and attributes. For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes. Each attribute corresponds to the membership in a multicast session with a small number of participants. For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value. We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation. Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme. Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes. Simulations with other session sizes (4 and 16) yield similar results. Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property. In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree. To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes. In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property. When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors. Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry. U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed. We measure the performance of our system with two micro-benchmarks. In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system. Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes. All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds. Notice that the latency in Update-Local is high compared to the Update-UP policy. This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection. In the second benchmark, we examine robustness. We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute. Each node updates the attribute with the value 10. Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes. Figure 13 shows the results on the departmental testbed. Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations. In Figure 14, we present the results of the experiment on PlanetLab testbed. The root node of the aggregation tree is terminated after about 275 seconds. There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs. In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures. From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications. Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function. Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting. Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources. Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered. We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms. First, nodes use SDIMS as a directory to handle read misses. When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL. At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates. Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it. Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry. Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information. To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value. Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent. Spanning trees for streams of pushed updates are maintained in a similar manner. In the future, we plan to use SDIMS for at least two additional services within this replication system. First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41]. Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed. Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint. Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic. As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance. Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view. We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters. For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window. The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes. Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit. Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute. Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8. RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project. Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5]. However, any gossiping scheme requires aggressive replication of the aggregates. While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio. Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios. Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45]. Willow, DASIS and SOMO build a single tree for aggregation. Cone builds a tree per attribute and requires a total order on the attribute values. Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems. Some of them are centralized where all the monitoring data is collected and analyzed at a central host. Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree. Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation. This research is complementary to our work. TAG [21] collects information from a large number of sensors along a single tree. The observation that DHTs internally provide a scalable forest of reduction trees is not new. Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects. Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications. Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface. Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction. Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs. All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT. With the aggregation abstraction provided by our system, designing and building of such applications becomes easier. Internal DHT trees typically do not satisfy domain locality properties required in our system. Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively. SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain. This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain. Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9. CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications. For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability. We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication. Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10. REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer. Join and Leave in Peer-to-Peer Systems: The DASIS approach. Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau. Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java. In Proc. OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J. Mogul. Resource Containers: A New Facility for Resource Management in Server Systems. In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker. Cone: A Distributed Heap-Based Approach to Resource Selection. Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman. The Surprising Power of Epidemic Communication. In Proceedings of FuDiCo, 2003. [6] B. Bloom. Space/time tradeoffs in hash coding with allowable errors. Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron. Exploiting Network Proximity in Peer-to-Peer Overlay Networks. Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh. SplitStream: High-bandwidth Multicast in a Cooperative Environment. In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron. SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure. IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J. Challenger, P. Dantzig, and A. Iyengar. A scalable and highly available system for serving dynamic data at frequently accessed web sites. In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris. Serving DNS using a Peer-to-Peer Lookup Service. In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng. PRACTI replication for large-scale systems. Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk. Bitmap algorithms for counting active flows on high speed links. In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J. Chase, B. Chun, S. Schwab, and A. Vahdat. SHARP: An architecture for secure resource peering. In Proc. SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu. What Can Peer-to-Peer Do for Databases, and Vice Versa? In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica. The Impact of DHT Routing Geometry on Resilience and Proximity. In SIGCOMM, 2003. [18] N. J. A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman. SkipNet: A Scalable Overlay Network with Practical Locality Properties. In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica. Querying the Internet with PIER. In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin. Directed diffusion: a scalable and robust communication paradigm for sensor networks. In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks. In OSDI, 2002. [22] D. Malkhi. Dynamic Lookup Networks. In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler. The ganglia distributed monitoring system: Design, implementation, and experience. In submission. [24] P. Maymounkov and D. Mazieres. Kademlia: A Peer-to-peer Information System Based on the XOR Metric. In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom. Offering a precision-performance tradeoff for aggregation queries over replicated data. In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers. Flexible Update Propagation for Weakly Consistent Replication. In Proc. SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa. Accessing Nearby Copies of Replicated Objects in a Distributed Environment. In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker. A Scalable Content Addressable Network. In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica. Routing Algorithms for DHTs: Some Open Questions. In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand. InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems. In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel. Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems. In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker. Application-level Multicast using Content-addressable Networks. In Proceedings of the NGC, November 2001. [34] W. Stallings. SNMP, SNMPv2, and CMIP. Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan. Chord: A scalable Peer-To-Peer lookup service for internet applications. In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz. Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination. In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels. Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining. TOCS, 2003. [39] R. VanRenesse and A. Bozdog. Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol. In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin. Bandwidth constrained placement in a wan. In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin. Potential costs and benefits of long-term prefetching for content-distribution. Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe. Sophia: An Information Plane for Networked Systems. In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes. The network weather service: A distributed resource performance forecasting service for metacomputing. Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin. SDIMS: A scalable distributed information management system. Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu. SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT. In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph. Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing. Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390",
    "original_translation": "Un sistema escalable de gestión de información distribuida ∗ praveen yalagandula ypraveen@cs.utexas.edu mike dahlin dahlin@cs.utexas.edu Departamento de ciencias informáticas La Universidad de Texas en Austin Austin, TX 78712 Resumen. Presentamos un sistema de gestión de información distribuido escalable (SDIMS SDIMS) que agrega información sobre los sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones distribuidas a gran escala al proporcionar vistas detalladas de la información cercana y las vistas sumarias de la información global. Para servir como un bloque de construcción básico, un SDIMS debe tener cuatro propiedades: escalabilidad a muchos nodos y atributos, flexibilidad para acomodar una amplia gama de aplicaciones, aislamiento administrativo para la seguridad y la disponibilidad, y la robustez a las fallas de nodos y redes. Diseñamos, implementamos y evaluamos un SDIMS que (1) aprovecha las tablas de hash distribuidas (DHT) para crear árboles de agregación escalables, (2) proporciona flexibilidad a través de una API simple que permite que las aplicaciones controlen la propagación de lecturas y escrituras, (3) proporciona aislamiento administrativoA través de extensiones simples a los algoritmos DHT actuales, y (4) logra robustez a las reconfiguraciones de nodos y redes a través de la reegregación perezosa, la reegregación a pedido y la replicación espacial sintonizable. A través de extensas simulaciones y experimentos de micro benchmark, observamos que nuestro sistema es un orden de magnitud más escalable que los enfoques existentes, logra propiedades de aislamiento a costa de una latencia de lectura modestamente aumentada en comparación con los DHT planos y maneja con gracia fallas. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: sistemas operativos de red de sistemas distribuidos, bases de datos distribuidas de gestión de términos generales, diseño, experimentación 1. Introducción El objetivo de esta investigación es diseñar y construir un Sistema de Gestión de Información Distribuida escalable (SDIMS) que agregue información sobre sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones distribuidas a gran escala. Monitoreo, consulta y reaccionamiento a los cambios en el estado de un sistema distribuido son componentes centrales de aplicaciones como la gestión del sistema [15, 31, 37, 42], la colocación de servicios [14, 43], el intercambio de datos y el almacenamiento en caché [18, 29, 32, 35, 46], monitoreo y control del sensor [20, 21], formación de árboles de multidifusión [8, 9, 33, 36, 38], y enrutamiento de nombres y solicitudes [10, 11]. Por lo tanto, especulamos que un SDIMS en un sistema en red proporcionaría una red troncal de sistemas operativos distribuidos y facilitaría el desarrollo y la implementación de nuevos servicios distribuidos. Para un sistema de información a gran escala, la agregación jerárquica es una abstracción fundamental para la escalabilidad. En lugar de exponer toda la información a todos los nodos, la agregación jerárquica permite que un nodo acceda a vistas detalladas de la información cercana y las vistas sumarias de la información global. En un SDIMS basado en la agregación jerárquica, los diferentes nodos pueden recibir diferentes respuestas a la consulta encontrar un nodo [cercano] con al menos 1 GB de memoria libre o encontrar una copia [cercana] del archivo foo. Un sistema jerárquico que agrega información a través de árboles de reducción [21, 38] permite que los nodos accedan a la información que les importa mientras mantiene la escalabilidad del sistema. Para ser utilizado como un bloque de construcción básico, un SDIMS debe tener cuatro propiedades. Primero, el sistema debe ser escalable: debe acomodar grandes cantidades de nodos participantes, y debe permitir que las aplicaciones instalen y monitoreen grandes números de atributos de datos. Los sistemas empresariales y de escala global hoy en día pueden tener decenas de miles o millones de nodos y estos números aumentarán con el tiempo. Del mismo modo, esperamos admitir muchas aplicaciones, y cada aplicación puede rastrear varios atributos (por ejemplo, la carga y la memoria libre de las máquinas de sistemas) o millones de atributos (por ejemplo, qué archivos se almacenan en qué máquinas). En segundo lugar, el sistema debe tener flexibilidad para acomodar una amplia gama de aplicaciones y atributos. Por ejemplo, los atributos de lectura como NUMCPU rara vez cambian en el valor, mientras que los atributos dominados por la escritura como los numrocesos cambian con bastante frecuencia. Un enfoque ajustado para los atributos dominados por lectura consumirá un alto ancho de banda cuando se aplique a los atributos dominados por la escritura. Por el contrario, un enfoque ajustado para los atributos dominados por la escritura sufrirá una latencia o imprecisión innecesaria de consultas para atributos dominados por lectura. Por lo tanto, un SDIMS debe proporcionar mecanismos para manejar diferentes tipos de atributos y dejar la decisión política de ajustar la replicación a las aplicaciones. Tercero, un SDIMS debe proporcionar aislamiento administrativo. En un sistema grande, es natural organizar nodos en una jerarquía organizacional o administrativa. Un SDIMS debe apoyar la Administración 10: Sistemas de información distribuidos 379 TIVE ASOLACIÓN EN EL QUE LAS CONSULTAS SOBRE UNA INFORMACIÓN DE DOMINOS ADMINISTRATIVOS PUEDEN SE SECUESTRA Dentro del dominio para que el sistema pueda operar durante las desconexiones de otros dominios, para que un observador externo no pueda monitorear o afectar Intra-Intra-Intraconsultas de dominio y para admitir consultas con escoltas de dominio de manera eficiente. Cuarto, el sistema debe ser robusto para las fallas y las desconexiones de los nodos. Un SDIMS debe adaptarse a las reconfiguraciones de manera oportuna y también debe proporcionar mecanismos para que las aplicaciones puedan intercambiar el costo de adaptación con el nivel de consistencia en los resultados agregados cuando ocurren reconfiguraciones. Nos inspiramos en dos trabajos anteriores: Astrolabe [38] y tablas de hash distribuidas (DHT). Astrolabe [38] es un sistema de gestión de información robusto. Astrolabe proporciona la abstracción de un solo árbol de agregación lógica que refleja una jerarquía administrativa de sistemas. Proporciona una interfaz general para instalar nuevas funciones de agregación y proporciona una consistencia eventual en sus datos. Astrolabe es robusto debido al uso de un protocolo de chismes no estructurado para difundir información y su estrategia de replicar todos los valores de atributos agregados para un subárbol en todos los nodos en el subárbol. Esta combinación permite que cualquier patrón de comunicación produzca una consistencia eventual y permite que cualquier nodo responda cualquier consulta utilizando información local. Sin embargo, este alto grado de replicación puede limitar la capacidad de los sistemas para acomodar grandes cantidades de atributos. Además, aunque el enfoque funciona bien para los atributos dominados por las lecturas, una actualización en un nodo eventualmente puede afectar el estado en todos los nodos, lo que puede limitar la flexibilidad de los sistemas para admitir atributos dominados por la escritura. Investigaciones recientes en redes estructuradas entre pares dieron como resultado una estructura de datos distribuidas (DHTS) [18, 28, 29, 32, 35, 46] -A estructura de datos que escala con el número de nodos y que distribuye la carga de lectura-escriturapara diferentes consultas entre los nodos participantes. Es interesante observar que, aunque estos sistemas exportan una abstracción global de la tabla de hash, muchos de ellos hacen uso internamente de lo que se puede ver como un sistema escalable de árboles de agregación para, por ejemplo, enrutar una solicitud de una clave dada para el DHT correctonodo. De hecho, en lugar de exportar una interfaz DHT general, Plaxton et al.s [28] la aplicación original utiliza la agregación jerárquica para permitir que los nodos ubiquen copias cercanas de objetos. Parece atractivo desarrollar una abstracción SDIMS que exponga esta funcionalidad interna de manera general para que los árboles escalables para la agregación puedan ser un bloque básico de construcción de sistemas junto con los DHT. A primera vista, puede parecer obvio que simplemente fusionar los DHT con abstracción de agregación de astrolabes dará como resultado un SDIMS. Sin embargo, cumplir con los requisitos de SDIMS obliga a un diseño a abordar cuatro preguntas: (1) ¿Cómo asignar diferentes atributos a diferentes árboles de agregación en una malla DHT?(2) ¿Cómo proporcionar flexibilidad en la agregación para acomodar diferentes requisitos de aplicación?(3) ¿Cómo adaptar una malla DHT global y plana para lograr una propiedad de aislamiento administrativo?y (4) ¿Cómo proporcionar robustez sin chismes no estructurados y replicación total? Las contribuciones clave de este documento que forman la base de nuestro diseño SDIMS son las siguientes.1. Definimos una nueva abstracción de agregación que especifica tanto el tipo de atributo como el nombre del atributo y que asocia una función de agregación con un tipo de atributo particular. Esta abstracción allana el camino para utilizar los árboles internos de los sistemas DHT para la agregación y para lograr la escalabilidad con nodos y atributos.2. Proporcionamos una API flexible que permite que las aplicaciones controlen la propagación de lecturas y escrituras y, por lo tanto, intercambiaran costos de actualización, latencia de lectura, replicación y estancamiento.3. Aumentamos un algoritmo DHT existente para garantizar las propiedades de convergencia de ruta y localidad de ruta para lograr el aislamiento administrativo.4. Proporcionamos robustez a las reconfiguraciones de nodos y redes al (a) proporcionar una replicación temporal a través de la reagregación perezosa que garantiza una consistencia eventual y (b) asegurando que nuestra API flexible permita que las aplicaciones exigentes obtengan robustez adicional utilizando la replicación espacial sintonizable de agregados de datos o al realizar rápidamente-Demand reagregación para aumentar la reagregación perezosa subyacente o haciendo ambas cosas. Hemos construido un prototipo de SDIMS. A través de simulaciones y experimentos micro-bencionos en varias máquinas de departamento y nodos de planetlab [27], observamos que el prototipo logra la escalabilidad con respecto a ambos nodos y atributos mediante el uso de su API flexible, inflige un orden de estrés de nodo máximo menor de magnitud más bajoque los esquemas de chismes no estructurados, logra propiedades de aislamiento a un costo de latencia de lectura modesta aumentada en comparación con los DHT planos y maneja con gracia fallas de nodos. Este estudio inicial analiza aspectos clave de un esfuerzo continuo de construcción de sistemas, pero no aborda todos los problemas en la construcción de un SDIMS. Por ejemplo, creemos que nuestras estrategias para proporcionar robustez se combinarán bien con técnicas como supernodos [22] y otros esfuerzos continuos para mejorar los DHT [30] para mejorar aún más la robustez. Además, aunque la agregación de división entre muchos árboles mejora la escalabilidad para consultas simples, este enfoque puede hacer que las consultas complejas y de múltiples atributos sean más caras en comparación con un solo árbol. Se necesita trabajo adicional para comprender la importancia de esta limitación para las cargas de trabajo reales y, si es necesario, para adaptar las técnicas de planificación de consultas de las abstracciones DHT [16, 19] a las abstracciones de árbol de agregación escalables. En la Sección 2, explicamos la abstracción de agregación jerárquica que SDIMS proporciona a las aplicaciones. En las Secciones 3 y 4, describimos el diseño de nuestro sistema para lograr la flexibilidad, la escalabilidad y los requisitos de aislamiento administrativo de un SDIMS. En la Sección 5, detallamos la implementación de nuestro sistema prototipo. La Sección 6 aborda el tema de la adaptación a las reconfiguraciones topológicas. En la Sección 7, presentamos la evaluación de nuestro sistema a través de simulaciones y microbistres a gran escala en redes reales. La Sección 8 detalla el trabajo relacionado, y la Sección 9 resume nuestra contribución.2. La agregación de abstracción de la agregación es una abstracción natural para un sistema de información distribuida a gran escala porque la agregación proporciona escalabilidad al permitir que un nodo vea información detallada sobre el estado cercano y resúmenes de grano progresivamente más grueso sobre subconjuntos progresivamente más grandes de datos de sistemas [38]. Nuestra abstracción de agregación se define a través de un árbol que abarca todos los nodos del sistema. Cada nodo físico en el sistema es una hoja y cada subárbol representa un grupo lógico de nodos. Tenga en cuenta que los grupos lógicos pueden corresponder a dominios administrativos (por ejemplo, departamento o universidad) o grupos de nodos dentro de un dominio (por ejemplo, 10 estaciones de trabajo en una LAN en el departamento de CS). Un nodo interno no hojas, que llamamos nodo virtual, está simulado por uno o más nodos físicos en las hojas del subárbol para el cual el nodo virtual es la raíz. Describimos cómo formar tales árboles en una sección posterior. Cada nodo físico tiene datos locales almacenados como un conjunto de tuplas (AttributeType, AttributeName, Value) tales como (Configuración, NumCPUS, 16), (MCAST Membresía, Session Foo, Yes) o (Archivo almacenado, Foo, Myipaddress). El sistema asocia una función de agregación FTYPE con cada tipo de atributo, y para cada subárbol de nivel I en el sistema, el sistema define un valor agregado VI, tipo, nombre para cada par (AT380 TributeteType, AttributeName) par de la siguiente manera. Para un nodo de hoja (físico) T0 en el nivel 0, V0, tipo, el nombre es el valor almacenado localmente para el tipo de atributo y el nombre o nulo si no existe una tupla coincidente. Luego, el valor agregado para un subárbol de nivel I es la función de agregación para el tipo, FTYPE calculado en los valores agregados de cada uno de los niños: VI, tipo, nombre = ftype (V0 i-1, tipo, nombre, nombre, V1i - 1, tipo, nombre, ..., vk - 1 i - 1, tipo, nombre). Aunque SDIMS permite funciones de agregación arbitraria, a menudo es deseable que estas funciones satisfagan la propiedad de cálculo jerárquico [21]: F (V1, ..., Vn) = F (F (V1, ..., VS1), F (VS1+1, ..., vs2), ..., f (vsk+1, ..., vn)), donde vi es el valor de un atributo en el nodo i. Por ejemplo, la operación promedio, definida como AVG (V1, ..., VN) = 1/N.∑N i = 0 VI, no satisface la propiedad. En cambio, si un atributo almacena valores como tuplas (suma, recuento), el atributo satisface la propiedad de cálculo jerárquico y al mismo tiempo permite que las aplicaciones calculen el promedio de los valores de suma y recuento agregados. Finalmente, tenga en cuenta que para un sistema a gran escala, es difícil o imposible insistir en que el valor de agregación devuelto por una sonda corresponde a la función calculada sobre los valores actuales en las hojas en el instante de la sonda. Por lo tanto, nuestro sistema proporciona solo garantías de consistencia débiles, específicamente consistencia eventual como se define en [38].3. Flexibilidad Una innovación importante de nuestro trabajo es permitir el cálculo y propagación agregados flexibles. La definición de la abstracción de agregación permite una flexibilidad considerable en cómo, cuándo y dónde se calculan y propagan los valores agregados. Mientras que los sistemas anteriores [15, 29, 38, 32, 35, 46] implementan una sola estrategia estática, argumentamos que un SDIMS debe proporcionar un cálculo y propagación flexibles para apoyar eficientemente una amplia variedad de aplicaciones con diversos requisitos. Para proporcionar esta flexibilidad, desarrollamos una interfaz simple que descompone la abstracción de la agregación en tres piezas de funcionalidad: instalar, actualizar y sondear. Esta definición de la abstracción de la agregación permite que nuestro sistema proporcione un espectro continuo de estrategias que van desde el cálculo y propagación agregados perezosos en lecturas hasta computación y propagación inmediatas agresivas en escrituras. En la Figura 1, ilustramos tanto estrategias extremas como una estrategia intermedia. Bajo la estrategia de cálculo y propagación locales de actualización perezosa, una actualización (o escritura) solo afecta el estado local. Luego, una sonda (o leída) que lee un valor agregado de nivel I se envía al árbol al antepasado de niveles de nivel I y luego baja el árbol a las hojas. Luego, el sistema calcula el valor agregado deseado en cada capa en el árbol hasta que el ancestro de nivel I que contenga el valor deseado. Finalmente, el antepasado de nivel I envía el resultado por el árbol al nodo emisor. En el otro caso extremo de la actualización agresiva, todo el cálculo y la propagación inmediatos en las escrituras [38], cuando se produce una actualización, los cambios se agregan en el árbol, y cada nuevo valor agregado se inunda a todos los descendientes de un nodos. En este caso, cada nodo de nivel I no solo mantiene los valores agregados para el subárbol de nivel I, sino que también recibe y almacena localmente copias de todos sus antepasados de nivel de nivel J (j> i). Además, una hoja satisface una sonda para un agregado de nivel I utilizando datos puramente locales. En una estrategia de actualización intermedia, la raíz de cada subárbol mantiene el valor agregado actual de los subárboles, y cuando ocurre una actualización, el nodo Leaf actualiza su estado local y pasa la actualización a su padre, y luego cada subárbol de encierra sucesivo actualiza su agregado.valor y pasa el nuevo valor a su padre. Esta estrategia satisface una sonda de hoja para un valor agregado de nivel I enviando la sonda al ancestro de nivel I de la hoja y luego enviando el valor agregado a la hoja. Finalmente, observe que existen otras estrategias. En general, una estrategia Update-Upk-Downj se agrega al parámetro Descripción Opcional Atrtype Atributo Tipo de agregación AgrfUnC Función ARRIBA A qué distancia se envía cada actualización (predeterminada: ALL) X Down hasta dónde se envía cada agregado (predeterminado: Ninguno) X)Restricción del dominio del dominio (predeterminado: Ninguno) x Exptime Expiry Time Tabla 1: Argumentos para la operación de instalación El nivel de KTH y propaga los valores agregados de un nodo en el nivel L (S.T. L ≤ K) hacia abajo para los niveles J. Un SDIMS debe proporcionar una amplia gama de estrategias flexibles de cálculo y propagación a las aplicaciones para que sea una abstracción general. Una aplicación debe poder elegir un mecanismo particular basado en su relación de lectura-escritura que reduzca el consumo de ancho de banda mientras alcanza la capacidad de respuesta y precisión requeridas. Tenga en cuenta que la relación de lectura-escritura de los atributos que las aplicaciones instalan varían ampliamente. Por ejemplo, un atributo dominado por lectura como NUMCPUS rara vez cambia en el valor, mientras que un atributo escrito por numerosos se cambia con bastante frecuencia. Una estrategia de agregación como Update-All Funciona bien para atributos dominados por las lecturas, pero sufre un alto consumo de ancho de banda cuando se aplica a los atributos dominados por la escritura. Por el contrario, un enfoque como UpdateLocal funciona bien para atributos dominados por la escritura, pero sufre latencia o imprecisión de consulta innecesaria para atributos dominados por lecturas. SDIMS también permite el cálculo y la propagación no uniformes en el árbol de agregación con diferentes parámetros hacia arriba y hacia abajo en diferentes subárboles para que las aplicaciones puedan adaptarse con la heterogeneidad espacial y temporal de las operaciones de lectura y escritura. Con respecto a la heterogeneidad espacial, los patrones de acceso pueden diferir para diferentes partes del árbol, lo que requiere diferentes estrategias de propagación para diferentes partes del árbol. De manera similar, con respecto a la heterogeneidad temporal, los patrones de acceso pueden cambiar con el tiempo que requieren diferentes estrategias con el tiempo.3.1 API de agregación Proporcionamos la flexibilidad descrita anteriormente dividiendo la API de agregación en tres funciones: install () instala una función de agregación que define una operación en un tipo de atributo y especifica la estrategia de actualización que la función usará, actualizando () inserta o modificaUn valor local de nodos para un atributo, y la sonda () obtiene un valor agregado para un subárbol especificado. La interfaz de instalación permite que las aplicaciones especifiquen los parámetros K y J de la estrategia Update-UPK-Downj junto con la función de agregación. La interfaz de actualización invoca la agregación de un atributo en el árbol de acuerdo con la estrategia de agregación de funciones de agregación correspondientes. La interfaz de la sonda no solo permite que las aplicaciones obtengan el valor agregado para un árbol especificado, sino que también permite que un nodo de sondeo obtenga continuamente los valores durante un tiempo especificado, lo que permite que una aplicación se adapte a la heterogeneidad espacial y temporal. El resto de la sección describe estas tres interfaces en detalle.3.1.1 Instalar la operación de instalación Instala una función de agregación en el sistema. Los argumentos para esta operación se enumeran en la Tabla 1. El argumento AttrType denota el tipo de atributos en los que se invoca esta función de agregación. Las funciones instaladas son un estado suave que debe renovarse periódicamente o serán recolectados de basura en Exptime. Los argumentos de arriba y hacia abajo especifican la estrategia de actualización del cálculo 381 agregado sobre la actualización en la sonda para el valor agregado global en la sonda para el nivel 1 valor agregado actualización de actualización-up actualización-todo Figura 1: parámetro de la API flexible descripción de atributo attrtype opcional atributo attrename atributoModo de nombre Continuo o One-Shot (Predeterminado: One-Shot) X Nivel de nivel en el que se busca el agregado (predeterminado: en todos los nivelLejos para ir y rehacer (predeterminado: Ninguno) x Exptime Exputy Time Tabla 2: Argumentos para la operación de la sonda y la actualización de la estrategia de propagación-upk-downj. El argumento del dominio, si está presente, indica que la función de agregación debe instalarse en todos los nodos en el dominio especificado;De lo contrario, la función se instala en todos los nodos del sistema.3.1.2 Actualizar la operación de actualización toma tres argumentos AttrType, AttrName y Value y crea un nuevo (attrType, attrname, valor) o actualiza el valor de una tupla antigua con attrype y attryame coincidente en un nodo hoja. La interfaz de actualización se combina con la estrategia de cálculo y propagación agregado instalado para proporcionar flexibilidad. En particular, como se describió anteriormente y se describe en detalle en la Sección 5, después de que una hoja aplica una actualización localmente, la actualización puede activar la computación de los valores agregados en el árbol y también puede desencadenar la propagación de los valores agregados modificados en el árbol. Observe que nuestra abstracción asocia una función de agregación con solo un attrtype, pero permite que las actualizaciones especifiquen un nombre ATTTR junto con el AttrType. Esta técnica ayuda a lograr la escalabilidad con respecto a los nodos y atributos como se describe en la Sección 4. 3.1.3 La sonda La operación de la sonda devuelve el valor de un atributo a una aplicación. El argumento completo establecido para la operación de la sonda se muestra en la Tabla 2. Junto con el AttrName y los argumentos AttrType, un argumento de nivel especifica el nivel en el que se requieren las respuestas para un atributo. En nuestra implementación, elegimos devolver los resultados en todos los niveles k <l para una sonda de nivel L porque (i) es económico ya que los nodos atravesados para la sonda nivel-L también contienen agregados de nivel K para k <l y como esperamos losEl costo de la red de transmitir la información adicional para que sea pequeño para los pequeños agregados que enfocamos y (ii) es útil ya que las aplicaciones pueden obtener de manera eficiente varios agregados con una sola sonda (por ejemplo, para consultas escopadas por dominio como se explica en la Sección 4.2). Las sondas con el modo establecido en continuo y con EXPTime finito permiten que las aplicaciones manejen la heterogeneidad espacial y temporal. Cuando el nodo A emite una sonda continua en el nivel L para un atributo, independientemente de los parámetros arriba y abajo, las actualizaciones para el atributo en cualquier subárbol de antepasados de nivel L AS se agregan hasta el nivel L y el valor agregado se propaga hacia abajo.a lo largo del camino desde el antepasado hasta A. Tenga en cuenta que el modo continuo permite a SDIMS admitir un mecanismo distribuido de sensor-activador en el que un sensor monitorea un agregado de nivel I con una sonda de modo continuo y activa un actuador al recibir nuevos valores para la sonda. Los argumentos hacia arriba y hacia abajo permiten que las aplicaciones realicen una agregación rápida en el demand durante las reconfiguraciones, donde se realiza una re-agregación forzada para los niveles correspondientes, incluso si el valor agregado está disponible, como discutimos en la Sección 6. Cuando está presente, los argumentos hacia arriba y hacia abajo se interpretan como se describe en la operación de instalación.3.1.4 Adaptación dinámica a nivel API, los argumentos hacia arriba y hacia abajo en la API de instalación pueden considerarse como sugerencias, ya que sugieren una estrategia de cálculo pero no afectan la semántica de una función de agregación. Una implementación de SDIMS puede ajustar dinámicamente sus estrategias hacia arriba/hacia abajo para un atributo basado en su frecuencia de lectura/escritura medida. Pero un nodo intermedio virtual necesita conocer los valores de propagación actuales hacia arriba y hacia abajo para decidir si el agregado local es fresco para responder una sonda. Esta es la razón clave por la cual arriba y abajo deben definirse estáticamente en el momento de la instalación y no se puede especificar en la operación de actualización. En la adaptación dinámica, implementamos un mecanismo basado en arrendamiento donde un nodo emite un arrendamiento a un padre o un hijo que denota que seguirá propagando las actualizaciones a ese padre o hijo. Actualmente estamos evaluando diferentes políticas para decidir cuándo emitir un contrato de arrendamiento y cuándo revocar un contrato de arrendamiento.4. Escalabilidad Nuestro diseño logra escalabilidad con respecto a ambos nodos y atributos a través de dos ideas clave. Primero, define cuidadosamente la abstracción de la agregación para combinar bien con su sistema DHT escalable subyacente. En segundo lugar, refina la abstracción DHT básica para formar un DHT autónomo (ADHT) para lograr las propiedades de aislamiento administrativo que son cruciales para la escala para grandes sistemas del mundo real. En esta sección, describimos estas dos ideas en detalle.4.1 Aprovechando los DHT en contraste con los sistemas anteriores [4, 15, 38, 39, 45], la abstracción de agregación de SDIMSS especifica tanto un tipo de atributo como un nombre de atributo y asocia una función de agregación con un tipo en lugar de especificar y asociar una función con un nombre. La instalación de una sola función que puede operar en muchos atributos con nombre diferentes que coinciden con un tipo de escalabilidad para tipos de atributos dispersos con espacios de nombre grandes y fallecidos. Por ejemplo, para construir un servicio de ubicación de archivo, nuestra interfaz nos permite instalar una función única que calcule un valor agregado para cualquier archivo con nombre. Un valor agregado de subárboles para (fileloc, nombre) sería la ID de un nodo en el subárbol que almacena el archivo nombrado. Por el contrario, Astrolabe se enfrenta a atributos dispersos al hacer que las funciones de agregación calculen conjuntos o listas y sugiere que la escalabilidad puede mejorarse representando tales conjuntos con filtros Bloom [6]. El apoyo de nombres escasos dentro de un tipo proporciona al menos dos ventajas. Primero, cuando se actualiza el valor asociado con un nombre, solo el estado Asoci382 001 010100 000 011 101 111 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figura 2: El árbol DHT correspondiente a la clave 111 (dhttree111) y la correspondienteÁrbol de agregación.Ated con ese nombre debe actualizarse y propagarse a otros nodos. En segundo lugar, la división de valores asociados con diferentes nombres en diferentes valores de agregación permite a nuestro sistema aprovechar las tablas de hash distribuidas (DHT) para asignar diferentes nombres a diferentes árboles y, por lo tanto, difundir las funciones que los nodos de raíz lógicos se cargan y dicen en múltiples nodos físicos. Dada esta abstracción, los atributos de mapeo escalablemente a los DHT son sencillos. Los sistemas DHT asignan una identificación larga y aleatoria a cada nodo y definen un algoritmo para enrutar una solicitud de Key K a un nodo rootk de tal manera que la unión de rutas de todos los nodos forma un árbol dhttreek enraizado en el nodo rootk. Ahora, como se ilustra en la Figura 2, al agregar un atributo a lo largo del árbol de agregación correspondiente a Dhttreek para k = hash (tipo de atributo, nombre del atributo), se agregarán diferentes atributos a lo largo de diferentes árboles. En comparación con un esquema donde todos los atributos se agregan a lo largo de un solo árbol, la agregación a lo largo de múltiples árboles incurre en el estrés del nodo máximo más bajo: mientras que en un solo enfoque de árbol de agregación, la raíz y los nodos intermedios pasan más mensajes que los nodos de la hoja, en un DHT-La de árboles basados en el árbol, cada nodo actúa como un punto de agregación intermedio para algunos atributos y como un nodo de hoja para otros atributos. Por lo tanto, este enfoque distribuye la responsabilidad de la agregación en todos los nodos.4.2 Los árboles de agregación administrativa de aislamiento deben proporcionar un aislamiento administrativo asegurando que para cada dominio, el nodo virtual en la raíz del subárbol de agregación más pequeño que contiene todos los nodos de ese dominio es alojado por un nodo en ese dominio. El aislamiento administrativo es importante por tres razones: (i) por seguridad, de modo que las actualizaciones y las sondas que fluyen en un dominio no sean accesibles fuera del dominio, (ii) para la disponibilidad, de modo que las consultas para los valores en un dominio no se ven afectadas por fallas de fallas deNodos en otros dominios, y (iii) para la eficiencia, de modo que las consultas escopadas por dominio pueden ser simples y eficientes. Para proporcionar aislamiento administrativo a los árboles de agregación, un DHT debe satisfacer dos propiedades: 1. Localidad de ruta: las rutas de búsqueda siempre deben estar contenidas en el dominio más pequeño posible.2. Convergencia de ruta: las rutas de búsqueda para una clave de diferentes nodos en un dominio deberían converger en un nodo en ese dominio. La localidad de la ruta de soporte de DHTS existente [18] o puede soportarlo fácilmente utilizando la cercanía del dominio como la métrica de distancia [7, 17], pero no garantizan la convergencia de la ruta ya que esos sistemas intentan optimizar la ruta de búsqueda a la raíz para reducir la respuestalatencia. Por ejemplo, Pastry [32] utiliza un enrutamiento de prefijo en el que cada tabla de enrutamiento de cada nodo contiene una fila por dígito hexadecimal en el espacio de nodoid donde la fila de ésimo contiene una lista de nodos cuyos nodoides difieren de los nodos actuales en el dígito ésimo con una entrada con una entrada con unapara cada posible valor de dígitos. Dada una topología de enrutamiento, para enrutar un paquete a una clave de destino arbitraria, un nodo en pastel reenvía un paquete al nodo con un prefijo de nodoid que coincide con la clave en al menos un dígito más que el nodo actual. Si no se conoce dicho nodo, el nodo actual utiliza una estructura de datos adicional, el conjunto de hoja que contiene 110xx 010xx 011xx 100xx 101xx UNIV DEP1 DEP2 CLAVE = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figura 3: Ejemplo muestra cómo la propiedad de la isolación está violada Violación decon pastel original. También mostramos el árbol de agregación correspondiente.110XX 010XX 011XX 100XX 101XX UNIV DEP1 DEP2 CLAVE = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figura 4: DHT autónomo que satisface la propiedad de aislamiento. También se muestra el árbol de agregación correspondiente. L Vecinos más altos e inferiores inmediatos en el espacio de nodoid, y reenvía el paquete a un nodo con un prefijo idéntico, pero eso está numéricamente más cerca de la clave de destino en el espacio de nodoid. Este proceso continúa hasta que aparece el nodo de destino en el conjunto de hoja, después de lo cual el mensaje se enruta directamente. Pastrys El número esperado de pasos de enrutamiento es logn, donde n es el número de nodos, pero como lo ilustra la Figura 3, este algoritmo no garantiza la convergencia de la ruta: si dos nodos en un dominio tienen nodos que coinciden con una clave en el mismo número de bits,Ambos pueden enrutar a un tercer nodo fuera del dominio al enrutar esa clave. Las modificaciones simples a los protocolos de construcción de la tabla de ruta de Pastrys y los protocolos de ruta clave producen un DHT autónomo (ADHT) que satisface las propiedades de la localidad de ruta y la convergencia de ruta. Como ilustra la Figura 4, cada vez que dos nodos en un dominio comparten el mismo prefijo con respecto a una clave y ningún otro nodo en el dominio tiene un prefijo más largo, nuestro algoritmo presenta un nodo virtual en el límite del dominio correspondiente a ese prefijo más elsiguiente dígito de la llave;Tal nodo virtual está simulado por el nodo existente cuya ID es numéricamente más cercana al ID de nodos virtuales. Nuestra tabla de enrutamiento ADHTS difiere de Pastrys de dos maneras. Primero, cada nodo mantiene un conjunto de hoja separado para cada dominio del cual es una parte. En segundo lugar, los nodos usan dos métricas de proximidad al poblar las tablas de enrutamiento: la proximidad del dominio jerárquico es la métrica principal y la distancia de red es secundaria. Luego, para enrutar un paquete a una raíz global para una clave, el algoritmo de enrutamiento de ADHT utiliza la tabla de enrutamiento y las entradas de ajuste de hoja a la ruta a cada raíz de dominios de encerrado sucesivo (el nodo virtual o real en el dominio que coincide con la clave en el número máximode dígitos). Detalles adicionales sobre el algoritmo ADHT están disponibles en un informe técnico extendido [44]. Mantener un conjunto de hoja diferente para cada nivel de jerarquía administrativa aumenta el número de vecinos que cada nodo rastrea a (2b) ∗ Lgb n+C.L de (2b) ∗ Lgb n+C en pasteles no modificados, donde B es el número de bits en A aDigit, N es el número de nodos, C es el tamaño del conjunto de hoja y L es el número de niveles de dominio. El enrutamiento requiere pasos O (LGBN + L) en comparación con los pasos O (LGBN) en la masa;Además, cada salto de enrutamiento puede ser más largo que en la masa porque la tabla de enrutamiento de algoritmos modificados prefiere los nodos de dominio del mismo dominio sobre los nodos cercanos. Cuantificamos experimentalmente los costos de enrutamiento adicionales en la Sección 7. En un sistema grande, la topología de ADHT permite que los dominios IM383 A1 A2 B1 ((B1.B., 1), (B., 1), (., 1)) ((B1.B., 1), (B., 1), (., 1)) L2 L1 L0 ((B1.B., 1), (B., 1), (., 3)) ((A1.A., 1), (A., 2), (., 2)) ((A1.A., 1), (A., 1), (., 1)) ((A2.A., 1), (A., 1),(., 1)) Figura 5: Ejemplo de consultas con escolción de dominio demuestra seguridad para los tipos de atributos confidenciales al instalarlos solo dentro de un dominio especificado. Luego, la agregación ocurre completamente dentro del dominio y un nodo externo al dominio no puede observar ni afectar las actualizaciones y los cálculos de agregación del tipo de atributo. Además, aunque no hemos implementado esta característica en el prototipo, la topología ADHT también admitiría sondas de dominio de dominio que podrían garantizar que nadie fuera de un dominio pueda observar una sonda para los datos almacenados dentro del dominio. La topología ADHT también mejora la disponibilidad al permitir que el caso común de las sondas para los datos dentro de un dominio dependa solo de los nodos de dominios. Esto, por ejemplo, permite que un dominio que se desconecte del resto de Internet continúe respondiendo consultas para los datos locales. Los árboles de agregación que proporcionan aislamiento administrativo también permiten la definición de funciones de agregación de dominio simples y eficientes para respaldar consultas como ¿cuál es la carga promedio en las máquinas en el dominio x? Por ejemplo, considere una función de agregación para contar el número de máquinas en un sistema de ejemplo con tres máquinas ilustradas en la Figura 5. Cada nodo de hoja L actualiza el atributo numachines con un valor VL que contiene un conjunto de tuplas de forma (dominio, recuento) para cada dominio del cual el nodo es parte. En el ejemplo, el nodo A1 con el nombre A1.A.Realiza una actualización con el valor ((A1.A., 1), (A., 1), (., 1)). Una función de agregación en un nodo virtual interno alojado en el nodo n con el conjunto de hijos C calcula el agregado como un conjunto de tuplas: para cada dominio d de que n forma parte, formar una tupla (d, ∑c∈C (count | (D, contar) ∈ Vc)). Este cálculo se ilustra en la Figura 5. Ahora una consulta para numachinas con nivel establecido en max devolverá los valores agregados en cada nodo virtual intermedio en la ruta hacia la raíz como un conjunto de tuplas (nivel de árbol, valor agregado) del que es fácil extraer el recuento de máquinas encada dominio de adjunto. Por ejemplo, A1 recibiría ((2, ((B1.B., 1), (B., 1), (., 3))), (1, ((A1.A., 1), (A., 2), (., 2))), (0, ((A1.A., 1), (A., 1), (., 1)))). Tenga en cuenta que las consultas de soporte de dominio serían menos convenientes y menos eficientes si los árboles de agregación no se ajustaran a la estructura administrativa de los sistemas. Sería menos eficiente porque cada nodo virtual intermedio tendrá que mantener una lista de todos los valores en las hojas en su subárbol junto con sus nombres y serían menos convenientes como aplicaciones que necesitan un agregado para un dominio tendrán que elegir valores deNodos en ese dominio de la lista devuelto por una sonda y realizar el cálculo.5. Implementación del prototipo El diseño interno de nuestro prototipo SDIMS comprende dos capas: la capa Autónoma DHT (ADHT) gestiona la topología de superposición del sistema y la capa de gestión de agregación (AML) mantiene las tuplas de atributos, realiza agregaciones, tiendas y propagenta los valores de agregado. Dada la construcción de ADHT descrita en la Sección 4.2, cada nodo implementa una capa de gestión de agregación (AML) para admitir la API flexible descrita en la Sección 3. En esta sección, describimos el estado interno y la operación de la capa AML de un nodo en el sistema.MIB MIB MIB LOCAL Reducción del antepasado MIB (Nivel 1) Ancestro MIBS MIB de niño 0x ... MIB del niño 0x ... Nivel 2 Nivel 1 Nivel 3 Nivel 0 1xxx ... 10xx ... 100x ... De los padres0x ..Al padre 0x ... −− Funciones de agregación de los padres al padre 10xx ... 1x .. 1x .. 1x .. al padre 11xx ... ID de nodo: (1001xxx) 1001x .. 100x .. 10x .. 1x.. Nodo virtual Figura 6: Ejemplo que ilustra las estructuras de datos y la organización de ellas en un nodo. Nos referimos a un almacén de (tipo de atributo, nombre de atributo, valor) tuples como una base de información de gestión o MIB, siguiendo la terminología de Astrolabe [38] y SNMP [34]. Referimos una tupla (tipo de atributo, nombre de atributo) como una clave de atributo. Como ilustra la Figura 6, cada nodo físico en el sistema actúa como varios nodos virtuales en la AML: un nodo actúa como hoja para todas las teclas de atributo, como un subárbol de nivel 1 para las teclas cuyo hash coincide con la identificación de nodos en bits de prefijo B ((donde B es el número de bits corregidos en cada paso del esquema de enrutamiento de ADHTS), como un subárbol de nivel I Roots para las teclas de atributo cuyo hash coincide con los nodos ID en los bits I ∗ B iniciales, y como los sistemas global para atribuir el atributoLas claves cuyo hash coincide con la identificación de nodos en más bits de prefijo que cualquier otro nodo (en caso de un empate, se ignora el primer bit no coincidente y la comparación continúa [46]). Para apoyar la agregación jerárquica, cada nodo virtual en la raíz de un subárbol de nivel I mantiene varios MIB que almacenan (1) MIB infantiles que contienen valores agregados sin procesar recopilados de los niños, (2) un MIB de reducción que contiene valores agregados localmente en esta información sin procesar,y (3) un antepasado MIB que contiene valores agregados dispersos de los antepasados. Esta estrategia básica de mantener el niño, la reducción y el antepasado MIBS se basa en astrolabio [38], pero nuestra estrategia de propagación estructurada canaliza información que fluye de acuerdo con su clave de atributo y nuestra estrategia de propagación flexible solo envía actualizaciones de niños y los resultados agregados de antepasadosEn cuanto a la función de agregación de teclas de atributo. Tenga en cuenta que en la discusión a continuación, para facilitar la explicación, suponemos que el protocolo de enrutamiento está corrigiendo un solo bit a la vez (b = 1). Nuestro sistema, construido sobre pasteles, maneja la corrección de múltiples bits (b = 4) y es una extensión simple del esquema descrito aquí. Para un nodo virtual determinado Ni en el nivel I, cada MIB de niño contiene el subconjunto de un MIB de reducción de Childs que contiene tuplas que coinciden con la ID del nodo NIS en I bits y cuyo atributo de función de agregación UP es al menos i. Estas copias locales facilitan que un nodo recomputara un valor agregado de nivel I cuando la entrada de un niño cambia. Los nodos mantienen a sus MIB de hijos en almacenamiento estable y usan una versión simplificada del Protocolo de intercambio de registros de Bayou (detección y resolución de conflictos SANS) para la sincronización después de las desconexiones [26]. Virtual Node Ni en el nivel I mantiene un MIB de reducción de tuplas con una tupla para cada clave presente en cualquier MIB infantil que contenga el tipo de atributo, el nombre del atributo y la salida de las funciones agregadas de los tipos de atributos aplicados a las tuplas de los niños. Un nodo virtual Ni en el Nivel I también mantiene un Ancestor MIB para almacenar las tuplas que contienen la clave de atributos y una lista de valores agregados en diferentes niveles dispersos de los antepasados. Tenga en cuenta que la lista 384 para una clave puede contener múltiples valores agregados para un mismo nivel pero agregado en diferentes nodos (ver Figura 4). Por lo tanto, los valores agregados se etiquetan no solo con información de nivel, sino que también están etiquetados con ID del nodo que realizó la agregación. El nivel-0 difiere ligeramente de otros niveles. Cada nodo de hoja de nivel 0 mantiene un MIB local en lugar de mantener MIB infantiles y una MIB de reducción. Este MIB local almacena información sobre el estado de nodos locales insertado por aplicaciones locales a través de llamadas Update (). Imaginamos varios programas de sensores y aplicaciones insertar datos en MIB local. Por ejemplo, un programa puede monitorear la configuración local y realizar actualizaciones con información como la memoria total, la memoria libre, etc., un sistema de archivos distribuido puede realizar la actualización de cada archivo almacenado en el nodo local. Junto con estos MIB, un nodo virtual mantiene otras dos tablas: una tabla de funciones de agregación y una tabla de sondas sobresaliente. Una tabla de funciones de agregación contiene la función de agregación y los argumentos de instalación (ver Tabla 1) asociado con un tipo de atributo o un tipo de atributo y nombre. Cada función agregada se instala en todos los nodos en un subárbol de dominios, por lo que la tabla de funciones agregadas puede considerarse como un caso especial del antepasado MIB con funciones de dominio siempre instaladas en una raíz dentro de un dominio especificado y hasta todos los nodos dentro de los nodos dentro de los nodos dentro de los nodos dentro de los nodos dentro de los nodos dentro dedominio. La tabla de sondas pendiente mantiene información temporal sobre sondas en progreso. Dadas estas estructuras de datos, es simple admitir las tres funciones API descritas en la Sección 3.1. Instale la operación de instalación (consulte la Tabla 1) Instala en un dominio una función de agregación que actúa en un tipo de atributo especificado. Ejecución de una operación de instalación para la función Agrfunc en el tipo de atributo Atrtype se realiza en dos fases: Primero, la solicitud de instalación se transmite el árbol ADHT con la tecla de atributo (AttrType, NULL) hasta que alcanza la raíz de esa tecla dentro del dominio especificado. Luego, la solicitud se inunda por el árbol y se instala en todos los nodos intermedios y de hoja. Actualización Cuando un nodo virtual de nivel I recibe una actualización para un atributo de un niño a continuación: primero recomputa el valor agregado de nivel I para la clave especificada, almacena que valore en su reducción de MIB y luego, sujeto a las funciones y los parámetros de dominio, pasa el valor actualizado al padre apropiado en función de la clave de atributo. Además, el nodo virtual de nivel I (i ≥ 1) envía el agregado de nivel I actualizado a todos sus hijos si el parámetro de baja funciones excede cero. Al recibir un agregado de nivel I de un padre, un nodo virtual de nivel K almacena el valor en su antepasado MIB y, si K ≥ I-down, reenvía este agregado a sus hijos. La sonda una sonda recopila y devuelve el valor agregado para una clave de atributo especificada para un nivel especificado del árbol. Como ilustra la Figura 1, el sistema satisface una sonda para un valor agregado de nivel I utilizando un protocolo de cuatro fases que puede ser cortado en cortocircuito cuando las actualizaciones han propagado previamente resultados o resultados parciales hacia arriba o hacia abajo del árbol. En la fase 1, la fase de la sonda de ruta, el sistema enruta la sonda del árbol de claves de atributo a la raíz del subárbol de nivel I o a un nodo que almacena el valor solicitado en su Ancestro MIB. En el primer caso, el sistema procede a la fase 2 y en el segundo se salta a la fase 4. En la fase 2, la fase de dispersión de la sonda, cada nodo que recibe una solicitud de sonda lo envía a todos sus hijos a menos que la reducción de los nodos MIB ya tenga un valor que coincida con la clave de atributo de sondas, en cuyo caso el nodo inicia la fase 3 en nombre desu subárbol. En la fase 3, la fase de agregación de la sonda, cuando un nodo recibe valores para la clave especificada de cada uno de sus hijos, ejecuta la función agregada en estos valores y (a) reenvía el resultado a su padre (si su nivel es menor quei) o (b) inicia la fase 4 (si está en el nivel I). Finalmente, en la fase 4, la fase de enrutamiento agregado El valor agregado se enruta al nodo que lo solicitó. Tenga en cuenta que en el caso extremo de una función instalada con up = down = 0, una sonda de nivel I puede tocar todos los nodos en un subárbol de nivel I, mientras que en el caso extremo opuesto de una función instalada con up = down = todos, sonda, sondaes una operación completamente local en una hoja. Para las sondas que incluyen fases 2 (dispersión de la sonda) y 3 (agregación de la sonda), un problema es cómo decidir cuándo un nodo debe dejar de esperar a que sus hijos respondan y envíen su valor agregado actual. Un nodo deja de esperar a sus hijos cuando ocurren una de las tres condiciones: (1) Todos los niños han respondido, (2) la capa de ADHT señala uno o más eventos de reconfiguración que marcan a todos los niños que aún no han respondido como inalcanzables, o (3)Un temporizador Watchdog para la solicitud dispara. El último caso explica los nodos que participan en el protocolo ADHT pero que fallan en el nivel de AML. En un nodo virtual, las sondas continuas se manejan de manera similar como sondas de un solo disparo, excepto que tales sondas se almacenan en la tabla de sondas pendiente durante un período de tiempo de Exptime especificado en la sonda. Por lo tanto, cada actualización para un atributo desencadena la reevaluación de las sondas continuas para ese atributo. Implementamos un mecanismo basado en arrendamiento para la adaptación dinámica. Un nodo virtual de nivel L para un atributo puede emitir el arrendamiento para el agregado de Levell a un padre o un hijo solo si arriba es mayor que L o tiene arrendamientos de todos sus hijos. Un nodo virtual en el nivel L puede emitir el arrendamiento para el agregado de nivel K para K> L a un niño solo si es descendente ≥ k −l o si tiene el arrendamiento para ese agregado de su padre. Ahora, una sonda para el agregado de nivel K se puede responder mediante el nodo virtual Level-L si tiene un arrendamiento válido, independientemente de los valores hacia arriba y hacia abajo. Actualmente estamos diseñando diferentes políticas para decidir cuándo emitir un contrato de arrendamiento y cuándo revocar un contrato de arrendamiento y también las evaluamos con el mecanismo anterior. Nuestro prototipo actual no implementa el control de acceso en las operaciones de instalación, actualización y sonda, pero planeamos implementar restricciones basadas en certificados de astrolabes [38]. Además, nuestro prototipo actual no restringe el consumo de recursos en la ejecución de las funciones de agregación;Pero, las técnicas de la investigación sobre la gestión de recursos en sistemas de servidores y sistemas operativos [2, 3] se pueden aplicar aquí.6. La robustez en los sistemas a gran escala, las reconfiguraciones son comunes. Nuestros dos principios principales para la robustez son garantizar (i) leer la disponibilidad: las sondas completadas en tiempo finito, y (ii) consistencia eventual: las actualizaciones de un nodo en vivo serán visibles para las sondas por nodos conectados en tiempo finito. Durante las reconfiguraciones, una sonda podría devolver un valor obsoleto por dos razones. Primero, las reconfiguraciones conducen a la incorrección en los valores agregados anteriores. En segundo lugar, los nodos necesarios para la agregación para responder a la sonda se vuelven inalcanzables. Nuestro sistema también proporciona dos ganchos que las aplicaciones pueden usar para mejorar la robustez de extremo a extremo en presencia de reconfiguraciones: (1) re-agregación en el demand y (2) replicación controlada por la aplicación. Nuestro sistema maneja las reconfiguraciones en dos niveles: adaptación en la capa ADHT para garantizar la conectividad y la adaptación en la capa de AML para garantizar el acceso a los datos en SDIMS.6.1 Adaptación ADHT Nuestro algoritmo de adaptación de la capa ADHT es el mismo que el algoritmo de adaptación de Pastrys [32]: los conjuntos de hoja se reparan tan pronto como se detecta una reconfiguración y la tabla de enrutamiento se repara perezosamente. Tenga en cuenta que mantener conjuntos de hoja adicionales no degrada la propiedad de tolerancia a fallas de la masa original;De hecho, mejora la resiliencia de los ADHT a las fallas al proporcionar enlaces de enrutamiento adicionales. Debido a la redundancia en los conjuntos de hoja y la tabla de enrutamiento, las actualizaciones se pueden enrutar hacia sus nodos raíz con éxito incluso durante las fallas.385 RECONFIG AVISOS DE RECONFIG DHT parcial dht completo dht termina datos de tiempo de lazada 3 7 81 2 4 5 6 directs Datos de los perrosas inicios de datos de los perroseares inicios de datos perezososLa propiedad de aislamiento satisfecha por nuestro algoritmo ADHT asegura que las reconfiguraciones en un dominio de nivel I no afecten las sondas para el nivel I en un dominio de hermanos.6.2 Adaptación de AML En general, utilizamos dos tipos de estrategias para la adaptación de AML frente a las reconfiguraciones: (1) replicación en el tiempo como una estrategia de referencia fundamental y (2) replicación en el espacio como una optimización adicional del rendimiento que recurre a la replicación entiempo cuando el sistema se queda sin réplicas. Proporcionamos dos mecanismos para la replicación a tiempo. Primero, la reagregación perezosa se propaga ya recibió actualizaciones a niños nuevos o nuevos padres de manera perezosa con el tiempo. En segundo lugar, las aplicaciones pueden reducir la probabilidad de estallidad de la respuesta de la sonda durante tales reparaciones a través de nuestra API flexible con la configuración adecuada del parámetro hacia abajo. Reengregación perezosa: la capa DHT informa la capa de AML sobre las reconfiguraciones en la red utilizando las siguientes tres llamadas de función: NewParent, Fournchild y NewChild. En NewParent (Padre, Prefijo), se reevalúan todas las sondas en la tabla de probos pendientes correspondientes al prefijo. Si el padre no es nulo, entonces las funciones de agregación y los datos ya existentes se transfieren perezosamente en segundo plano. Cualquier nueva actualización, instalaciones y sondas para este prefijo se envían al padre de inmediato. En FallyChild (niño, prefijo), la capa de AML marca al niño como inactivo y cualquier sonda pendiente que esté esperando datos de este niño se vuelvan a evaluar. En Newchild (Child, Prefix), la capa AML crea espacio en sus estructuras de datos para este niño. La Figura 7 muestra la línea de tiempo para la reagregación perezosa predeterminada tras la reconfiguración. Las sondas iniciadas entre los puntos 1 y 2 y que se ven afectadas por las reconfiguraciones son reevaluadas por AML al detectar la reconfiguración. Las sondas que completan o comienzan entre los puntos 2 y 8 pueden devolver respuestas rancias. Reengregación a pedido: el esquema de agregación perezosa predeterminada propaga perezosamente las antiguas actualizaciones en el sistema. Además, utilizando las perillas arriba y abajo en la API de la sonda, las aplicaciones pueden forzar la agregación rápida a pedido de las actualizaciones para evitar la incomodidad frente a las reconfiguraciones. En particular, si una aplicación detecta o sospecha una respuesta como obsoleta, entonces puede volver a emitir la sonda aumentando los parámetros hacia arriba y hacia abajo para forzar la refrescante de los datos en caché. Tenga en cuenta que esta estrategia será útil solo después de que se complete la adaptación DHT (punto 6 en la línea de tiempo en la Figura 7). Replicación en el espacio: la replicación en el espacio es más desafiante en nuestro sistema que en una aplicación de ubicación de archivo DHT porque la replicación en el espacio se puede lograr fácilmente en este último replicando el contenido de los nodos raíz. En nuestro sistema, sin embargo, todos los nodos internos deben replicarse junto con la raíz. En nuestro sistema, las aplicaciones controlan la replicación en el espacio que usa perillas arriba y abajo en la API de instalación;Con valores grandes hacia arriba y hacia abajo, los agregados en los nodos virtuales intermedios se propagan a más nodos en el sistema. Al reducir el número de nodos a los que se debe acceder para responder una sonda, las aplicaciones pueden reducir la probabilidad de que ocurran resultados incorrectos debido a la falla de los nodos que no contribuyen al agregado. Por ejemplo, en una aplicación de ubicación de archivo, el uso de un parámetro positivo no positivo de cero asegura que un agregado global de archivos se replique en nodos distintos de la raíz.0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 AVG. NumberOfMessagePerperation Leer a la relación de escritura Actualización: All Up = All, Down = 9 Up = All, Down = 6 Actualización de actualización Local up = 2, Down = 0 Up = =5, hacia abajo = 0 Figura 8: Flexibilidad de nuestro enfoque. Con diferentes valores hacia arriba y hacia abajo en una red de nodos 4096 para diferentes relaciones de lectura. Las sondas para la ubicación del archivo se pueden responder sin acceder a la raíz;Por lo tanto, no se ven afectados por la falla de la raíz. Sin embargo, tenga en cuenta que esta técnica no es apropiada en algunos casos. Un valor agregado en el sistema de ubicación del archivo es válido siempre que el nodo que aloja el archivo esté activo, independientemente del estado de otros nodos en el sistema;Mientras que una aplicación que cuenta el número de máquinas en un sistema puede recibir resultados incorrectos, independientemente de la replicación. Si las reconfiguraciones son solo transitorias (como un nodo temporalmente que no responde debido a una explosión de carga), el agregado replicado se parece estrechamente al estado actual.7. Evaluación Hemos implementado un prototipo de SDIMS en Java utilizando el marco Freepastry [32] y realizamos experimentos de simulación a gran escala y experimentos de micro-benchmark en dos redes reales: 187 máquinas en el departamento y 69 máquinas en el Testbed de PlanetLab [27]. En todos los experimentos, utilizamos valores estáticos hacia arriba y hacia abajo y apagamos la adaptación dinámica. Nuestra evaluación respalda cuatro conclusiones principales. Primero, la API flexible proporciona diferentes estrategias de propagación que minimizan los recursos de comunicación en diferentes relaciones de lectura a escritura. Por ejemplo, en nuestra simulación observamos actualizar el local para ser eficientes para las relaciones de lectura a escritura por debajo de 0.0001, actualizar alrededor de 1 y actualizar todo por encima de 50000. En segundo lugar, nuestro sistema es escalable con respecto a los nodos y los atributos. En particular, encontramos que el estrés del nodo máximo en nuestro sistema es un orden más bajo que el observado con un enfoque de chismes de actualización. Tercero, en contraste con la pastelería no modificada que viola la propiedad de convergencia de ruta en hasta el 14% de los casos, nuestro sistema se ajusta a la propiedad. Cuarto, el sistema es robusto para las reconfiguraciones y se adapta a las fallas con en unos pocos segundos.7.1 Experimentos de simulación Flexibilidad y escalabilidad: una innovación importante de nuestro sistema es su capacidad para proporcionar un cálculo flexible y la propagación de los agregados. En la Figura 8, demostramos la flexibilidad expuesta por la API de agregación explicada en la Sección 3. Simulamos un sistema con 4096 nodos dispuestos en una jerarquía de dominio con factor de ramificación (BF) de 16 e instalamos varios atributos con diferentes parámetros hacia arriba y hacia abajo. Trazamos el número promedio de mensajes por operación incurridos para una amplia gama de relaciones de lectura a escritura de las operaciones para diferentes atributos. Las simulaciones con otros tamaños de redes con diferentes factores de ramificación revelan resultados similares. Este gráfico demuestra claramente el beneficio de apoyar una amplia gama de estrategias de cálculo y propagación. Aunque tiene un pequeño UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MAXIMUMNDESTRESS Número de atributos instalados Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figura 9: Estrés de nodo máximo para un tensión de gossiping de gossipingEnfoque versus enfoque basado en ADHT para diferentes números de nodos con un número creciente de atributos dispersos.El valor es eficiente para los atributos con bajas relaciones de lectura-escritura (redacción de aplicaciones dominadas), la latencia de la sonda, cuando se producen lecturas, puede ser alta ya que la sonda necesita agregar los datos de todos los nodos que no enviaron su agregado. Por el contrario, las aplicaciones que desean mejorar los gastos o latencias de la sonda pueden aumentar su propagación ascendente a un costo potencial de aumento en los gastos generales de escritura. En comparación con un enfoque de árbol de agregación única existente [38], la escalabilidad en SDIMS proviene de (1) aprovechar los DHT para formar múltiples árboles de agregación que dividen la carga en los nodos y (2) propagación flexible que evita la propagación de todas las actualizaciones a todosnodos. La Figura 9 demuestra la escalabilidad SDIMSS con nodos y atributos. Para este experimento, construimos un simulador para simular tanto astrolabio [38] (un enfoque de chismes, actualizaciones de actualización) y nuestro sistema para un número creciente de atributos escasos. Cada atributo corresponde a la membresía en una sesión de multidifusión con un pequeño número de participantes. Para este experimento, el tamaño de la sesión se establece en 8, el factor de ramificación se establece en 16, el modo de propagación para SDIMS se actualiza y los nodos participantes realizan sondas continuas para el valor agregado global. Trazamos el estrés del nodo máximo (en términos de mensajes) observado en ambos esquemas para redes de diferentes tamaños con un número creciente de sesiones cuando el participante de cada sesión realiza una operación de actualización. Claramente, el esquema basado en DHT es más escalable con respecto a los atributos que un esquema de chismes de actualización. Observe que en un número constante de atributos, a medida que aumenta el número de nodos en el sistema, el estrés de nodo máximo aumenta en el enfoque de chismes, mientras que disminuye en nuestro enfoque a medida que la carga de agregación se extiende a través de más nodos. Las simulaciones con otros tamaños de sesión (4 y 16) producen resultados similares. Jerarquía administrativa y robustez: aunque el protocolo de enrutamiento de ADHT podría conducir a un mayor número de lúpulo para alcanzar la raíz de una clave en comparación con la masa original, el algoritmo se ajusta a la convergencia de ruta y las propiedades de la localidad y, por lo tanto, proporciona propiedades de aislamiento administrativo. En la Figura 10, cuantificamos el aumento de la longitud de la ruta mediante comparaciones con pasteles no modificados para redes de diferentes tamaños con diferentes factores de ramificación del árbol de jerarquía de dominio. Para cuantificar la propiedad de convergencia de ruta, realizamos simulaciones con una gran cantidad de pares de sondas, cada par sondeando para una clave aleatoria que comienza desde dos nodos elegidos al azar. En la Figura 11, trazamos el porcentaje de pares de sondas para pasteles no modificados que no se ajustan a la propiedad de convergencia de ruta. Cuando el factor de ramificación es bajo, el árbol de jerarquía de dominio es más profundo, lo que resulta en una gran diferencia entre 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 Número de nodos de longitud= 4,16,64 Figura 10: Longitud promedio de la ruta a la raíz en pasteles versus ADHT para diferentes factores de ramificación. Tenga en cuenta que todas las líneas correspondientes a la superposición de pastelería.0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Porcentaje de Violaciones Número de nodos BF = 4 BF = 16 BF = 64 Figura 11: Porcentaje de pares de sondas cuyos caminos a la raíz no se ajustaban a la propiedad de convergencia de la ruta con Pastry. U pdate-todo u pdate-u p u pdate-local 0 200 400 600 800 LATENCIA (INM) LATENCIA promedio U PDATE-ALL U PDATE-U P U PDATE LOCAL 0 1000 2000 3000 LATENCIA (INM) LATENCIA promedio (a)(b) Figura 12: Latencia de las sondas para el agregado a nivel de raíz global con tres modos diferentes de propagación agregada en (a) máquinas de departamento y (b) máquinas PlanetLab Pastry y ADHT en la longitud promedio de la ruta;Pero es en estos pequeños tamaños de dominio, que la convergencia del camino falla con más frecuencia con la masa original.7.2 Experimentos de Testbed Ejecutamos nuestro prototipo en 180 máquinas de departamento (algunas máquinas ejecutaron múltiples instancias de nodos, por lo que esta configuración tiene un total de 283 nodos SDIMS) y también en 69 máquinas del Bebed de Testlab [27]. Medimos el rendimiento de nuestro sistema con dos micro-benchmarks. En el primer micro-benchmar, instalamos tres funciones de agregación de tipos de actualización local, actualización y actualización, realice una operación de actualización en todos los nodos para las tres funciones de agregación y medimos las latencias incurridas por las sondas para el agregado global del agregado globalde todos los nodos en el sistema. Figura 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 LATENCIA (INM) Tiempo de tiempo (en Sec) Valores Nodo de latencia muerto Figura 13: Micro-Bencillo en la red de departamento que muestra elComportamiento de las sondas de un solo nodo cuando están ocurriendo fallas en otros nodos. Los 283 nodos asignan un valor de 10 al atributo.10 100 1000 10000 100000 0 50 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 LATENCIA (INMS) Valores de tiempo Observado (en SEC) Valores Nodo de latencia Figura 14: rendimiento de la sonda durante fallas en 69 máquinas de planetlab testbed muestra elLatencias observadas para ambos tallas de prueba. Observe que la latencia en Update-Local es alta en comparación con la política de actualización. Esto se debe a que la latencia en Update-Local se ve afectada por la presencia de incluso una sola máquina lenta o una sola máquina con una conexión de red de alta latencia. En el segundo punto de referencia, examinamos la robustez. Instalamos una función de agregación de la actualización de tipo que realiza una operación de suma en un atributo valorado en entero. Cada nodo actualiza el atributo con el valor 10. Luego monitoreamos las latencias y los resultados devueltos en la operación de la sonda para el agregado global en un nodo elegido, mientras que matamos algunos nodos después de cada pocas sondas. La Figura 13 muestra los resultados en el Bed de la Prueba departamental. Debido a la naturaleza del Testbed (máquinas en un departamento), hay pocos cambios en las latencias incluso frente a las reconfiguraciones. En la Figura 14, presentamos los resultados del experimento en PlanetLab Testbed. El nodo raíz del árbol de agregación termina después de aproximadamente 275 segundos. Hay un aumento 5x en las latencias después de la muerte del nodo de raíz inicial, ya que un nodo más distante se convierte en el nodo raíz después de las reparaciones. En ambos experimentos, los valores devueltos en las sondas comienzan a reflejar la situación correcta dentro de poco tiempo después de las fallas. Tanto los experimentos de referencia de la prueba de prueba como de los experimentos de simulación sobre flexibilidad y escalabilidad, concluimos que (1) la flexibilidad proporcionada por SDIMS permite que las aplicaciones intercambien sobrecargas de lectura-escritura (Figura 8), latencia de lectura y sensibilidad a máquinas ralas (Figura 12), (2) Una buena estrategia de agregación predeterminada es la actualización que tiene gastos generales moderados tanto en las lecturas como en las escrituras (Figura 8), tiene latencias de lectura moderadas (Figura 12) y es escalable con respecto a los nodos y los atributos (Figura 9), y (3) los tamaños de dominio pequeños son los casos en que los algoritmos DHT no proporcionan la convergencia de ruta con más frecuencia y los SDIMS aseguran la convergencia de la ruta con solo un aumento moderado en las longitudes de la ruta (Figura 11).7.3 Aplicaciones SDIMS está diseñada como una infraestructura general de control y control distribuido para una amplia gama de aplicaciones. Arriba, discutimos algunos microbistres simples que incluyen un servicio de membresía de multidifusión y una función de calculación de suma. Van Renesse et al.[38] proporcionan ejemplos detallados de cómo dicho servicio puede usarse para un directorio de almacenamiento en caché de pares, un servicio de difusión de datos, un sistema PublishSubscribe, sincronización de barreras y votación. Además, tenemos experiencia inicial utilizando SDIMS para construir dos aplicaciones significativas: el plano de control para un sistema de archivos distribuidos a gran escala [12] y un monitor de red para identificar bateadores pesados que consumen recursos en exceso. Control del sistema de archivos distribuido: el sistema de replicación práctica (replicación parcial, consistencia arbitraria, independencia de la topología) proporciona un conjunto de mecanismos para la replicación de datos sobre los cuales se pueden colocar políticas de control arbitrarias. Utilizamos SDIMS para proporcionar varias funciones clave para crear un sistema de archivos a través de los mecanismos prácticos de bajo nivel. Primero, los nodos usan SDIMS como directorio para manejar la lectura. Cuando un nodo n recibe un objeto o, actualiza el atributo (readDir, o) con el valor n;Cuando n descarga O de su tienda local, se restablece (readdir, o) a null. En cada nodo virtual, la función de agregación ReadDir simplemente selecciona un valor infantil no nulo aleatorio (si lo hay) y utilizamos la política de actualización para propagar actualizaciones. Finalmente, para localizar una copia cercana de un objeto O, un nodo n1 emite una serie de solicitudes de sonda para el atributo (readdir, o), comenzando con nivel = 1 y aumentando el valor de nivel con cada solicitud de sonda repetida hasta que no sea un no nuloSe devuelve el ID del nodo N2.N1 luego envía una solicitud de lectura de demanda a N2, y N2 envía los datos si los tiene. Por el contrario, si N2 no tiene una copia de O, envía un NACK a N1, y N1 emite una sonda de reintento con el parámetro descendente establecido en un valor mayor que el utilizado en la sonda anterior para forzar la reagregación a pedido, que producirá un valor más fresco para el reintento. En segundo lugar, los nodos se suscriben a invalidaciones y actualizaciones a los conjuntos de intereses de los archivos, y los nodos usan SDIMS para configurar y mantener los árboles que abarcan la red-topología de sets porterestas para propagar esta información. Para suscribirse a las invalidaciones para el conjunto de intereses I, un nodo N1 actualiza primero el atributo (Inval, i) con su identidad N1, y la función de agregación en cada nodo virtual selecciona un valor infantil no nulo. Finalmente, N1 sondea niveles de aumento del atributo (Inval, i) hasta que encuentra el primer nodo n2 = n1;N1 luego usa N2 como padre en el árbol de expansión.N1 también emite una sonda continua para este atributo en este nivel, de modo que se notifique a cualquier cambio a su padre de la extensión. Los árboles que abarcan corrientes de actualizaciones empujadas se mantienen de manera similar. En el futuro, planeamos usar SDIMS para al menos dos servicios adicionales dentro de este sistema de replicación. Primero, planeamos usar SDIMS para rastrear las tarifas de lectura y escritura a diferentes objetos;Los algoritmos previos a la captura utilizarán esta información para priorizar la replicación [40, 41]. En segundo lugar, planeamos rastrear los rangos de los números de secuencia de invalidación vistos por cada nodo para cada interés establecido para aumentar los árboles de expansión descritos anteriormente con relleno adicional de agujeros para permitir que los nodos ubiquen invalidaciones específicas que se han perdido. En general, nuestra experiencia inicial con el uso de SDIMS para el sistema de replicación práctica sugiere que (1) la interfaz de agregación general proporcionada por SDIMS simplifica la construcción de aplicaciones distribuidas otorgadas los mecanismos de bajo nivel, 388 pudimos construir un sistema de archivos básicoque utiliza SDIMS para varias tareas de control distintas en menos de dos semanas y (2) las garantías de consistencia débil proporcionadas por los SDIMS cumplen con los requisitos de este controlador de nodos de aplicación, cada uno de los nodos trata efectivamente la información de SDIMS como sugerencias, y si un nodo contactado no tiene elLos datos necesarios, el controlador se reactiva, utilizando la reagregación de SDIMS bajo demanda para obtener una pista más fresca. Problema de bateador pesado distribuido: el objetivo del problema de los bateadores pesados es identificar fuentes de red, destinos o protocolos que representan cantidades significativas o inusuales de tráfico. Como señalaron Estan et al.[13], esta información es útil para una variedad de aplicaciones, como la detección de intrusos (por ejemplo, escaneo de puertos), detección de servicios, detección y seguimiento de gusanos, asignación de red justa y mantenimiento de la red. Se ha realizado un trabajo significativo para desarrollar algoritmos de procesamiento de flujo de alto rendimiento para identificar bateadores pesados en un enrutador, pero esto es solo un primer paso;Idealmente, a estas aplicaciones les gustaría no solo una visión de los enrutadores de los bateadores pesados sino una vista agregada. Utilizamos SDIMS para permitir que la información local sobre los bateadores pesados se agrupe en una vista de los bateadores pesados globales. Para cada dirección IP de destino IPX, un nodo actualiza el atributo (DestBW, IPX) con el número de bytes enviados a IPX en la última ventana de tiempo. La función de agregación para el tipo de atributo Destbw se instala con la estrategia de actualización y simplemente agrega los valores de los nodos infantiles. Los nodos realizan una sonda continua para el agregado global del atributo y aumentan una alarma cuando el valor agregado global va por encima de un límite específico. Tenga en cuenta que solo los nodos que envían datos a una dirección IP particular realizan sondas para el atributo correspondiente. También tenga en cuenta que las técnicas de [25] pueden extenderse al caso jerárquico para la precisión de compensación para el ancho de banda de comunicación.8. Trabajo relacionado La abstracción de agregación que usamos en nuestro trabajo está fuertemente influenciada por el proyecto Astrolabe [38]. Astrolabe adopta una técnica de chismes propagateall y no estructuradas para lograr robustez [5]. Sin embargo, cualquier esquema de chismes requiere una replicación agresiva de los agregados. Si bien dicha replicación agresiva es eficiente para los atributos dominados por lecturas, incurre en un alto costo de mensajes para los atributos con una pequeña relación de lectura-escritura. Nuestro enfoque proporciona una API flexible para que las aplicaciones establezcan reglas de propagación de acuerdo con sus relaciones de lectura a escritura. Otros proyectos estrechamente relacionados incluyen Willow [39], Cono [4], Dasis [1] y Somo [45]. Willow, Dasis y Somo construyen un solo árbol para la agregación. Cono construye un árbol por atributo y requiere un orden total en los valores de atributo. Se han diseñado varios sistemas académicos [15, 21, 42] y comerciales [37] de monitoreo distribuido para monitorear el estado de grandes sistemas en red. Algunos de ellos están centralizados donde se recopilan y analizan todos los datos de monitoreo en un huésped central. Los ganglios [15, 23] usan un sistema jerárquico donde los atributos se replican dentro de los grupos utilizando multidifusión y luego los agregados de clúster se agregan aún más a lo largo de un solo árbol. Sophia [42] es un sistema de monitoreo distribuido diseñado con un modelo de programación lógica declarativa donde la ubicación de la ejecución de la consulta es explícita en el lenguaje y se puede calcular durante la evaluación. Esta investigación es complementaria a nuestro trabajo. Etiqueta [21] recopila información de una gran cantidad de sensores a lo largo de un solo árbol. La observación de que los DHT proporcionan internamente un bosque escalable de árboles de reducción no es nueva. Plaxton et al.s [28] El documento original no describe un DHT, sino un sistema para agregar y consultar los datos de ubicación de objetos jerárquicamente para enrutar las solicitudes a copias cercanas de objetos. Muchos sistemas construyen tanto la estrategia de corrección de bits de los plaxtones [32, 46] como en otras estrategias [24, 29, 35] -He elegido para ocultar esta potencia y exportar una abstracción de tabla de hash distribuida simple y general como un bloque de construcción útil paraUna amplia gama de aplicaciones distribuidas. Algunos de estos sistemas utilizan internamente el bosque de reducción no solo para el enrutamiento sino también para el almacenamiento en caché [32], sino que por simplicidad, estos sistemas generalmente no exportan esta poderosa funcionalidad en su interfaz externa. Nuestro objetivo es desarrollar y exponer el bosque de reducción interna de los DHT como una abstracción igualmente general y útil. Aunque la ubicación del objeto es una aplicación objetivo predominante para DHTS, varias otras aplicaciones como la multidifusión [8, 9, 33, 36] y DNS [11] también se construyen utilizando DHT. Todos estos sistemas realizan implícitamente la agregación en algún atributo, y cada uno de ellos debe estar diseñado para manejar cualquier reconfiguración en el DHT subyacente. Con la abstracción de agregación proporcionada por nuestro sistema, el diseño y la construcción de tales aplicaciones se vuelve más fácil. Los árboles DHT internos generalmente no satisfacen las propiedades de la localidad de dominio requeridas en nuestro sistema. Castro et al.[7] y Gummadi et al.[17] señalan la importancia de la convergencia de la ruta desde la perspectiva de lograr la eficiencia e investigar el rendimiento de la pastelería y otros algoritmos DHT, respectivamente. Skipnet [18] proporciona un enrutamiento restringido de dominio donde una búsqueda de clave se limita al dominio especificado. Esta interfaz se puede utilizar para garantizar la convergencia de ruta buscando en el dominio más bajo y avanzando al siguiente dominio cuando la búsqueda llega a la raíz en el dominio actual. Aunque esta estrategia garantiza la convergencia de la ruta, pierde la propiedad de abstracción del árbol de agregación de los DHT, ya que el enrutamiento limitado del dominio podría tocar un nodo más de una vez (mientras busca hacia adelante y luego hacia atrás para permanecer dentro de un dominio).9. Conclusiones Este documento presenta un sistema escalable de gestión de información distribuida (SDIMS) que agrega información en sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones. Para los sistemas a gran escala, la agregación jerárquica es una abstracción fundamental para la escalabilidad. Construimos nuestro sistema extendiendo ideas de Astrolabe y DHTS para lograr (i) escalabilidad con respecto a los nodos y atributos a través de una nueva abstracción de agregación que ayuda a aprovechar los árboles internos de DHTS para la agregación, (ii) a través de una API simple que permite que las aplicaciones controlen las aplicacionesPropagación de lecturas y escrituras, (iii) aislamiento administrativo a través de aumentos simples de los algoritmos DHT actuales, y (iv) robustez a las reconfiguraciones de nodos y redes a través de la reegregación perezosa, la reegregación a pedido y la replicación espacial sintonizable. Agradecimientos Agradecemos a J.C. Browne, Robert Van Renseee, Amin Vahdat, Jay Lepreau y los revisores anónimos por sus útiles comentarios sobre este trabajo.10. Referencias [1] K. Albrecht, R. Arnold, M. Gahwiler y R. Wattenhofer. Únase y deje en los sistemas de igual a igual: el enfoque DASIS. Informe técnico, CS, Eth Zurich, 2003. [2] G. Back, W. H. Hsieh y J. Lepreau. Procesos en Kaffeos: aislamiento, gestión de recursos e intercambio en Java. Osdi, octubre de 2000. [3] G. Banga, P. Druschel y J. Contenedores de recursos: una nueva instalación para la gestión de recursos en los sistemas de servidores. En OSDI99, febrero de 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese y G. M. Voelker. Cono: un enfoque distribuido basado en el montón para la selección de recursos. Informe técnico CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman. El sorprendente poder de la comunicación epidémica. En Actas de Fudico, 2003. [6] B. Bloom. Las compensaciones de espacio/tiempo en la codificación hash con errores permitidos. Comunicaciónde la ACM, 13 (7): 422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu y A. Rowstron. Explotación de la proximidad de la red en redes de superposición de igual a igual. Informe técnico MSR-TR-2002-82, MSR.[8] M. Castro, P. Druschel, A.-M.Kermarrec, A. Nandi, A. Rowstron y A. Singh. Splitstream: multidifusión de alto ancho de banda en un entorno cooperativo. En Sosp, 2003. [9] M. Castro, P. Druschel, A.-M.Kermarrec y A. Rowstron. Escribo: una infraestructura de multidifusión de multidifusión a gran escala y descentralizada de nivel de aplicación. IEEE JSAC (número especial sobre soporte de red para comunicaciones de multidifusión), 2002. [10] J. Challenger, P. Dantzig y A. Iyengar. Un sistema escalable y altamente disponible para servir datos dinámicos en sitios web de acceso frecuente. En Actas de ACM/IEEE, SuperComputing 98 (SC98), noviembre de 1998. [11] R. Cox, A. Muthitacharoen y R. T. Morris. Sirviendo DNS utilizando un servicio de búsqueda entre pares. En IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula y J. Zheng. Replicación práctica para sistemas a gran escala. Informe técnico TR-04-28, Universidad de Texas en Austin, 2004. [13] C. Estan, G. Varghese y M. Fisk. Algoritmos de mapa de bits para contar flujos activos en enlaces de alta velocidad. En Internet Medeurement Conference 2003, 2003. [14] Y. Fu, J. Chase, B. Chun, S. Schwab y A. Vahdat. Sharp: una arquitectura para la mirada de recursos seguros. Sosp, octubre de 2003. [15] Ganglios: Sistema de monitoreo y ejecución distribuidos.http://ganglia.sourceforge.net.[16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig y D. Suciu. ¿Qué puede hacer entre pares para las bases de datos y viceversa? En Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker e I. Stoica. El impacto de la geometría de enrutamiento de DHT en la resiliencia y la proximidad. A. Harvey, M. B. Jones, S. Saroiu, M. Theimer y A. Wolman. Skipnet: una red superpuesta escalable con propiedades prácticas de localidad. En Usits, marzo de 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker e I. Stoica. Consulta en Internet con Pier. En Actas de la Conferencia VLDB, mayo de 2003. [20] C. Intanagonwiwat, R. Govindan y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Mobicom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. Etiqueta: un pequeño servicio de agregación para redes de sensores ad-hoc. En Osdi, 2002. [22] D. Malkhi. En Fudico, 2002. [23] M. L. Massie, B. N. Chun y D. E. Culler. El sistema de monitoreo distribuido de los ganglios: diseño, implementación y experiencia. En sumisión.[24] P. Maymounkov y D. Mazieres. Kademlia: un sistema de información entre pares basado en la métrica XOR. En procedimientos de los IPTPS, marzo de 2002. [25] C. Olston y J. Widom. Ofreciendo una compensación de precisión-rendimiento para consultas de agregación sobre datos replicados. En VLDB, páginas 144-155, septiembre de 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer y A. Demers. Propagación de actualización flexible para una replicación débilmente consistente. Sosp, octubre de 1997. [27] Planetlab.http://www.planet-lab.org.[28] C. G. Plaxton, R. Rajaraman y A. W. Richa. Acceso a copias cercanas de objetos replicados en un entorno distribuido. En ACM Spaa, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red de contenido de contenido escalable. En Actas de ACM Sigcomm, 2001. [30] S. Ratnasamy, S. Shenker e I. Stoica. Algoritmos de enrutamiento para DHT: algunas preguntas abiertas. En IPTPS, marzo de 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky y S. Hand. InfoSpect: utilizando un lenguaje lógico para el monitoreo de la salud del sistema en sistemas distribuidos. En Actas del Taller Europeo de Sigops, 2002. [32] A. Rowstron y P. Druschel. PASTRA: ubicación y enrutamiento de objetos escalables y distribuidos para sistemas de pares a igual a gran escala. En Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp y S.Shenker. Multicast de nivel de aplicación utilizando redes de contenido directo. En Actas de la NGC, noviembre de 2001. [34] W. Stallings. Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek y H. Balakrishnan. Acorde: un servicio de búsqueda de pares escalable para aplicaciones de Internet. En ACM Sigcomm, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz y J.Kubiatowicz. Bayeux: una arquitectura para la difusión de datos de área amplia escalable y tolerante a fallas. En Nossdav, 2001. [37] Monitoreo de IBM Tivoli.www.ibm.com/software/tivoli/products/monitor.[38] R. Vanrenesse, K. P. Birman y W. Vogels. Astrolabe: una tecnología robusta y escalable para el monitoreo, gestión y minería de datos distribuidos del sistema. TOCS, 2003. [39] R. Vanrenesse y A. Bozdog. Willow: DHT, agregación y publicar/suscríbete en un protocolo. En IPTPS, 2004. [40] A. Venkataramani, P. Weidmann y M. Dahlin. Ancho de banda Ubicación restringida en un WAN. En Podc, agosto de 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif y M. Dahlin. Costos y beneficios potenciales de la prioridad a largo plazo para la distribución de contenido. Elsevier Computer Communications, 25 (4): 367-375, marzo de 2002. [42] M. Wawrzoniak, L. Peterson y T. Roscoe. Sophia: un plano de información para sistemas en red. En Hotnets-II, 2003. [43] R. Wolski, N. Spring y J. Hayes. El servicio meteorológico de la red: un servicio de pronóstico de rendimiento de recursos distribuido para metacomputación. Journal of Future Generation Computing Systems, 15 (5-6): 757-768, octubre de 1999. [44] P. Yalagandula y M. Dahlin. SDIMS: un sistema de gestión de información distribuido escalable. Informe técnico TR-03-47, Departamento de Ciencias de la Computadora, UT Austin, septiembre de 2003. [45] Z. Zhang, S.-M.Shi y J. Zhu. Somo: superposición de metadatos autoorganizados para la gestión de recursos en P2P DHT. En IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz y A. D. Joseph. Tapestry: una infraestructura para la ubicación y el enrutamiento del área ancha tolerante a fallas. Informe técnico UCB/CSD-01-1141, UC Berkeley, abril de 2001. 390",
    "original_sentences": [
        "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
        "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
        "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
        "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
        "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
        "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
        "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
        "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
        "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
        "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
        "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
        "To be used as a basic building block, a SDIMS should have four properties.",
        "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
        "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
        "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
        "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
        "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
        "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
        "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
        "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
        "Third, a SDIMS should provide administrative isolation.",
        "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
        "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
        "Fourth, the system must be robust to node failures and disconnections.",
        "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
        "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
        "Astrolabe [38] is a robust information management system.",
        "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
        "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
        "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
        "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
        "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
        "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
        "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
        "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
        "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
        "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
        "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
        "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
        "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
        "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
        "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
        "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
        "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
        "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
        "We have built a prototype of SDIMS.",
        "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
        "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
        "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
        "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
        "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
        "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
        "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
        "In Section 5, we detail the implementation of our prototype system.",
        "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
        "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
        "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
        "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
        "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
        "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
        "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
        "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
        "We describe how to form such trees in a later section.",
        "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
        "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
        "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
        "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
        "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
        "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
        "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
        "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
        "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
        "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
        "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
        "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
        "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
        "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
        "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
        "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
        "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
        "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
        "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
        "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
        "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
        "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
        "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
        "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
        "Finally, notice that other strategies exist.",
        "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
        "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
        "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
        "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
        "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
        "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
        "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
        "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
        "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
        "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
        "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
        "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
        "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
        "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
        "The arguments for this operation are listed in Table 1.",
        "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
        "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
        "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
        "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
        "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
        "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
        "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
        "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
        "The complete argument set for the probe operation is shown in Table 2.",
        "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
        "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
        "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
        "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
        "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
        "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
        "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
        "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
        "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
        "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
        "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
        "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
        "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
        "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
        "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
        "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
        "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
        "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
        "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
        "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
        "Supporting sparse names within a type provides at least two advantages.",
        "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
        "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
        "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
        "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
        "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
        "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
        "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
        "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
        "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
        "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
        "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
        "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
        "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
        "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
        "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
        "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
        "Also the corresponding aggregation tree is shown.",
        "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
        "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
        "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
        "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
        "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
        "Our ADHTs routing table differs from Pastrys in two ways.",
        "First, each node maintains a separate leaf set for each domain of which it is a part.",
        "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
        "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
        "Additional details about the ADHT algorithm are available in an extended technical report [44].",
        "Properties.",
        "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
        "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
        "We experimentally quantify the additional routing costs in Section 7.",
        "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
        "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
        "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
        "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
        "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
        "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
        "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
        "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
        "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
        "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
        "This computation is illustrated in the Figure 5.",
        "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
        "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
        "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
        "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
        "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
        "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
        "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
        "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
        "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
        "We refer an (attribute type, attribute name) tuple as an attribute key.",
        "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
        "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
        "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
        "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
        "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
        "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
        "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
        "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
        "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
        "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
        "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
        "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
        "Level-0 differs slightly from other levels.",
        "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
        "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
        "We envision various sensor programs and applications insert data into local MIB.",
        "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
        "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
        "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
        "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
        "The outstanding probes table maintains temporary information regarding in-progress probes.",
        "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
        "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
        "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
        "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
        "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
        "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
        "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
        "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
        "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
        "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
        "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
        "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
        "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
        "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
        "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
        "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
        "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
        "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
        "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
        "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
        "We implement a lease-based mechanism for dynamic adaptation.",
        "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
        "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
        "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
        "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
        "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
        "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
        "ROBUSTNESS In large scale systems, reconfigurations are common.",
        "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
        "During reconfigurations, a probe might return a stale value for two reasons.",
        "First, reconfigurations lead to incorrectness in the previous aggregate values.",
        "Second, the nodes needed for aggregation to answer the probe become unreachable.",
        "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
        "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
        "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
        "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
        "We provide two mechanisms for replication in time.",
        "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
        "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
        "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
        "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
        "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
        "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
        "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
        "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
        "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
        "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
        "Probes that complete or start between points 2 and 8 may return stale answers.",
        "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
        "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
        "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
        "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
        "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
        "In our system, however, all internal nodes have to be replicated along with the root.",
        "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
        "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
        "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
        "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
        "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
        "However, note that this technique is not appropriate in some cases.",
        "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
        "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
        "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
        "In all experiments, we use static up and down values and turn off dynamic adaptation.",
        "Our evaluation supports four main conclusions.",
        "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
        "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
        "Second, our system is scalable with respect to both nodes and attributes.",
        "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
        "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
        "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
        "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
        "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
        "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
        "Simulations with other sizes of networks with different branching factors reveal similar results.",
        "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
        "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
        "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
        "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
        "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
        "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
        "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
        "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
        "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
        "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
        "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
        "Simulations with other session sizes (4 and 16) yield similar results.",
        "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
        "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
        "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
        "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
        "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
        "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
        "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
        "We measure the performance of our system with two micro-benchmarks.",
        "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
        "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
        "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
        "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
        "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
        "In the second benchmark, we examine robustness.",
        "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
        "Each node updates the attribute with the value 10.",
        "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
        "Figure 13 shows the results on the departmental testbed.",
        "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
        "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
        "The root node of the aggregation tree is terminated after about 275 seconds.",
        "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
        "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
        "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
        "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
        "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
        "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
        "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
        "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
        "First, nodes use SDIMS as a directory to handle read misses.",
        "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
        "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
        "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
        "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
        "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
        "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
        "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
        "Spanning trees for streams of pushed updates are maintained in a similar manner.",
        "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
        "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
        "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
        "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
        "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
        "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
        "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
        "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
        "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
        "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
        "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
        "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
        "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
        "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
        "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
        "However, any gossiping scheme requires aggressive replication of the aggregates.",
        "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
        "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
        "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
        "Willow, DASIS and SOMO build a single tree for aggregation.",
        "Cone builds a tree per attribute and requires a total order on the attribute values.",
        "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
        "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
        "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
        "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
        "This research is complementary to our work.",
        "TAG [21] collects information from a large number of sensors along a single tree.",
        "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
        "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
        "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
        "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
        "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
        "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
        "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
        "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
        "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
        "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
        "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
        "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
        "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
        "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
        "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
        "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
        "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
        "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
        "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
        "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
        "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
        "In Proc.",
        "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
        "Mogul.",
        "Resource Containers: A New Facility for Resource Management in Server Systems.",
        "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
        "Cone: A Distributed Heap-Based Approach to Resource Selection.",
        "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
        "The Surprising Power of Epidemic Communication.",
        "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
        "Space/time tradeoffs in hash coding with allowable errors.",
        "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
        "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
        "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
        "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
        "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
        "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
        "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
        "Challenger, P. Dantzig, and A. Iyengar.",
        "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
        "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
        "Serving DNS using a Peer-to-Peer Lookup Service.",
        "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
        "PRACTI replication for large-scale systems.",
        "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
        "Bitmap algorithms for counting active flows on high speed links.",
        "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
        "Chase, B. Chun, S. Schwab, and A. Vahdat.",
        "SHARP: An architecture for secure resource peering.",
        "In Proc.",
        "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
        "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
        "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
        "The Impact of DHT Routing Geometry on Resilience and Proximity.",
        "In SIGCOMM, 2003. [18] N. J.",
        "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
        "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
        "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
        "Querying the Internet with PIER.",
        "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
        "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
        "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
        "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
        "In OSDI, 2002. [22] D. Malkhi.",
        "Dynamic Lookup Networks.",
        "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
        "The ganglia distributed monitoring system: Design, implementation, and experience.",
        "In submission. [24] P. Maymounkov and D. Mazieres.",
        "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
        "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
        "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
        "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
        "Flexible Update Propagation for Weakly Consistent Replication.",
        "In Proc.",
        "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
        "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
        "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
        "A Scalable Content Addressable Network.",
        "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
        "Routing Algorithms for DHTs: Some Open Questions.",
        "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
        "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
        "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
        "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
        "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
        "Application-level Multicast using Content-addressable Networks.",
        "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
        "SNMP, SNMPv2, and CMIP.",
        "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
        "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
        "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
        "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
        "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
        "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
        "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
        "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
        "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
        "Bandwidth constrained placement in a wan.",
        "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
        "Potential costs and benefits of long-term prefetching for content-distribution.",
        "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
        "Sophia: An Information Plane for Networked Systems.",
        "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
        "The network weather service: A distributed resource performance forecasting service for metacomputing.",
        "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
        "SDIMS: A scalable distributed information management system.",
        "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
        "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
        "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
        "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
        "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
    ],
    "error_count": 0,
    "keys": {
        "information management system": {
            "translated_key": "sistema de gestión de la información",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed <br>information management system</br>∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed <br>information management system</br> (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed <br>information management system</br> (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust <br>information management system</br>.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed <br>information management system</br> (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed <br>information management system</br>.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un \"sistema de gestión de la información\" distribuido escalable ∗ praveen yalagandula ypraveen@cs.utexas.edu mike dahlin dahlin@cs.utexas.edu Departamento de ciencias de las computadorSistema \"(SDIMS) que agrega información sobre los sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones distribuidas a gran escala al proporcionar vistas detalladas de la información cercana y las vistas sumarias de la información global.",
                "Introducción El objetivo de esta investigación es diseñar y construir un \"sistema de gestión de la información\" (SDIMS) distribuido escalable que agregue información sobre los sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones distribuidas a gran escala.",
                "Astrolabe [38] es un robusto \"sistema de gestión de la información\".",
                "Conclusiones Este documento presenta un \"Sistema de gestión de la información\" (SDIMS) escalable que agrega información en sistemas en red a gran escala y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones.",
                "SDIMS: un \"Sistema de gestión de la información\" escalable."
            ],
            "translated_text": "",
            "candidates": [
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "sistema de gestión de la información",
                "Sistema de gestión de la información",
                "sistema de gestión de la información",
                "Sistema de gestión de la información"
            ],
            "error": []
        },
        "distributed hash table": {
            "translated_key": "tabla hash distribuida",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general <br>distributed hash table</br> abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Muchos sistemas construyen tanto la estrategia de corrección de bits de los plaxtones [32, 46] como en otras estrategias [24, 29, 35] -He eligido para ocultar esta potencia y exportar una abstracción simple y general de \"tabla hash distribuida\" como un edificio útil.bloque para una amplia gama de aplicaciones distribuidas."
            ],
            "translated_text": "",
            "candidates": [
                "tabla hash distribuida",
                "tabla hash distribuida"
            ],
            "error": []
        },
        "networked system monitoring": {
            "translated_key": "monitoreo del sistema en red",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "large-scale networked system": {
            "translated_key": "sistema en red a gran escala",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about <br>large-scale networked system</br>s and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about <br>large-scale networked system</br>s and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in <br>large-scale networked system</br>s and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un sistema escalable de gestión de información distribuida ∗ praveen yalagandula ypraveen@cs.utexas.edu mike dahlin dahlin@cs.utexas.edu Departamento de ciencias informáticas La Universidad de Texas en Austin Austin, TX 78712 Resumen. Presentamos un sistema de gestión de información distribuido escalable (SDIMS SDIMS) que agrega información sobre los \"sistemas en red a gran escala\" y que pueden servir como un bloque de construcción básico para una amplia gama de aplicaciones distribuidas a gran escala al proporcionar vistas detalladas de la información cercana y las vistas sumarias de la información global.",
                "Introducción El objetivo de esta investigación es diseñar y construir un sistema escalable de gestión de información distribuida (SDIMS) que agregue información sobre los \"sistemas de redes a gran escala\" y que pueden servir como un bloque de construcción básico para una amplia gama de distribuidos a gran escala distribuidos a gran escalaaplicaciones.",
                "Conclusiones Este documento presenta un sistema escalable de gestión de información distribuida (SDIMS) que agrega información en \"sistemas de redes a gran escala\" y que puede servir como un bloque de construcción básico para una amplia gama de aplicaciones."
            ],
            "translated_text": "",
            "candidates": [
                "sistema en red a gran escala",
                "sistemas en red a gran escala",
                "sistema en red a gran escala",
                "sistemas de redes a gran escala",
                "sistema en red a gran escala",
                "sistemas de redes a gran escala"
            ],
            "error": []
        },
        "distributed operating system backbone": {
            "translated_key": "columna vertebral del sistema operativo distribuido",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "read-dominated attribute": {
            "translated_key": "atributo dominado por lectura",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a <br>read-dominated attribute</br> like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Por ejemplo, un \"atributo dominado por lectura\" como NUMCPUS rara vez cambia en el valor, mientras que un atributo escrito por numerosos, como numprocesos, cambia con bastante frecuencia."
            ],
            "translated_text": "",
            "candidates": [
                "atributo dominado por lectura",
                "atributo dominado por lectura"
            ],
            "error": []
        },
        "write-dominated attribute": {
            "translated_key": "Atributo dominado por la escritura",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while <br>write-dominated attribute</br>s like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to <br>write-dominated attribute</br>s.",
                "Conversely, an approach tuned for <br>write-dominated attribute</br>s will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support <br>write-dominated attribute</br>s.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for <br>write-dominated attribute</br>s.",
                "Conversely, an approach like UpdateLocal works well for <br>write-dominated attribute</br>s but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Por ejemplo, los atributos de lectura como NUMCPU rara vez cambian en el valor, mientras que los \"atributos dominados por la escritura\" son como los numorizos cambian con bastante frecuencia.",
                "Un enfoque ajustado para los atributos dominados por lectura consumirá un alto ancho de banda cuando se aplique a \"atributo dominado por la escritura\" s.",
                "Por el contrario, un enfoque ajustado para el \"atributo dominado por la escritura\" s sufrirá una latencia o imprecisión de consulta innecesaria para los atributos dominados por lectura.",
                "Además, aunque el enfoque funciona bien para los atributos dominados por la lectura, una actualización en un nodo eventualmente puede afectar el estado en todos los nodos, lo que puede limitar la flexibilidad de los sistemas para admitir el \"atributo dominado por la escritura\" s.",
                "Una estrategia de agregación como Update-All Funciona bien para atributos dominados por las lecturas, pero sufre un alto consumo de ancho de banda cuando se aplica a los \"atributos dominados por la escritura\" s.",
                "Por el contrario, un enfoque como UpdateLocal funciona bien para \"atributos dominados por la escritura\", pero sufre de latencia o imprecisión de consulta innecesaria para atributos dominados por lecturas."
            ],
            "translated_text": "",
            "candidates": [
                "Atributo dominado por la escritura",
                "atributos dominados por la escritura",
                "Atributo dominado por la escritura",
                "atributo dominado por la escritura",
                "Atributo dominado por la escritura",
                "atributo dominado por la escritura",
                "Atributo dominado por la escritura",
                "atributo dominado por la escritura",
                "Atributo dominado por la escritura",
                "atributos dominados por la escritura",
                "Atributo dominado por la escritura",
                "atributos dominados por la escritura"
            ],
            "error": []
        },
        "virtual node": {
            "translated_key": "nodo virtual",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call <br>virtual node</br>, is simulated by one or more physical nodes at the leaves of the subtree for which the <br>virtual node</br> is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the <br>virtual node</br> at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a <br>virtual node</br> at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a <br>virtual node</br> is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal <br>virtual node</br> hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate <br>virtual node</br> on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate <br>virtual node</br> will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "<br>virtual node</br> Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each <br>virtual node</br> at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given <br>virtual node</br> ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "<br>virtual node</br> ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A <br>virtual node</br> ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a <br>virtual node</br> maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i <br>virtual node</br> receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) <br>virtual node</br> sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k <br>virtual node</br> stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a <br>virtual node</br>, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l <br>virtual node</br> for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A <br>virtual node</br> at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l <br>virtual node</br> if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each <br>virtual node</br>, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each <br>virtual node</br> selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un nodo interno no hojas, que llamamos \"nodo virtual\", está simulado por uno o más nodos físicos en las hojas del subárbol para los cuales el \"nodo virtual\" es la raíz.",
                "Por lo tanto, este enfoque distribuye la responsabilidad de la agregación en todos los nodos.4.2 Los árboles de agregación administrativa de aislamiento deben proporcionar un aislamiento administrativo asegurando que para cada dominio, el \"nodo virtual\" en la raíz del subárbol de agregación más pequeño que contiene todos los nodos de ese dominio es alojado por un nodo en ese dominio.",
                "Como ilustra la Figura 4, cada vez que dos nodos en un dominio comparten el mismo prefijo con respecto a una clave y ningún otro nodo en el dominio tiene un prefijo más largo, nuestro algoritmo presenta un \"nodo virtual\" en el límite del dominio correspondiente a ese prefijomás el siguiente dígito de la llave;Tal \"nodo virtual\" está simulado por el nodo existente cuya ID es numéricamente más cercana al ID de nodos virtuales.",
                "Una función de agregación en un \"nodo virtual\" interno alojado en el nodo n con el conjunto de niños C calcula el agregado como un conjunto de tuplas: para cada dominio d de que n forma parte, forma una tupla (d, ∑c∈C (cuenta |(D, contar) ∈ Vc)).",
                "Ahora, una consulta para numachinas con nivel establecido en max devolverá los valores agregados en cada \"nodo virtual\" intermedio en la ruta hacia la raíz como un conjunto de tuplas (nivel de árbol, valor agregado) del que es fácil extraer el recuento demáquinas en cada dominio de encerrado.",
                "Sería menos eficiente porque cada \"nodo virtual\" intermedio tendrá que mantener una lista de todos los valores en las hojas en su subárbol junto con sus nombres y serían menos convenientes ya que las aplicaciones que necesitan un agregado para un dominio tendrán que elegirValores de nodos en ese dominio de la lista devuelto por una sonda y realizar el cálculo.5.",
                "\"Nodo virtual\" Figura 6: Ejemplo que ilustra las estructuras de datos y la organización de ellas en un nodo.",
                "Para apoyar la agregación jerárquica, cada \"nodo virtual\" en la raíz de un subárbol de nivel I mantiene varios MIB que almacenan (1) MIB de niños que contienen valores agregados crudos recolectados de los niños, (2) un MIB de reducción que contiene valores agregados localmente en este crudoinformación, y (3) un antepasado MIB que contiene valores agregados dispersos de los antepasados.",
                "Para un Ni \"Nodo virtual\" dado en el Nivel I, cada MIB de niño contiene el subconjunto de un MIB de reducción de Childs que contiene tuplas que coinciden con la ID del nodo NIS en bits I y cuyo atributo de función de agregación UP es al menos i.",
                "\"Nodo virtual\" Ni en el nivel I mantiene un MIB de reducción de tuplas con una tupla para cada clave presente en cualquier MIB infantil que contenga el tipo de atributo, el nombre del atributo y la salida de las funciones agregadas de los tipos de atributos aplicados a las tuplas de los niños."
            ],
            "translated_text": "",
            "candidates": [
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "Nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "Nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "nodo virtual",
                "Nodo virtual",
                "nodo virtual",
                "Nodo virtual"
            ],
            "error": []
        },
        "update-upk-downj strategy": {
            "translated_key": "estrategia update-upk-downj",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an <br>update-upk-downj strategy</br> aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the <br>update-upk-downj strategy</br> along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En general, una estrategia \"Update-Upk-Downj\" se agrega al parámetro Descripción Opcional Atrtype Atributo Tipo de agregación Agrfunc Función Up hasta qué tan lejos se envía cada actualización (predeterminada: ALL) X Down cuán hacia abajo se envía cada agregado (predeterminado: Ninguno: Ninguno: Ninguno: Ninguno) X Restricción del dominio del dominio (predeterminado: Ninguno) X Exptime Expiry Time Tabla 1: Argumentos para la operación de instalación El nivel de KTH y propaga los valores agregados de un nodo en el nivel L (S.T. L ≤ K) hacia abajo para los niveles J.",
                "La interfaz de instalación permite que las aplicaciones especifiquen los parámetros K y J de la \"Estrategia Update-UPK-Downj\" junto con la función de agregación."
            ],
            "translated_text": "",
            "candidates": [
                "Estrategia de actualización-upk-downj",
                "Update-Upk-Downj",
                "Estrategia de actualización-upk-downj",
                "Estrategia Update-UPK-Downj"
            ],
            "error": []
        },
        "temporal heterogeneity": {
            "translated_key": "heterogeneidad temporal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and <br>temporal heterogeneity</br> of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to <br>temporal heterogeneity</br>, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and <br>temporal heterogeneity</br>.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and <br>temporal heterogeneity</br>.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "SDIMS también permite el cálculo y la propagación no uniformes en el árbol de agregación con diferentes parámetros hacia arriba y hacia abajo en diferentes subárboles para que las aplicaciones puedan adaptarse con la \"heterogeneidad temporal\" de las operaciones de lectura y escritura.",
                "De manera similar, con respecto a la \"heterogeneidad temporal\", los patrones de acceso pueden cambiar con el tiempo que requieren diferentes estrategias con el tiempo.3.1 API de agregación Proporcionamos la flexibilidad descrita anteriormente dividiendo la API de agregación en tres funciones: install () instala una función de agregación que define una operación en un tipo de atributo y especifica la estrategia de actualización que la función usará, actualizando () inserta o modificaUn valor local de nodos para un atributo, y la sonda () obtiene un valor agregado para un subárbol especificado.",
                "La interfaz de la sonda no solo permite que las aplicaciones obtengan el valor agregado para un árbol especificado, sino que también permite que un nodo de sondeo obtenga continuamente los valores durante un tiempo especificado, lo que permite que una aplicación se adapte a la \"heterogeneidad temporal\".",
                "Las sondas con el modo establecido en continuo y con EXPTime finito permiten que las aplicaciones manejen la \"heterogeneidad temporal\"."
            ],
            "translated_text": "",
            "candidates": [
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal",
                "heterogeneidad temporal"
            ],
            "error": []
        },
        "administrative isolation": {
            "translated_key": "aislamiento administrativo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, <br>administrative isolation</br> for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides <br>administrative isolation</br> through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide <br>administrative isolation</br>.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain <br>administrative isolation</br> property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve <br>administrative isolation</br>. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and <br>administrative isolation</br> requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the <br>administrative isolation</br> properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 <br>administrative isolation</br> Aggregation trees should provide <br>administrative isolation</br> by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "<br>administrative isolation</br> is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide <br>administrative isolation</br> to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide <br>administrative isolation</br> also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the <br>administrative isolation</br> property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides <br>administrative isolation</br> property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) <br>administrative isolation</br> through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Para servir como un bloque de construcción básico, un SDIMS debe tener cuatro propiedades: escalabilidad para muchos nodos y atributos, flexibilidad para acomodar una amplia gama de aplicaciones, \"aislamiento administrativo\" para la seguridad y la disponibilidad, y la robustez a las fallas de nodos y redes.",
                "Diseñamos, implementamos y evaluamos un SDIMS que (1) aprovecha las tablas de hash distribuidas (DHT) para crear árboles de agregación escalables, (2) proporciona flexibilidad a través de una API simple que permite que las aplicaciones controlen la propagación de lecturas y escrituras, (3) proporciona \"administrativo\" administrativo \"Aislamiento \"a través de extensiones simples a los algoritmos DHT actuales, y (4) logra robustez a las reconfiguraciones de nodo y en red a través de la reagregación perezosa, reegregación a pedido y replicación espacial sintonizable.",
                "Tercero, un SDIMS debe proporcionar \"aislamiento administrativo\".",
                "Sin embargo, cumplir con los requisitos de SDIMS obliga a un diseño a abordar cuatro preguntas: (1) ¿Cómo asignar diferentes atributos a diferentes árboles de agregación en una malla DHT?(2) ¿Cómo proporcionar flexibilidad en la agregación para acomodar diferentes requisitos de aplicación?(3) ¿Cómo adaptar una malla DHT global y plana para alcanzar la propiedad de \"aislamiento administrativo\"?y (4) ¿Cómo proporcionar robustez sin chismes no estructurados y replicación total?",
                "Aumentamos un algoritmo DHT existente para garantizar las propiedades de convergencia de ruta y localidad de ruta para lograr el \"aislamiento administrativo\".4.",
                "En las Secciones 3 y 4, describimos el diseño de nuestro sistema para lograr la flexibilidad, la escalabilidad y los requisitos de \"aislamiento administrativo\" de un SDIMS.",
                "En segundo lugar, refina la abstracción DHT básica para formar un DHT autónomo (ADHT) para lograr las propiedades de \"aislamiento administrativo\" que son cruciales para la escala de grandes sistemas del mundo real.",
                "Por lo tanto, este enfoque distribuye la responsabilidad de la agregación en todos los nodos.4.2 Los árboles de agregación de \"aislamiento administrativo\" deben proporcionar \"aislamiento administrativo\" al garantizar que para cada dominio, el nodo virtual en la raíz del subárbol de agregación más pequeño que contiene todos los nodos de ese dominio es alojado por un nodo en ese dominio.",
                "El \"aislamiento administrativo\" es importante por tres razones: (i) por seguridad, de modo que las actualizaciones y las sondas que fluyen en un dominio no sean accesibles fuera del dominio, (ii) para la disponibilidad, de modo que las consultas para los valores en un dominio no se ven afectadas porFallas de los nodos en otros dominios, y (iii) para la eficiencia, de modo que las consultas escopadas por dominio pueden ser simples y eficientes.",
                "Para proporcionar \"aislamiento administrativo\" a los árboles de agregación, un DHT debe satisfacer dos propiedades: 1."
            ],
            "translated_text": "",
            "candidates": [
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "administrativo",
                "Aislamiento ",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "Aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "aislamiento administrativo",
                "Aislamiento administrativo",
                "aislamiento administrativo"
            ],
            "error": []
        },
        "autonomous dht": {
            "translated_key": "DHT autónomo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an <br>autonomous dht</br> (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: <br>autonomous dht</br> satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an <br>autonomous dht</br> (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the <br>autonomous dht</br> (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En segundo lugar, refina la abstracción DHT básica para formar un \"DHT autónomo\" (ADHT) para lograr las propiedades de aislamiento administrativo que son cruciales para la escala de grandes sistemas del mundo real.",
                "También mostramos el árbol de agregación correspondiente.110XX 010XX 011XX 100XX 101XX UNIV DEP1 DEP2 CLAVE = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figura 4: \"DHT autónomo\" Satisface la propiedad de aislamiento.",
                "Las modificaciones simples a los protocolos de construcción de la tabla de ruta de Pastrys y los protocolos de rutas clave producen un \"DHT autónomo\" (ADHT) que satisface las propiedades de la localidad de ruta y la convergencia de ruta.",
                "Implementación del prototipo El diseño interno de nuestro prototipo SDIMS comprende dos capas: la capa \"Autónoma DHT\" (ADHT) gestiona la topología superpuesta del sistema y la capa de gestión de agregación (AML) mantiene los atributos de los atributos, realiza agregaciones, tiendas y propague los valores de Agregado."
            ],
            "translated_text": "",
            "candidates": [
                "DHT autónomo",
                "DHT autónomo",
                "DHT autónomo",
                "DHT autónomo",
                "DHT autónomo",
                "DHT autónomo",
                "DHT autónomo",
                "Autónoma DHT"
            ],
            "error": []
        },
        "aggregation management layer": {
            "translated_key": "capa de gestión de agregación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the <br>aggregation management layer</br> (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an <br>aggregation management layer</br> (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Implementación del prototipo El diseño interno de nuestro prototipo SDIMS comprende dos capas: la capa autónoma DHT (ADHT) gestiona la topología superpuesta del sistema y la \"capa de gestión de agregación\" (AML) mantiene los atributos de los atributos, realiza agregaciones, tiendas y propague los valores de Agregado.",
                "Dada la construcción de ADHT descrita en la Sección 4.2, cada nodo implementa una \"capa de gestión de agregación\" (AML) para admitir la API flexible descrita en la Sección 3."
            ],
            "translated_text": "",
            "candidates": [
                "capa de gestión de agregación",
                "capa de gestión de agregación",
                "Capa de gestión de agregación",
                "capa de gestión de agregación"
            ],
            "error": []
        },
        "availability": {
            "translated_key": "disponibilidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and <br>availability</br>, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for <br>availability</br> - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances <br>availability</br> by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read <br>availability</br> - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Para servir como un bloque de construcción básico, un SDIMS debe tener cuatro propiedades: escalabilidad para muchos nodos y atributos, flexibilidad para acomodar una amplia gama de aplicaciones, aislamiento administrativo para la seguridad y la \"disponibilidad\", y robustez a las fallas de nodos y redes.",
                "El aislamiento administrativo es importante por tres razones: (i) por seguridad, de modo que las actualizaciones y las sondas que fluyen en un dominio no sean accesibles fuera del dominio, (ii) para la \"disponibilidad\", de modo que las consultas para los valores en un dominio no se ven afectadas porFallas de los nodos en otros dominios, y (iii) para la eficiencia, de modo que las consultas escopadas por dominio pueden ser simples y eficientes.",
                "La topología ADHT también mejora la \"disponibilidad\" al permitir que el caso común de las sondas para los datos dentro de un dominio dependa solo de los nodos de dominios.",
                "Nuestros dos principios principales para la robustez son garantizar (i) leer \"disponibilidad\": sondas completadas en tiempo finito, y (ii) consistencia eventual: las actualizaciones de un nodo en vivo serán visibles para las sondas por nodos conectados en tiempo finito."
            ],
            "translated_text": "",
            "candidates": [
                "disponibilidad",
                "disponibilidad",
                "disponibilidad",
                "disponibilidad",
                "disponibilidad",
                "disponibilidad",
                "disponibilidad",
                "disponibilidad"
            ],
            "error": []
        },
        "eventual consistency": {
            "translated_key": "consistencia eventual",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides <br>eventual consistency</br> on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield <br>eventual consistency</br> and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees <br>eventual consistency</br> and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically <br>eventual consistency</br> as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) <br>eventual consistency</br> - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Proporciona una interfaz general para instalar nuevas funciones de agregación y proporciona una \"consistencia eventual\" en sus datos.",
                "Esta combinación permite que cualquier patrón de comunicación produzca una \"consistencia eventual\" y permite que cualquier nodo responda cualquier consulta utilizando información local.",
                "Proporcionamos robustez a las reconfiguraciones de nodos y redes al (a) proporcionar una replicación temporal a través de la reagregación perezosa que garantiza \"consistencia eventual\" y (b) asegurando que nuestra API flexible permita que las aplicaciones exigentes obtengan robustez adicional mediante el uso de la replicación espacial sintonizable de los agregados de datos o al realizarReengación rápida a pedido para aumentar la reagregación perezosa subyacente o haciendo ambas cosas.",
                "Por lo tanto, nuestro sistema proporciona solo garantías de consistencia débiles, específicamente \"consistencia eventual\" como se define en [38].3.",
                "Nuestros dos principios principales para la robustez son garantizar (i) leer la disponibilidad: las sondas completadas en tiempo finito, y (ii) \"consistencia eventual\": las actualizaciones de un nodo en vivo serán visibles a las sondas por nodos conectados en tiempo finito."
            ],
            "translated_text": "",
            "candidates": [
                "consistencia eventual",
                "consistencia eventual",
                "consistencia eventual",
                "consistencia eventual",
                "consistencia eventual",
                "consistencia eventual",
                "Consistencia eventual",
                "consistencia eventual",
                "consistencia eventual",
                "consistencia eventual"
            ],
            "error": []
        },
        "lazy re-aggregation": {
            "translated_key": "reagregación perezosa",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, <br>lazy re-aggregation</br> propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "<br>lazy re-aggregation</br>: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default <br>lazy re-aggregation</br> upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Primero, \"Lazy Reaggregation\" propaga las actualizaciones ya recibidas a niños nuevos o nuevos padres de manera perezosa con el tiempo.",
                "\"Lazy Reaggregation\": la capa DHT informa la capa de AML sobre las reconfiguraciones en la red utilizando las siguientes tres llamadas de funciones: NewParent, FallyChild y NewChild.",
                "La Figura 7 muestra la línea de tiempo para la \"re-agregación perezosa\" predeterminada tras la reconfiguración."
            ],
            "translated_text": "",
            "candidates": [
                "reagregación perezosa",
                "Lazy Reaggregation",
                "reagregación perezosa",
                "Lazy Reaggregation",
                "reagregación perezosa",
                "re-agregación perezosa"
            ],
            "error": []
        },
        "freepastry framework": {
            "translated_key": "Marco Freepastry",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the <br>freepastry framework</br> [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Evaluación Hemos implementado un prototipo de SDIMS en Java utilizando el \"Marco Freepastry\" [32] y realizamos experimentos de simulación a gran escala y experimentos de micro bencillo en dos redes reales: 187 máquinas en el departamento y 69 máquinas en el planetlab [27]Testbed."
            ],
            "translated_text": "",
            "candidates": [
                "Marco de Freepastry",
                "Marco Freepastry"
            ],
            "error": []
        },
        "tunable spatial replication": {
            "translated_key": "replicación espacial sintonizable",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and <br>tunable spatial replication</br>.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using <br>tunable spatial replication</br> of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and <br>tunable spatial replication</br>.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Diseñamos, implementamos y evaluamos un SDIMS que (1) aprovecha las tablas de hash distribuidas (DHT) para crear árboles de agregación escalables, (2) proporciona flexibilidad a través de una API simple que permite que las aplicaciones controlen la propagación de lecturas y escrituras, (3) proporciona aislamiento administrativoA través de extensiones simples a los algoritmos DHT actuales, y (4) logra robustez a las reconfiguraciones de nodos y redes a través de la reegregación perezosa, la referencia a pedido y \"replicación espacial sintonizable\".",
                "Proporcionamos robustez a las reconfiguraciones de nodos y redes al (a) proporcionar una replicación temporal a través de la reagregación perezosa que garantiza una consistencia eventual y (b) asegurando que nuestra API flexible permita que las aplicaciones exigentes obtengan robustez adicional al usar la \"replicación espacial sintonizable\" de los agregados de datos o al realizarReengación rápida a pedido para aumentar la reagregación perezosa subyacente o haciendo ambas cosas.",
                "Construimos nuestro sistema extendiendo ideas de Astrolabe y DHTS para lograr (i) escalabilidad con respecto a los nodos y atributos a través de una nueva abstracción de agregación que ayuda a aprovechar los árboles internos de DHTS para la agregación, (ii) a través de una API simple que permite que las aplicaciones controlen las aplicacionesPropagación de lecturas y escrituras, (iii) aislamiento administrativo a través de aumentos simples de los algoritmos DHT actuales y (iv) robustez a las reconfiguraciones de nodos y redes a través de la reegregación perezosa, la referencia a pedido y la \"replicación espacial sintonizable\"."
            ],
            "translated_text": "",
            "candidates": [
                "replicación espacial sintonizable",
                "replicación espacial sintonizable",
                "replicación espacial sintonizable",
                "replicación espacial sintonizable",
                "replicación espacial sintonizable",
                "replicación espacial sintonizable"
            ],
            "error": []
        },
        "distribute hash table": {
            "translated_key": "Distribuir la tabla hash",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "network system monitor": {
            "translated_key": "monitor de sistema de red",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Scalable Distributed Information Management System∗ Praveen Yalagandula ypraveen@cs.utexas.edu Mike Dahlin dahlin@cs.utexas.edu Department of Computer Sciences The University of Texas at Austin Austin, TX 78712 ABSTRACT We present a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications by providing detailed views of nearby information and summary views of global information.",
                "To serve as a basic building block, a SDIMS should have four properties: scalability to many nodes and attributes, flexibility to accommodate a broad range of applications, administrative isolation for security and availability, and robustness to node and network failures.",
                "We design, implement and evaluate a SDIMS that (1) leverages Distributed Hash Tables (DHT) to create scalable aggregation trees, (2) provides flexibility through a simple API that lets applications control propagation of reads and writes, (3) provides administrative isolation through simple extensions to current DHT algorithms, and (4) achieves robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Through extensive simulations and micro-benchmark experiments, we observe that our system is an order of magnitude more scalable than existing approaches, achieves isolation properties at the cost of modestly increased read latency in comparison to flat DHTs, and gracefully handles failures.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Network Operating Systems, Distributed Databases General Terms Management, Design, Experimentation 1.",
                "INTRODUCTION The goal of this research is to design and build a Scalable Distributed Information Management System (SDIMS) that aggregates information about large-scale networked systems and that can serve as a basic building block for a broad range of large-scale distributed applications.",
                "Monitoring, querying, and reacting to changes in the state of a distributed system are core components of applications such as system management [15, 31, 37, 42], service placement [14, 43], data sharing and caching [18, 29, 32, 35, 46], sensor monitoring and control [20, 21], multicast tree formation [8, 9, 33, 36, 38], and naming and request routing [10, 11].",
                "We therefore speculate that a SDIMS in a networked system would provide a distributed operating systems backbone and facilitate the development and deployment of new distributed services.",
                "For a large scale information system, hierarchical aggregation is a fundamental abstraction for scalability.",
                "Rather than expose all information to all nodes, hierarchical aggregation allows a node to access detailed views of nearby information and summary views of global information.",
                "In a SDIMS based on hierarchical aggregation, different nodes can therefore receive different answers to the query find a [nearby] node with at least 1 GB of free memory or find a [nearby] copy of file foo.",
                "A hierarchical system that aggregates information through reduction trees [21, 38] allows nodes to access information they care about while maintaining system scalability.",
                "To be used as a basic building block, a SDIMS should have four properties.",
                "First, the system should be scalable: it should accommodate large numbers of participating nodes, and it should allow applications to install and monitor large numbers of data attributes.",
                "Enterprise and global scale systems today might have tens of thousands to millions of nodes and these numbers will increase over time.",
                "Similarly, we hope to support many applications, and each application may track several attributes (e.g., the load and free memory of a systems machines) or millions of attributes (e.g., which files are stored on which machines).",
                "Second, the system should have flexibility to accommodate a broad range of applications and attributes.",
                "For example, readdominated attributes like numCPUs rarely change in value, while write-dominated attributes like numProcesses change quite often.",
                "An approach tuned for read-dominated attributes will consume high bandwidth when applied to write-dominated attributes.",
                "Conversely, an approach tuned for write-dominated attributes will suffer from unnecessary query latency or imprecision for read-dominated attributes.",
                "Therefore, a SDIMS should provide mechanisms to handle different types of attributes and leave the policy decision of tuning replication to the applications.",
                "Third, a SDIMS should provide administrative isolation.",
                "In a large system, it is natural to arrange nodes in an organizational or an administrative hierarchy.",
                "A SDIMS should support administraSession 10: Distributed Information Systems 379 tive isolation in which queries about an administrative domains information can be satisfied within the domain so that the system can operate during disconnections from other domains, so that an external observer cannot monitor or affect intra-domain queries, and to support domain-scoped queries efficiently.",
                "Fourth, the system must be robust to node failures and disconnections.",
                "A SDIMS should adapt to reconfigurations in a timely fashion and should also provide mechanisms so that applications can tradeoff the cost of adaptation with the consistency level in the aggregated results when reconfigurations occur.",
                "We draw inspiration from two previous works: Astrolabe [38] and Distributed Hash Tables (DHTs).",
                "Astrolabe [38] is a robust information management system.",
                "Astrolabe provides the abstraction of a single logical aggregation tree that mirrors a systems administrative hierarchy.",
                "It provides a general interface for installing new aggregation functions and provides eventual consistency on its data.",
                "Astrolabe is robust due to its use of an unstructured gossip protocol for disseminating information and its strategy of replicating all aggregated attribute values for a subtree to all nodes in the subtree.",
                "This combination allows any communication pattern to yield eventual consistency and allows any node to answer any query using local information.",
                "This high degree of replication, however, may limit the systems ability to accommodate large numbers of attributes.",
                "Also, although the approach works well for read-dominated attributes, an update at one node can eventually affect the state at all nodes, which may limit the systems flexibility to support write-dominated attributes.",
                "Recent research in peer-to-peer structured networks resulted in Distributed Hash Tables (DHTs) [18, 28, 29, 32, 35, 46]-a data structure that scales with the number of nodes and that distributes the read-write load for different queries among the participating nodes.",
                "It is interesting to note that although these systems export a global hash table abstraction, many of them internally make use of what can be viewed as a scalable system of aggregation trees to, for example, route a request for a given key to the right DHT node.",
                "Indeed, rather than export a general DHT interface, Plaxton et al.s [28] original application makes use of hierarchical aggregation to allow nodes to locate nearby copies of objects.",
                "It seems appealing to develop a SDIMS abstraction that exposes this internal functionality in a general way so that scalable trees for aggregation can be a basic system building block alongside the DHTs.",
                "At a first glance, it might appear to be obvious that simply fusing DHTs with Astrolabes aggregation abstraction will result in a SDIMS.",
                "However, meeting the SDIMS requirements forces a design to address four questions: (1) How to scalably map different attributes to different aggregation trees in a DHT mesh? (2) How to provide flexibility in the aggregation to accommodate different application requirements? (3) How to adapt a global, flat DHT mesh to attain administrative isolation property? and (4) How to provide robustness without unstructured gossip and total replication?",
                "The key contributions of this paper that form the foundation of our SDIMS design are as follows. 1.",
                "We define a new aggregation abstraction that specifies both attribute type and attribute name and that associates an aggregation function with a particular attribute type.",
                "This abstraction paves the way for utilizing the DHT systems internal trees for aggregation and for achieving scalability with both nodes and attributes. 2.",
                "We provide a flexible API that lets applications control the propagation of reads and writes and thus trade off update cost, read latency, replication, and staleness. 3.",
                "We augment an existing DHT algorithm to ensure path convergence and path locality properties in order to achieve administrative isolation. 4.",
                "We provide robustness to node and network reconfigurations by (a) providing temporal replication through lazy reaggregation that guarantees eventual consistency and (b) ensuring that our flexible API allows demanding applications gain additional robustness by using tunable spatial replication of data aggregates or by performing fast on-demand reaggregation to augment the underlying lazy reaggregation or by doing both.",
                "We have built a prototype of SDIMS.",
                "Through simulations and micro-benchmark experiments on a number of department machines and PlanetLab [27] nodes, we observe that the prototype achieves scalability with respect to both nodes and attributes through use of its flexible API, inflicts an order of magnitude lower maximum node stress than unstructured gossiping schemes, achieves isolation properties at a cost of modestly increased read latency compared to flat DHTs, and gracefully handles node failures.",
                "This initial study discusses key aspects of an ongoing system building effort, but it does not address all issues in building a SDIMS.",
                "For example, we believe that our strategies for providing robustness will mesh well with techniques such as supernodes [22] and other ongoing efforts to improve DHTs [30] for further improving robustness.",
                "Also, although splitting aggregation among many trees improves scalability for simple queries, this approach may make complex and multi-attribute queries more expensive compared to a single tree.",
                "Additional work is needed to understand the significance of this limitation for real workloads and, if necessary, to adapt query planning techniques from DHT abstractions [16, 19] to scalable aggregation tree abstractions.",
                "In Section 2, we explain the hierarchical aggregation abstraction that SDIMS provides to applications.",
                "In Sections 3 and 4, we describe the design of our system for achieving the flexibility, scalability, and administrative isolation requirements of a SDIMS.",
                "In Section 5, we detail the implementation of our prototype system.",
                "Section 6 addresses the issue of adaptation to the topological reconfigurations.",
                "In Section 7, we present the evaluation of our system through large-scale simulations and microbenchmarks on real networks.",
                "Section 8 details the related work, and Section 9 summarizes our contribution. 2.",
                "AGGREGATION ABSTRACTION Aggregation is a natural abstraction for a large-scale distributed information system because aggregation provides scalability by allowing a node to view detailed information about the state near it and progressively coarser-grained summaries about progressively larger subsets of a systems data [38].",
                "Our aggregation abstraction is defined across a tree spanning all nodes in the system.",
                "Each physical node in the system is a leaf and each subtree represents a logical group of nodes.",
                "Note that logical groups can correspond to administrative domains (e.g., department or university) or groups of nodes within a domain (e.g., 10 workstations on a LAN in CS department).",
                "An internal non-leaf node, which we call virtual node, is simulated by one or more physical nodes at the leaves of the subtree for which the virtual node is the root.",
                "We describe how to form such trees in a later section.",
                "Each physical node has local data stored as a set of (attributeType, attributeName, value) tuples such as (configuration, numCPUs, 16), (mcast membership, session foo, yes), or (file stored, foo, myIPaddress).",
                "The system associates an aggregation function ftype with each attribute type, and for each level-i subtree Ti in the system, the system defines an aggregate value Vi,type,name for each (at380 tributeType, attributeName) pair as follows.",
                "For a (physical) leaf node T0 at level 0, V0,type,name is the locally stored value for the attribute type and name or NULL if no matching tuple exists.",
                "Then the aggregate value for a level-i subtree Ti is the aggregation function for the type, ftype computed across the aggregate values of each of Tis k children: Vi,type,name = ftype(V0 i−1,type,name,V1 i−1,type,name,...,Vk−1 i−1,type,name).",
                "Although SDIMS allows arbitrary aggregation functions, it is often desirable that these functions satisfy the hierarchical computation property [21]: f(v1,...,vn)= f(f(v1,...,vs1 ), f(vs1+1,...,vs2 ), ..., f(vsk+1,...,vn)), where vi is the value of an attribute at node i.",
                "For example, the average operation, defined as avg(v1,...,vn) = 1/n.∑n i=0 vi, does not satisfy the property.",
                "Instead, if an attribute stores values as tuples (sum,count), the attribute satisfies the hierarchical computation property while still allowing the applications to compute the average from the aggregate sum and count values.",
                "Finally, note that for a large-scale system, it is difficult or impossible to insist that the aggregation value returned by a probe corresponds to the function computed over the current values at the leaves at the instant of the probe.",
                "Therefore our system provides only weak consistency guarantees - specifically eventual consistency as defined in [38]. 3.",
                "FLEXIBILITY A major innovation of our work is enabling flexible aggregate computation and propagation.",
                "The definition of the aggregation abstraction allows considerable flexibility in how, when, and where aggregate values are computed and propagated.",
                "While previous systems [15, 29, 38, 32, 35, 46] implement a single static strategy, we argue that a SDIMS should provide flexible computation and propagation to efficiently support wide variety of applications with diverse requirements.",
                "In order to provide this flexibility, we develop a simple interface that decomposes the aggregation abstraction into three pieces of functionality: install, update, and probe.",
                "This definition of the aggregation abstraction allows our system to provide a continuous spectrum of strategies ranging from lazy aggregate computation and propagation on reads to aggressive immediate computation and propagation on writes.",
                "In Figure 1, we illustrate both extreme strategies and an intermediate strategy.",
                "Under the lazy Update-Local computation and propagation strategy, an update (or write) only affects local state.",
                "Then, a probe (or read) that reads a level-i aggregate value is sent up the tree to the issuing nodes level-i ancestor and then down the tree to the leaves.",
                "The system then computes the desired aggregate value at each layer up the tree until the level-i ancestor that holds the desired value.",
                "Finally, the level-i ancestor sends the result down the tree to the issuing node.",
                "In the other extreme case of the aggressive Update-All immediate computation and propagation on writes [38], when an update occurs, changes are aggregated up the tree, and each new aggregate value is flooded to all of a nodes descendants.",
                "In this case, each level-i node not only maintains the aggregate values for the level-i subtree but also receives and locally stores copies of all of its ancestors level- j ( j > i) aggregation values.",
                "Also, a leaf satisfies a probe for a level-i aggregate using purely local data.",
                "In an intermediate Update-Up strategy, the root of each subtree maintains the subtrees current aggregate value, and when an update occurs, the leaf node updates its local state and passes the update to its parent, and then each successive enclosing subtree updates its aggregate value and passes the new value to its parent.",
                "This strategy satisfies a leafs probe for a level-i aggregate value by sending the probe up to the level-i ancestor of the leaf and then sending the aggregate value down to the leaf.",
                "Finally, notice that other strategies exist.",
                "In general, an Update-Upk-Downj strategy aggregates up to parameter description optional attrType Attribute Type aggrfunc Aggregation Function up How far upward each update is sent (default: all) X down How far downward each aggregate is sent (default: none) X domain Domain restriction (default: none) X expTime Expiry Time Table 1: Arguments for the install operation the kth level and propagates the aggregate values of a node at level l (s.t. l ≤ k) downward for j levels.",
                "A SDIMS must provide a wide range of flexible computation and propagation strategies to applications for it to be a general abstraction.",
                "An application should be able to choose a particular mechanism based on its read-to-write ratio that reduces the bandwidth consumption while attaining the required responsiveness and precision.",
                "Note that the read-to-write ratio of the attributes that applications install vary extensively.",
                "For example, a read-dominated attribute like numCPUs rarely changes in value, while a writedominated attribute like numProcesses changes quite often.",
                "An aggregation strategy like Update-All works well for read-dominated attributes but suffers high bandwidth consumption when applied for write-dominated attributes.",
                "Conversely, an approach like UpdateLocal works well for write-dominated attributes but suffers from unnecessary query latency or imprecision for read-dominated attributes.",
                "SDIMS also allows non-uniform computation and propagation across the aggregation tree with different up and down parameters in different subtrees so that applications can adapt with the spatial and temporal heterogeneity of read and write operations.",
                "With respect to spatial heterogeneity, access patterns may differ for different parts of the tree, requiring different propagation strategies for different parts of the tree.",
                "Similarly with respect to temporal heterogeneity, access patterns may change over time requiring different strategies over time. 3.1 Aggregation API We provide the flexibility described above by splitting the aggregation API into three functions: Install() installs an aggregation function that defines an operation on an attribute type and specifies the update strategy that the function will use, Update() inserts or modifies a nodes local value for an attribute, and Probe() obtains an aggregate value for a specified subtree.",
                "The install interface allows applications to specify the k and j parameters of the Update-Upk-Downj strategy along with the aggregation function.",
                "The update interface invokes the aggregation of an attribute on the tree according to corresponding aggregation functions aggregation strategy.",
                "The probe interface not only allows applications to obtain the aggregated value for a specified tree but also allows a probing node to continuously fetch the values for a specified time, thus enabling an application to adapt to spatial and temporal heterogeneity.",
                "The rest of the section describes these three interfaces in detail. 3.1.1 Install The Install operation installs an aggregation function in the system.",
                "The arguments for this operation are listed in Table 1.",
                "The attrType argument denotes the type of attributes on which this aggregation function is invoked.",
                "Installed functions are soft state that must be periodically renewed or they will be garbage collected at expTime.",
                "The arguments up and down specify the aggregate computation 381 Update Strategy On Update On Probe for Global Aggregate Value On Probe for Level-1 Aggregate Value Update-Local Update-Up Update-All Figure 1: Flexible API parameter description optional attrType Attribute Type attrName Attribute Name mode Continuous or One-shot (default: one-shot) X level Level at which aggregate is sought (default: at all levels) X up How far up to go and re-fetch the value (default: none) X down How far down to go and reaggregate (default: none) X expTime Expiry Time Table 2: Arguments for the probe operation and propagation strategy Update-Upk-Downj.",
                "The domain argument, if present, indicates that the aggregation function should be installed on all nodes in the specified domain; otherwise the function is installed on all nodes in the system. 3.1.2 Update The Update operation takes three arguments attrType, attrName, and value and creates a new (attrType, attrName, value) tuple or updates the value of an old tuple with matching attrType and attrName at a leaf node.",
                "The update interface meshes with installed aggregate computation and propagation strategy to provide flexibility.",
                "In particular, as outlined above and described in detail in Section 5, after a leaf applies an update locally, the update may trigger re-computation of aggregate values up the tree and may also trigger propagation of changed aggregate values down the tree.",
                "Notice that our abstraction associates an aggregation function with only an attrType but lets updates specify an attrName along with the attrType.",
                "This technique helps achieve scalability with respect to nodes and attributes as described in Section 4. 3.1.3 Probe The Probe operation returns the value of an attribute to an application.",
                "The complete argument set for the probe operation is shown in Table 2.",
                "Along with the attrName and the attrType arguments, a level argument specifies the level at which the answers are required for an attribute.",
                "In our implementation we choose to return results at all levels k < l for a level-l probe because (i) it is inexpensive as the nodes traversed for level-l probe also contain level k aggregates for k < l and as we expect the network cost of transmitting the additional information to be small for the small aggregates which we focus and (ii) it is useful as applications can efficiently get several aggregates with a single probe (e.g., for domain-scoped queries as explained in Section 4.2).",
                "Probes with mode set to continuous and with finite expTime enable applications to handle spatial and temporal heterogeneity.",
                "When node A issues a continuous probe at level l for an attribute, then regardless of the up and down parameters, updates for the attribute at any node in As level-l ancestors subtree are aggregated up to level l and the aggregated value is propagated down along the path from the ancestor to A.",
                "Note that continuous mode enables SDIMS to support a distributed sensor-actuator mechanism where a sensor monitors a level-i aggregate with a continuous mode probe and triggers an actuator upon receiving new values for the probe.",
                "The up and down arguments enable applications to perform ondemand fast re-aggregation during reconfigurations, where a forced re-aggregation is done for the corresponding levels even if the aggregated value is available, as we discuss in Section 6.",
                "When present, the up and down arguments are interpreted as described in the install operation. 3.1.4 Dynamic Adaptation At the API level, the up and down arguments in install API can be regarded as hints, since they suggest a computation strategy but do not affect the semantics of an aggregation function.",
                "A SDIMS implementation can dynamically adjust its up/down strategies for an attribute based on its measured read/write frequency.",
                "But a virtual intermediate node needs to know the current up and down propagation values to decide if the local aggregate is fresh in order to answer a probe.",
                "This is the key reason why up and down need to be statically defined at the install time and can not be specified in the update operation.",
                "In dynamic adaptation, we implement a leasebased mechanism where a node issues a lease to a parent or a child denoting that it will keep propagating the updates to that parent or child.",
                "We are currently evaluating different policies to decide when to issue a lease and when to revoke a lease. 4.",
                "SCALABILITY Our design achieves scalability with respect to both nodes and attributes through two key ideas.",
                "First, it carefully defines the aggregation abstraction to mesh well with its underlying scalable DHT system.",
                "Second, it refines the basic DHT abstraction to form an Autonomous DHT (ADHT) to achieve the administrative isolation properties that are crucial to scaling for large real-world systems.",
                "In this section, we describe these two ideas in detail. 4.1 Leveraging DHTs In contrast to previous systems [4, 15, 38, 39, 45], SDIMSs aggregation abstraction specifies both an attribute type and attribute name and associates an aggregation function with a type rather than just specifying and associating a function with a name.",
                "Installing a single function that can operate on many different named attributes matching a type improves scalability for sparse attribute types with large, sparsely-filled name spaces.",
                "For example, to construct a file location service, our interface allows us to install a single function that computes an aggregate value for any named file.",
                "A subtrees aggregate value for (FILELOC, name) would be the ID of a node in the subtree that stores the named file.",
                "Conversely, Astrolabe copes with sparse attributes by having aggregation functions compute sets or lists and suggests that scalability can be improved by representing such sets with Bloom filters [6].",
                "Supporting sparse names within a type provides at least two advantages.",
                "First, when the value associated with a name is updated, only the state associ382 001 010100 000 011 101 111 110 011 111 001 101 000 100 110010 L0 L1 L2 L3 Figure 2: The DHT tree corresponding to key 111 (DHTtree111) and the corresponding aggregation tree. ated with that name needs to be updated and propagated to other nodes.",
                "Second, splitting values associated with different names into different aggregation values allows our system to leverage Distributed Hash Tables (DHTs) to map different names to different trees and thereby spread the functions logical root nodes load and state across multiple physical nodes.",
                "Given this abstraction, scalably mapping attributes to DHTs is straightforward.",
                "DHT systems assign a long, random ID to each node and define an algorithm to route a request for key k to a node rootk such that the union of paths from all nodes forms a tree DHTtreek rooted at the node rootk.",
                "Now, as illustrated in Figure 2, by aggregating an attribute along the aggregation tree corresponding to DHTtreek for k =hash(attribute type, attribute name), different attributes will be aggregated along different trees.",
                "In comparison to a scheme where all attributes are aggregated along a single tree, aggregating along multiple trees incurs lower maximum node stress: whereas in a single aggregation tree approach, the root and the intermediate nodes pass around more messages than leaf nodes, in a DHT-based multi-tree, each node acts as an intermediate aggregation point for some attributes and as a leaf node for other attributes.",
                "Hence, this approach distributes the onus of aggregation across all nodes. 4.2 Administrative Isolation Aggregation trees should provide administrative isolation by ensuring that for each domain, the virtual node at the root of the smallest aggregation subtree containing all nodes of that domain is hosted by a node in that domain.",
                "Administrative isolation is important for three reasons: (i) for security - so that updates and probes flowing in a domain are not accessible outside the domain, (ii) for availability - so that queries for values in a domain are not affected by failures of nodes in other domains, and (iii) for efficiency - so that domain-scoped queries can be simple and efficient.",
                "To provide administrative isolation to aggregation trees, a DHT should satisfy two properties: 1.",
                "Path Locality: Search paths should always be contained in the smallest possible domain. 2.",
                "Path Convergence: Search paths for a key from different nodes in a domain should converge at a node in that domain.",
                "Existing DHTs support path locality [18] or can easily support it by using the domain nearness as the distance metric [7, 17], but they do not guarantee path convergence as those systems try to optimize the search path to the root to reduce response latency.",
                "For example, Pastry [32] uses prefix routing in which each nodes routing table contains one row per hexadecimal digit in the nodeId space where the ith row contains a list of nodes whose nodeIds differ from the current nodes nodeId in the ith digit with one entry for each possible digit value.",
                "Given a routing topology, to route a packet to an arbitrary destination key, a node in Pastry forwards a packet to the node with a nodeId prefix matching the key in at least one more digit than the current node.",
                "If such a node is not known, the current node uses an additional data structure, the leaf set containing 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX 011XX 100XX 101XX 110XX 010XX L1 L0 L2 Figure 3: Example shows how isolation property is violated with original Pastry.",
                "We also show the corresponding aggregation tree. 110XX 010XX 011XX 100XX 101XX univ dep1 dep2 key = 111XX X 011XX 100XX 101XX 110XX 010XX L0 L1 L2 Figure 4: Autonomous DHT satisfying the isolation property.",
                "Also the corresponding aggregation tree is shown.",
                "L immediate higher and lower neighbors in the nodeId space, and forwards the packet to a node with an identical prefix but that is numerically closer to the destination key in the nodeId space.",
                "This process continues until the destination node appears in the leaf set, after which the message is routed directly.",
                "Pastrys expected number of routing steps is logn, where n is the number of nodes, but as Figure 3 illustrates, this algorithm does not guarantee path convergence: if two nodes in a domain have nodeIds that match a key in the same number of bits, both of them can route to a third node outside the domain when routing for that key.",
                "Simple modifications to Pastrys route table construction and key-routing protocols yield an Autonomous DHT (ADHT) that satisfies the path locality and path convergence properties.",
                "As Figure 4 illustrates, whenever two nodes in a domain share the same prefix with respect to a key and no other node in the domain has a longer prefix, our algorithm introduces a virtual node at the boundary of the domain corresponding to that prefix plus the next digit of the key; such a virtual node is simulated by the existing node whose id is numerically closest to the virtual nodes id.",
                "Our ADHTs routing table differs from Pastrys in two ways.",
                "First, each node maintains a separate leaf set for each domain of which it is a part.",
                "Second, nodes use two proximity metrics when populating the routing tables - hierarchical domain proximity is the primary metric and network distance is secondary.",
                "Then, to route a packet to a global root for a key, ADHT routing algorithm uses the routing table and the leaf set entries to route to each successive enclosing domains root (the virtual or real node in the domain matching the key in the maximum number of digits).",
                "Additional details about the ADHT algorithm are available in an extended technical report [44].",
                "Properties.",
                "Maintaining a different leaf set for each administrative hierarchy level increases the number of neighbors that each node tracks to (2b)∗lgb n+c.l from (2b)∗lgb n+c in unmodified Pastry, where b is the number of bits in a digit, n is the number of nodes, c is the leaf set size, and l is the number of domain levels.",
                "Routing requires O(lgbn + l) steps compared to O(lgbn) steps in Pastry; also, each routing hop may be longer than in Pastry because the modified algorithms routing table prefers same-domain nodes over nearby nodes.",
                "We experimentally quantify the additional routing costs in Section 7.",
                "In a large system, the ADHT topology allows domains to im383 A1 A2 B1 ((B1.B.,1), (B.,1),(.,1)) ((B1.B.,1), (B.,1),(.,1)) L2 L1 L0 ((B1.B.,1), (B.,1),(.,3)) ((A1.A.,1), (A.,2),(.,2)) ((A1.A.,1), (A.,1),(.,1)) ((A2.A.,1), (A.,1),(.,1)) Figure 5: Example for domain-scoped queries prove security for sensitive attribute types by installing them only within a specified domain.",
                "Then, aggregation occurs entirely within the domain and a node external to the domain can neither observe nor affect the updates and aggregation computations of the attribute type.",
                "Furthermore, though we have not implemented this feature in the prototype, the ADHT topology would also support domainrestricted probes that could ensure that no one outside of a domain can observe a probe for data stored within the domain.",
                "The ADHT topology also enhances availability by allowing the common case of probes for data within a domain to depend only on a domains nodes.",
                "This, for example, allows a domain that becomes disconnected from the rest of the Internet to continue to answer queries for local data.",
                "Aggregation trees that provide administrative isolation also enable the definition of simple and efficient domain-scoped aggregation functions to support queries like what is the average load on machines in domain X?",
                "For example, consider an aggregation function to count the number of machines in an example system with three machines illustrated in Figure 5.",
                "Each leaf node l updates attribute NumMachines with a value vl containing a set of tuples of form (Domain, Count) for each domain of which the node is a part.",
                "In the example, the node A1 with name A1.A. performs an update with the value ((A1.A.,1),(A.,1),(.,1)).",
                "An aggregation function at an internal virtual node hosted on node N with child set C computes the aggregate as a set of tuples: for each domain D that N is part of, form a tuple (D,∑c∈C(count|(D,count) ∈ vc)).",
                "This computation is illustrated in the Figure 5.",
                "Now a query for NumMachines with level set to MAX will return the aggregate values at each intermediate virtual node on the path to the root as a set of tuples (tree level, aggregated value) from which it is easy to extract the count of machines at each enclosing domain.",
                "For example, A1 would receive ((2, ((B1.B.,1),(B.,1),(.,3))), (1, ((A1.A.,1),(A.,2),(.,2))), (0, ((A1.A.,1),(A.,1),(.,1)))).",
                "Note that supporting domain-scoped queries would be less convenient and less efficient if aggregation trees did not conform to the systems administrative structure.",
                "It would be less efficient because each intermediate virtual node will have to maintain a list of all values at the leaves in its subtree along with their names and it would be less convenient as applications that need an aggregate for a domain will have to pick values of nodes in that domain from the list returned by a probe and perform computation. 5.",
                "PROTOTYPE IMPLEMENTATION The internal design of our SDIMS prototype comprises of two layers: the Autonomous DHT (ADHT) layer manages the overlay topology of the system and the Aggregation Management Layer (AML) maintains attribute tuples, performs aggregations, stores and propagates aggregate values.",
                "Given the ADHT construction described in Section 4.2, each node implements an Aggregation Management Layer (AML) to support the flexible API described in Section 3.",
                "In this section, we describe the internal state and operation of the AML layer of a node in the system. local MIB MIBs ancestor reduction MIB (level 1)MIBs ancestor MIB from child 0X... MIB from child 0X... Level 2 Level 1 Level 3 Level 0 1XXX... 10XX... 100X... From parents0X.. To parent 0X... −− aggregation functions From parents To parent 10XX... 1X.. 1X.. 1X.. To parent 11XX... Node Id: (1001XXX) 1001X.. 100X.. 10X.. 1X..",
                "Virtual Node Figure 6: Example illustrating the data structures and the organization of them at a node.",
                "We refer to a store of (attribute type, attribute name, value) tuples as a Management Information Base or MIB, following the terminology from Astrolabe [38] and SNMP [34].",
                "We refer an (attribute type, attribute name) tuple as an attribute key.",
                "As Figure 6 illustrates, each physical node in the system acts as several virtual nodes in the AML: a node acts as leaf for all attribute keys, as a level-1 subtree root for keys whose hash matches the nodes ID in b prefix bits (where b is the number of bits corrected in each step of the ADHTs routing scheme), as a level-i subtree root for attribute keys whose hash matches the nodes ID in the initial i ∗ b bits, and as the systems global root for attribute keys whose hash matches the nodes ID in more prefix bits than any other node (in case of a tie, the first non-matching bit is ignored and the comparison is continued [46]).",
                "To support hierarchical aggregation, each virtual node at the root of a level-i subtree maintains several MIBs that store (1) child MIBs containing raw aggregate values gathered from children, (2) a reduction MIB containing locally aggregated values across this raw information, and (3) an ancestor MIB containing aggregate values scattered down from ancestors.",
                "This basic strategy of maintaining child, reduction, and ancestor MIBs is based on Astrolabe [38], but our structured propagation strategy channels information that flows up according to its attribute key and our flexible propagation strategy only sends child updates up and ancestor aggregate results down as far as specified by the attribute keys aggregation function.",
                "Note that in the discussion below, for ease of explanation, we assume that the routing protocol is correcting single bit at a time (b = 1).",
                "Our system, built upon Pastry, handles multi-bit correction (b = 4) and is a simple extension to the scheme described here.",
                "For a given virtual node ni at level i, each child MIB contains the subset of a childs reduction MIB that contains tuples that match nis node ID in i bits and whose up aggregation function attribute is at least i.",
                "These local copies make it easy for a node to recompute a level-i aggregate value when one childs input changes.",
                "Nodes maintain their child MIBs in stable storage and use a simplified version of the Bayou log exchange protocol (sans conflict detection and resolution) for synchronization after disconnections [26].",
                "Virtual node ni at level i maintains a reduction MIB of tuples with a tuple for each key present in any child MIB containing the attribute type, attribute name, and output of the attribute types aggregate functions applied to the childrens tuples.",
                "A virtual node ni at level i also maintains an ancestor MIB to store the tuples containing attribute key and a list of aggregate values at different levels scattered down from ancestors.",
                "Note that the 384 list for a key might contain multiple aggregate values for a same level but aggregated at different nodes (see Figure 4).",
                "So, the aggregate values are tagged not only with level information, but are also tagged with ID of the node that performed the aggregation.",
                "Level-0 differs slightly from other levels.",
                "Each level-0 leaf node maintains a local MIB rather than maintaining child MIBs and a reduction MIB.",
                "This local MIB stores information about the local nodes state inserted by local applications via update() calls.",
                "We envision various sensor programs and applications insert data into local MIB.",
                "For example, one program might monitor local configuration and perform updates with information such as total memory, free memory, etc., A distributed file system might perform update for each file stored on the local node.",
                "Along with these MIBs, a virtual node maintains two other tables: an aggregation function table and an outstanding probes table.",
                "An aggregation function table contains the aggregation function and installation arguments (see Table 1) associated with an attribute type or an attribute type and name.",
                "Each aggregate function is installed on all nodes in a domains subtree, so the aggregate function table can be thought of as a special case of the ancestor MIB with domain functions always installed up to a root within a specified domain and down to all nodes within the domain.",
                "The outstanding probes table maintains temporary information regarding in-progress probes.",
                "Given these data structures, it is simple to support the three API functions described in Section 3.1.",
                "Install The Install operation (see Table 1) installs on a domain an aggregation function that acts on a specified attribute type.",
                "Execution of an install operation for function aggrFunc on attribute type attrType proceeds in two phases: first the install request is passed up the ADHT tree with the attribute key (attrType, null) until it reaches the root for that key within the specified domain.",
                "Then, the request is flooded down the tree and installed on all intermediate and leaf nodes.",
                "Update When a level i virtual node receives an update for an attribute from a child below: it first recomputes the level-i aggregate value for the specified key, stores that value in its reduction MIB and then, subject to the functions up and domain parameters, passes the updated value to the appropriate parent based on the attribute key.",
                "Also, the level-i (i ≥ 1) virtual node sends the updated level-i aggregate to all its children if the functions down parameter exceeds zero.",
                "Upon receipt of a level-i aggregate from a parent, a level k virtual node stores the value in its ancestor MIB and, if k ≥ i−down, forwards this aggregate to its children.",
                "Probe A Probe collects and returns the aggregate value for a specified attribute key for a specified level of the tree.",
                "As Figure 1 illustrates, the system satisfies a probe for a level-i aggregate value using a four-phase protocol that may be short-circuited when updates have previously propagated either results or partial results up or down the tree.",
                "In phase 1, the route probe phase, the system routes the probe up the attribute keys tree to either the root of the level-i subtree or to a node that stores the requested value in its ancestor MIB.",
                "In the former case, the system proceeds to phase 2 and in the latter it skips to phase 4.",
                "In phase 2, the probe scatter phase, each node that receives a probe request sends it to all of its children unless the nodes reduction MIB already has a value that matches the probes attribute key, in which case the node initiates phase 3 on behalf of its subtree.",
                "In phase 3, the probe aggregation phase, when a node receives values for the specified key from each of its children, it executes the aggregate function on these values and either (a) forwards the result to its parent (if its level is less than i) or (b) initiates phase 4 (if it is at level i).",
                "Finally, in phase 4, the aggregate routing phase the aggregate value is routed down to the node that requested it.",
                "Note that in the extreme case of a function installed with up = down = 0, a level-i probe can touch all nodes in a level-i subtree while in the opposite extreme case of a function installed with up = down = ALL, probe is a completely local operation at a leaf.",
                "For probes that include phases 2 (probe scatter) and 3 (probe aggregation), an issue is how to decide when a node should stop waiting for its children to respond and send up its current aggregate value.",
                "A node stops waiting for its children when one of three conditions occurs: (1) all children have responded, (2) the ADHT layer signals one or more reconfiguration events that mark all children that have not yet responded as unreachable, or (3) a watchdog timer for the request fires.",
                "The last case accounts for nodes that participate in the ADHT protocol but that fail at the AML level.",
                "At a virtual node, continuous probes are handled similarly as one-shot probes except that such probes are stored in the outstanding probe table for a time period of expTime specified in the probe.",
                "Thus each update for an attribute triggers re-evaluation of continuous probes for that attribute.",
                "We implement a lease-based mechanism for dynamic adaptation.",
                "A level-l virtual node for an attribute can issue the lease for levell aggregate to a parent or a child only if up is greater than l or it has leases from all its children.",
                "A virtual node at level l can issue the lease for level-k aggregate for k > l to a child only if down≥ k −l or if it has the lease for that aggregate from its parent.",
                "Now a probe for level-k aggregate can be answered by level-l virtual node if it has a valid lease, irrespective of the up and down values.",
                "We are currently designing different policies to decide when to issue a lease and when to revoke a lease and are also evaluating them with the above mechanism.",
                "Our current prototype does not implement access control on install, update, and probe operations but we plan to implement Astrolabes [38] certificate-based restrictions.",
                "Also our current prototype does not restrict the resource consumption in executing the aggregation functions; but, techniques from research on resource management in server systems and operating systems [2, 3] can be applied here. 6.",
                "ROBUSTNESS In large scale systems, reconfigurations are common.",
                "Our two main principles for robustness are to guarantee (i) read availability - probes complete in finite time, and (ii) eventual consistency - updates by a live node will be visible to probes by connected nodes in finite time.",
                "During reconfigurations, a probe might return a stale value for two reasons.",
                "First, reconfigurations lead to incorrectness in the previous aggregate values.",
                "Second, the nodes needed for aggregation to answer the probe become unreachable.",
                "Our system also provides two hooks that applications can use for improved end-to-end robustness in the presence of reconfigurations: (1) Ondemand re-aggregation and (2) application controlled replication.",
                "Our system handles reconfigurations at two levels - adaptation at the ADHT layer to ensure connectivity and adaptation at the AML layer to ensure access to the data in SDIMS. 6.1 ADHT Adaptation Our ADHT layer adaptation algorithm is same as Pastrys adaptation algorithm [32] - the leaf sets are repaired as soon as a reconfiguration is detected and the routing table is repaired lazily.",
                "Note that maintaining extra leaf sets does not degrade the fault-tolerance property of the original Pastry; indeed, it enhances the resilience of ADHTs to failures by providing additional routing links.",
                "Due to redundancy in the leaf sets and the routing table, updates can be routed towards their root nodes successfully even during failures. 385 Reconfig reconfig notices DHT partial DHT complete DHT ends Lazy Time Data 3 7 81 2 4 5 6starts Lazy Data starts Lazy Data starts Lazy Data repairrepair reaggr reaggr reaggr reaggr happens Figure 7: Default lazy data re-aggregation time line Also note that the administrative isolation property satisfied by our ADHT algorithm ensures that the reconfigurations in a level i domain do not affect the probes for level i in a sibling domain. 6.2 AML Adaptation Broadly, we use two types of strategies for AML adaptation in the face of reconfigurations: (1) Replication in time as a fundamental baseline strategy, and (2) Replication in space as an additional performance optimization that falls back on replication in time when the system runs out of replicas.",
                "We provide two mechanisms for replication in time.",
                "First, lazy re-aggregation propagates already received updates to new children or new parents in a lazy fashion over time.",
                "Second, applications can reduce the probability of probe response staleness during such repairs through our flexible API with appropriate setting of the down parameter.",
                "Lazy Re-aggregation: The DHT layer informs the AML layer about reconfigurations in the network using the following three function calls - newParent, failedChild, and newChild.",
                "On newParent(parent, prefix), all probes in the outstanding-probes table corresponding to prefix are re-evaluated.",
                "If parent is not null, then aggregation functions and already existing data are lazily transferred in the background.",
                "Any new updates, installs, and probes for this prefix are sent to the parent immediately.",
                "On failedChild(child, prefix), the AML layer marks the child as inactive and any outstanding probes that are waiting for data from this child are re-evaluated.",
                "On newChild(child, prefix), the AML layer creates space in its data structures for this child.",
                "Figure 7 shows the time line for the default lazy re-aggregation upon reconfiguration.",
                "Probes initiated between points 1 and 2 and that are affected by reconfigurations are reevaluated by AML upon detecting the reconfiguration.",
                "Probes that complete or start between points 2 and 8 may return stale answers.",
                "On-demand Re-aggregation: The default lazy aggregation scheme lazily propagates the old updates in the system.",
                "Additionally, using up and down knobs in the Probe API, applications can force on-demand fast re-aggregation of updates to avoid staleness in the face of reconfigurations.",
                "In particular, if an application detects or suspects an answer as stale, then it can re-issue the probe increasing the up and down parameters to force the refreshing of the cached data.",
                "Note that this strategy will be useful only after the DHT adaptation is completed (Point 6 on the time line in Figure 7).",
                "Replication in Space: Replication in space is more challenging in our system than in a DHT file location application because replication in space can be achieved easily in the latter by just replicating the root nodes contents.",
                "In our system, however, all internal nodes have to be replicated along with the root.",
                "In our system, applications control replication in space using up and down knobs in the Install API; with large up and down values, aggregates at the intermediate virtual nodes are propagated to more nodes in the system.",
                "By reducing the number of nodes that have to be accessed to answer a probe, applications can reduce the probability of incorrect results occurring due to the failure of nodes that do not contribute to the aggregate.",
                "For example, in a file location application, using a non-zero positive down parameter ensures that a files global aggregate is replicated on nodes other than the root. 0.1 1 10 100 1000 10000 0.0001 0.01 1 100 10000 Avg.numberofmessagesperoperation Read to Write ratio Update-All Up=ALL, Down=9 Up=ALL, Down=6 Update-Up Update-Local Up=2, Down=0 Up=5, Down=0 Figure 8: Flexibility of our approach.",
                "With different UP and DOWN values in a network of 4096 nodes for different readwrite ratios.",
                "Probes for the file location can then be answered without accessing the root; hence they are not affected by the failure of the root.",
                "However, note that this technique is not appropriate in some cases.",
                "An aggregated value in file location system is valid as long as the node hosting the file is active, irrespective of the status of other nodes in the system; whereas an application that counts the number of machines in a system may receive incorrect results irrespective of the replication.",
                "If reconfigurations are only transient (like a node temporarily not responding due to a burst of load), the replicated aggregate closely or correctly resembles the current state. 7.",
                "EVALUATION We have implemented a prototype of SDIMS in Java using the FreePastry framework [32] and performed large-scale simulation experiments and micro-benchmark experiments on two real networks: 187 machines in the department and 69 machines on the PlanetLab [27] testbed.",
                "In all experiments, we use static up and down values and turn off dynamic adaptation.",
                "Our evaluation supports four main conclusions.",
                "First, flexible API provides different propagation strategies that minimize communication resources at different read-to-write ratios.",
                "For example, in our simulation we observe Update-Local to be efficient for read-to-write ratios below 0.0001, Update-Up around 1, and Update-All above 50000.",
                "Second, our system is scalable with respect to both nodes and attributes.",
                "In particular, we find that the maximum node stress in our system is an order lower than observed with an Update-All, gossiping approach.",
                "Third, in contrast to unmodified Pastry which violates path convergence property in upto 14% cases, our system conforms to the property.",
                "Fourth, the system is robust to reconfigurations and adapts to failures with in a few seconds. 7.1 Simulation Experiments Flexibility and Scalability: A major innovation of our system is its ability to provide flexible computation and propagation of aggregates.",
                "In Figure 8, we demonstrate the flexibility exposed by the aggregation API explained in Section 3.",
                "We simulate a system with 4096 nodes arranged in a domain hierarchy with branching factor (bf) of 16 and install several attributes with different up and down parameters.",
                "We plot the average number of messages per operation incurred for a wide range of read-to-write ratios of the operations for different attributes.",
                "Simulations with other sizes of networks with different branching factors reveal similar results.",
                "This graph clearly demonstrates the benefit of supporting a wide range of computation and propagation strategies.",
                "Although having a small UP 386 1 10 100 1000 10000 100000 1e+06 1e+07 1 10 100 1000 10000 100000 MaximumNodeStress Number of attributes installed Gossip 256 Gossip 4096 Gossip 65536 DHT 256 DHT 4096 DHT 65536 Figure 9: Max node stress for a gossiping approach vs. ADHT based approach for different number of nodes with increasing number of sparse attributes. value is efficient for attributes with low read-to-write ratios (write dominated applications), the probe latency, when reads do occur, may be high since the probe needs to aggregate the data from all the nodes that did not send their aggregate up.",
                "Conversely, applications that wish to improve probe overheads or latencies can increase their UP and DOWN propagation at a potential cost of increase in write overheads.",
                "Compared to an existing Update-all single aggregation tree approach [38], scalability in SDIMS comes from (1) leveraging DHTs to form multiple aggregation trees that split the load across nodes and (2) flexible propagation that avoids propagation of all updates to all nodes.",
                "Figure 9 demonstrates the SDIMSs scalability with nodes and attributes.",
                "For this experiment, we build a simulator to simulate both Astrolabe [38] (a gossiping, Update-All approach) and our system for an increasing number of sparse attributes.",
                "Each attribute corresponds to the membership in a multicast session with a small number of participants.",
                "For this experiment, the session size is set to 8, the branching factor is set to 16, the propagation mode for SDIMS is Update-Up, and the participant nodes perform continuous probes for the global aggregate value.",
                "We plot the maximum node stress (in terms of messages) observed in both schemes for different sized networks with increasing number of sessions when the participant of each session performs an update operation.",
                "Clearly, the DHT based scheme is more scalable with respect to attributes than an Update-all gossiping scheme.",
                "Observe that at some constant number of attributes, as the number of nodes increase in the system, the maximum node stress increases in the gossiping approach, while it decreases in our approach as the load of aggregation is spread across more nodes.",
                "Simulations with other session sizes (4 and 16) yield similar results.",
                "Administrative Hierarchy and Robustness: Although the routing protocol of ADHT might lead to an increased number of hops to reach the root for a key as compared to original Pastry, the algorithm conforms to the path convergence and locality properties and thus provides administrative isolation property.",
                "In Figure 10, we quantify the increased path length by comparisons with unmodified Pastry for different sized networks with different branching factors of the domain hierarchy tree.",
                "To quantify the path convergence property, we perform simulations with a large number of probe pairs - each pair probing for a random key starting from two randomly chosen nodes.",
                "In Figure 11, we plot the percentage of probe pairs for unmodified pastry that do not conform to the path convergence property.",
                "When the branching factor is low, the domain hierarchy tree is deeper resulting in a large difference between 0 1 2 3 4 5 6 7 10 100 1000 10000 100000 PathLength Number of Nodes ADHT bf=4 ADHT bf=16 ADHT bf=64 PASTRY bf=4,16,64 Figure 10: Average path length to root in Pastry versus ADHT for different branching factors.",
                "Note that all lines corresponding to Pastry overlap. 0 2 4 6 8 10 12 14 16 10 100 1000 10000 100000 Percentageofviolations Number of Nodes bf=4 bf=16 bf=64 Figure 11: Percentage of probe pairs whose paths to the root did not conform to the path convergence property with Pastry.",
                "U pdate-All U pdate-U p U pdate-Local 0 200 400 600 800 Latency(inms) Average Latency U pdate-All U pdate-U p U pdate-Local 0 1000 2000 3000 Latency(inms) Average Latency (a) (b) Figure 12: Latency of probes for aggregate at global root level with three different modes of aggregate propagation on (a) department machines, and (b) PlanetLab machines Pastry and ADHT in the average path length; but it is at these small domain sizes, that the path convergence fails more often with the original Pastry. 7.2 Testbed experiments We run our prototype on 180 department machines (some machines ran multiple node instances, so this configuration has a total of 283 SDIMS nodes) and also on 69 machines of the PlanetLab [27] testbed.",
                "We measure the performance of our system with two micro-benchmarks.",
                "In the first micro-benchmark, we install three aggregation functions of types Update-Local, Update-Up, and Update-All, perform update operation on all nodes for all three aggregation functions, and measure the latencies incurred by probes for the global aggregate from all nodes in the system.",
                "Figure 12 387 0 20 40 60 80 100 120 140 0 5 10 15 20 25 2700 2720 2740 2760 2780 2800 2820 2840 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 13: Micro-benchmark on department network showing the behavior of the probes from a single node when failures are happening at some other nodes.",
                "All 283 nodes assign a value of 10 to the attribute. 10 100 1000 10000 100000 0 50 100 150 200 250 300 350 400 450 500 500 550 600 650 700 Latency(inms) ValuesObserved Time(in sec) Values latency Node Killed Figure 14: Probe performance during failures on 69 machines of PlanetLab testbed shows the observed latencies for both testbeds.",
                "Notice that the latency in Update-Local is high compared to the Update-UP policy.",
                "This is because latency in Update-Local is affected by the presence of even a single slow machine or a single machine with a high latency network connection.",
                "In the second benchmark, we examine robustness.",
                "We install one aggregation function of type Update-Up that performs sum operation on an integer valued attribute.",
                "Each node updates the attribute with the value 10.",
                "Then we monitor the latencies and results returned on the probe operation for global aggregate on one chosen node, while we kill some nodes after every few probes.",
                "Figure 13 shows the results on the departmental testbed.",
                "Due to the nature of the testbed (machines in a department), there is little change in the latencies even in the face of reconfigurations.",
                "In Figure 14, we present the results of the experiment on PlanetLab testbed.",
                "The root node of the aggregation tree is terminated after about 275 seconds.",
                "There is a 5X increase in the latencies after the death of the initial root node as a more distant node becomes the root node after repairs.",
                "In both experiments, the values returned on probes start reflecting the correct situation within a short time after the failures.",
                "From both the testbed benchmark experiments and the simulation experiments on flexibility and scalability, we conclude that (1) the flexibility provided by SDIMS allows applications to tradeoff read-write overheads (Figure 8), read latency, and sensitivity to slow machines (Figure 12), (2) a good default aggregation strategy is Update-Up which has moderate overheads on both reads and writes (Figure 8), has moderate read latencies (Figure 12), and is scalable with respect to both nodes and attributes (Figure 9), and (3) small domain sizes are the cases where DHT algorithms fail to provide path convergence more often and SDIMS ensures path convergence with only a moderate increase in path lengths (Figure 11). 7.3 Applications SDIMS is designed as a general distributed monitoring and control infrastructure for a broad range of applications.",
                "Above, we discuss some simple microbenchmarks including a multicast membership service and a calculate-sum function.",
                "Van Renesse et al. [38] provide detailed examples of how such a service can be used for a peer-to-peer caching directory, a data-diffusion service, a publishsubscribe system, barrier synchronization, and voting.",
                "Additionally, we have initial experience using SDIMS to construct two significant applications: the control plane for a large-scale distributed file system [12] and a network monitor for identifying heavy hitters that consume excess resources.",
                "Distributed file system control: The PRACTI (Partial Replication, Arbitrary Consistency, Topology Independence) replication system provides a set of mechanisms for data replication over which arbitrary control policies can be layered.",
                "We use SDIMS to provide several key functions in order to create a file system over the lowlevel PRACTI mechanisms.",
                "First, nodes use SDIMS as a directory to handle read misses.",
                "When a node n receives an object o, it updates the (ReadDir, o) attribute with the value n; when n discards o from its local store, it resets (ReadDir, o) to NULL.",
                "At each virtual node, the ReadDir aggregation function simply selects a random non-null child value (if any) and we use the Update-Up policy for propagating updates.",
                "Finally, to locate a nearby copy of an object o, a node n1 issues a series of probe requests for the (ReadDir, o) attribute, starting with level = 1 and increasing the level value with each repeated probe request until a non-null node ID n2 is returned. n1 then sends a demand read request to n2, and n2 sends the data if it has it.",
                "Conversely, if n2 does not have a copy of o, it sends a nack to n1, and n1 issues a retry probe with the down parameter set to a value larger than used in the previous probe in order to force on-demand re-aggregation, which will yield a fresher value for the retry.",
                "Second, nodes subscribe to invalidations and updates to interest sets of files, and nodes use SDIMS to set up and maintain perinterest-set network-topology-sensitive spanning trees for propagating this information.",
                "To subscribe to invalidations for interest set i, a node n1 first updates the (Inval, i) attribute with its identity n1, and the aggregation function at each virtual node selects one non-null child value.",
                "Finally, n1 probes increasing levels of the the (Inval, i) attribute until it finds the first node n2 = n1; n1 then uses n2 as its parent in the spanning tree. n1 also issues a continuous probe for this attribute at this level so that it is notified of any change to its spanning tree parent.",
                "Spanning trees for streams of pushed updates are maintained in a similar manner.",
                "In the future, we plan to use SDIMS for at least two additional services within this replication system.",
                "First, we plan to use SDIMS to track the read and write rates to different objects; prefetch algorithms will use this information to prioritize replication [40, 41].",
                "Second, we plan to track the ranges of invalidation sequence numbers seen by each node for each interest set in order to augment the spanning trees described above with additional hole filling to allow nodes to locate specific invalidations they have missed.",
                "Overall, our initial experience with using SDIMS for the PRACTII replication system suggests that (1) the general aggregation interface provided by SDIMS simplifies the construction of distributed applications-given the low-level PRACTI mechanisms, 388 we were able to construct a basic file system that uses SDIMS for several distinct control tasks in under two weeks and (2) the weak consistency guarantees provided by SDIMS meet the requirements of this application-each nodes controller effectively treats information from SDIMS as hints, and if a contacted node does not have the needed data, the controller retries, using SDIMS on-demand reaggregation to obtain a fresher hint.",
                "Distributed heavy hitter problem: The goal of the heavy hitter problem is to identify network sources, destinations, or protocols that account for significant or unusual amounts of traffic.",
                "As noted by Estan et al. [13], this information is useful for a variety of applications such as intrusion detection (e.g., port scanning), denial of service detection, worm detection and tracking, fair network allocation, and network maintenance.",
                "Significant work has been done on developing high-performance stream-processing algorithms for identifying heavy hitters at one router, but this is just a first step; ideally these applications would like not just one routers views of the heavy hitters but an aggregate view.",
                "We use SDIMS to allow local information about heavy hitters to be pooled into a view of global heavy hitters.",
                "For each destination IP address IPx, a node updates the attribute (DestBW,IPx) with the number of bytes sent to IPx in the last time window.",
                "The aggregation function for attribute type DestBW is installed with the Update-UP strategy and simply adds the values from child nodes.",
                "Nodes perform continuous probe for global aggregate of the attribute and raise an alarm when the global aggregate value goes above a specified limit.",
                "Note that only nodes sending data to a particular IP address perform probes for the corresponding attribute.",
                "Also note that techniques from [25] can be extended to hierarchical case to tradeoff precision for communication bandwidth. 8.",
                "RELATED WORK The aggregation abstraction we use in our work is heavily influenced by the Astrolabe [38] project.",
                "Astrolabe adopts a PropagateAll and unstructured gossiping techniques to attain robustness [5].",
                "However, any gossiping scheme requires aggressive replication of the aggregates.",
                "While such aggressive replication is efficient for read-dominated attributes, it incurs high message cost for attributes with a small read-to-write ratio.",
                "Our approach provides a flexible API for applications to set propagation rules according to their read-to-write ratios.",
                "Other closely related projects include Willow [39], Cone [4], DASIS [1], and SOMO [45].",
                "Willow, DASIS and SOMO build a single tree for aggregation.",
                "Cone builds a tree per attribute and requires a total order on the attribute values.",
                "Several academic [15, 21, 42] and commercial [37] distributed monitoring systems have been designed to monitor the status of large networked systems.",
                "Some of them are centralized where all the monitoring data is collected and analyzed at a central host.",
                "Ganglia [15, 23] uses a hierarchical system where the attributes are replicated within clusters using multicast and then cluster aggregates are further aggregated along a single tree.",
                "Sophia [42] is a distributed monitoring system designed with a declarative logic programming model where the location of query execution is both explicit in the language and can be calculated during evaluation.",
                "This research is complementary to our work.",
                "TAG [21] collects information from a large number of sensors along a single tree.",
                "The observation that DHTs internally provide a scalable forest of reduction trees is not new.",
                "Plaxton et al.s [28] original paper describes not a DHT, but a system for hierarchically aggregating and querying object location data in order to route requests to nearby copies of objects.",
                "Many systems-building upon both Plaxtons bit-correcting strategy [32, 46] and upon other strategies [24, 29, 35]-have chosen to hide this power and export a simple and general distributed hash table abstraction as a useful building block for a broad range of distributed applications.",
                "Some of these systems internally make use of the reduction forest not only for routing but also for caching [32], but for simplicity, these systems do not generally export this powerful functionality in their external interface.",
                "Our goal is to develop and expose the internal reduction forest of DHTs as a similarly general and useful abstraction.",
                "Although object location is a predominant target application for DHTs, several other applications like multicast [8, 9, 33, 36] and DNS [11] are also built using DHTs.",
                "All these systems implicitly perform aggregation on some attribute, and each one of them must be designed to handle any reconfigurations in the underlying DHT.",
                "With the aggregation abstraction provided by our system, designing and building of such applications becomes easier.",
                "Internal DHT trees typically do not satisfy domain locality properties required in our system.",
                "Castro et al. [7] and Gummadi et al. [17] point out the importance of path convergence from the perspective of achieving efficiency and investigate the performance of Pastry and other DHT algorithms, respectively.",
                "SkipNet [18] provides domain restricted routing where a key search is limited to the specified domain.",
                "This interface can be used to ensure path convergence by searching in the lowest domain and moving up to the next domain when the search reaches the root in the current domain.",
                "Although this strategy guarantees path convergence, it loses the aggregation tree abstraction property of DHTs as the domain constrained routing might touch a node more than once (as it searches forward and then backward to stay within a domain). 9.",
                "CONCLUSIONS This paper presents a Scalable Distributed Information Management System (SDIMS) that aggregates information in large-scale networked systems and that can serve as a basic building block for a broad range of applications.",
                "For large scale systems, hierarchical aggregation is a fundamental abstraction for scalability.",
                "We build our system by extending ideas from Astrolabe and DHTs to achieve (i) scalability with respect to both nodes and attributes through a new aggregation abstraction that helps leverage DHTs internal trees for aggregation, (ii) flexibility through a simple API that lets applications control propagation of reads and writes, (iii) administrative isolation through simple augmentations of current DHT algorithms, and (iv) robustness to node and network reconfigurations through lazy reaggregation, on-demand reaggregation, and tunable spatial replication.",
                "Acknowlegements We are grateful to J.C. Browne, Robert van Renessee, Amin Vahdat, Jay Lepreau, and the anonymous reviewers for their helpful comments on this work. 10.",
                "REFERENCES [1] K. Albrecht, R. Arnold, M. Gahwiler, and R. Wattenhofer.",
                "Join and Leave in Peer-to-Peer Systems: The DASIS approach.",
                "Technical report, CS, ETH Zurich, 2003. [2] G. Back, W. H. Hsieh, and J. Lepreau.",
                "Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java.",
                "In Proc.",
                "OSDI, Oct 2000. [3] G. Banga, P. Druschel, and J.",
                "Mogul.",
                "Resource Containers: A New Facility for Resource Management in Server Systems.",
                "In OSDI99, Feb. 1999. [4] R. Bhagwan, P. Mahadevan, G. Varghese, and G. M. Voelker.",
                "Cone: A Distributed Heap-Based Approach to Resource Selection.",
                "Technical Report CS2004-0784, UCSD, 2004. 389 [5] K. P. Birman.",
                "The Surprising Power of Epidemic Communication.",
                "In Proceedings of FuDiCo, 2003. [6] B. Bloom.",
                "Space/time tradeoffs in hash coding with allowable errors.",
                "Comm. of the ACM, 13(7):422-425, 1970. [7] M. Castro, P. Druschel, Y. C. Hu, and A. Rowstron.",
                "Exploiting Network Proximity in Peer-to-Peer Overlay Networks.",
                "Technical Report MSR-TR-2002-82, MSR. [8] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron, and A. Singh.",
                "SplitStream: High-bandwidth Multicast in a Cooperative Environment.",
                "In SOSP, 2003. [9] M. Castro, P. Druschel, A.-M. Kermarrec, and A. Rowstron.",
                "SCRIBE: A Large-scale and Decentralised Application-level Multicast Infrastructure.",
                "IEEE JSAC (Special issue on Network Support for Multicast Communications), 2002. [10] J.",
                "Challenger, P. Dantzig, and A. Iyengar.",
                "A scalable and highly available system for serving dynamic data at frequently accessed web sites.",
                "In In Proceedings of ACM/IEEE, Supercomputing 98 (SC98), Nov. 1998. [11] R. Cox, A. Muthitacharoen, and R. T. Morris.",
                "Serving DNS using a Peer-to-Peer Lookup Service.",
                "In IPTPS, 2002. [12] M. Dahlin, L. Gao, A. Nayate, A. Venkataramani, P. Yalagandula, and J. Zheng.",
                "PRACTI replication for large-scale systems.",
                "Technical Report TR-04-28, The University of Texas at Austin, 2004. [13] C. Estan, G. Varghese, and M. Fisk.",
                "Bitmap algorithms for counting active flows on high speed links.",
                "In Internet Measurement Conference 2003, 2003. [14] Y. Fu, J.",
                "Chase, B. Chun, S. Schwab, and A. Vahdat.",
                "SHARP: An architecture for secure resource peering.",
                "In Proc.",
                "SOSP, Oct. 2003. [15] Ganglia: Distributed Monitoring and Execution System. http://ganglia.sourceforge.net. [16] S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu.",
                "What Can Peer-to-Peer Do for Databases, and Vice Versa?",
                "In Proceedings of the WebDB, 2001. [17] K. Gummadi, R. Gummadi, S. D. Gribble, S. Ratnasamy, S. Shenker, and I. Stoica.",
                "The Impact of DHT Routing Geometry on Resilience and Proximity.",
                "In SIGCOMM, 2003. [18] N. J.",
                "A. Harvey, M. B. Jones, S. Saroiu, M. Theimer, and A. Wolman.",
                "SkipNet: A Scalable Overlay Network with Practical Locality Properties.",
                "In USITS, March 2003. [19] R. Huebsch, J. M. Hellerstein, N. Lanham, B. T. Loo, S. Shenker, and I. Stoica.",
                "Querying the Internet with PIER.",
                "In Proceedings of the VLDB Conference, May 2003. [20] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed diffusion: a scalable and robust communication paradigm for sensor networks.",
                "In MobiCom, 2000. [21] S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGgregation Service for ad-hoc Sensor Networks.",
                "In OSDI, 2002. [22] D. Malkhi.",
                "Dynamic Lookup Networks.",
                "In FuDiCo, 2002. [23] M. L. Massie, B. N. Chun, and D. E. Culler.",
                "The ganglia distributed monitoring system: Design, implementation, and experience.",
                "In submission. [24] P. Maymounkov and D. Mazieres.",
                "Kademlia: A Peer-to-peer Information System Based on the XOR Metric.",
                "In Proceesings of the IPTPS, March 2002. [25] C. Olston and J. Widom.",
                "Offering a precision-performance tradeoff for aggregation queries over replicated data.",
                "In VLDB, pages 144-155, Sept. 2000. [26] K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and A. Demers.",
                "Flexible Update Propagation for Weakly Consistent Replication.",
                "In Proc.",
                "SOSP, Oct. 1997. [27] Planetlab. http://www.planet-lab.org. [28] C. G. Plaxton, R. Rajaraman, and A. W. Richa.",
                "Accessing Nearby Copies of Replicated Objects in a Distributed Environment.",
                "In ACM SPAA, 1997. [29] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content Addressable Network.",
                "In Proceedings of ACM SIGCOMM, 2001. [30] S. Ratnasamy, S. Shenker, and I. Stoica.",
                "Routing Algorithms for DHTs: Some Open Questions.",
                "In IPTPS, March 2002. [31] T. Roscoe, R. Mortier, P. Jardetzky, and S. Hand.",
                "InfoSpect: Using a Logic Language for System Health Monitoring in Distributed Systems.",
                "In Proceedings of the SIGOPS European Workshop, 2002. [32] A. Rowstron and P. Druschel.",
                "Pastry: Scalable, Distributed Object Location and Routing for Large-scale Peer-to-peer Systems.",
                "In Middleware, 2001. [33] S.Ratnasamy, M.Handley, R.Karp, and S.Shenker.",
                "Application-level Multicast using Content-addressable Networks.",
                "In Proceedings of the NGC, November 2001. [34] W. Stallings.",
                "SNMP, SNMPv2, and CMIP.",
                "Addison-Wesley, 1993. [35] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan.",
                "Chord: A scalable Peer-To-Peer lookup service for internet applications.",
                "In ACM SIGCOMM, 2001. [36] S.Zhuang, B.Zhao, A.Joseph, R.Katz, and J.Kubiatowicz.",
                "Bayeux: An Architecture for Scalable and Fault-tolerant Wide-Area Data Dissemination.",
                "In NOSSDAV, 2001. [37] IBM Tivoli Monitoring. www.ibm.com/software/tivoli/products/monitor. [38] R. VanRenesse, K. P. Birman, and W. Vogels.",
                "Astrolabe: A Robust and Scalable Technology for Distributed System Monitoring, Management, and Data Mining.",
                "TOCS, 2003. [39] R. VanRenesse and A. Bozdog.",
                "Willow: DHT, Aggregation, and Publish/Subscribe in One Protocol.",
                "In IPTPS, 2004. [40] A. Venkataramani, P. Weidmann, and M. Dahlin.",
                "Bandwidth constrained placement in a wan.",
                "In PODC, Aug. 2001. [41] A. Venkataramani, P. Yalagandula, R. Kokku, S. Sharif, and M. Dahlin.",
                "Potential costs and benefits of long-term prefetching for content-distribution.",
                "Elsevier Computer Communications, 25(4):367-375, Mar. 2002. [42] M. Wawrzoniak, L. Peterson, and T. Roscoe.",
                "Sophia: An Information Plane for Networked Systems.",
                "In HotNets-II, 2003. [43] R. Wolski, N. Spring, and J. Hayes.",
                "The network weather service: A distributed resource performance forecasting service for metacomputing.",
                "Journal of Future Generation Computing Systems, 15(5-6):757-768, Oct 1999. [44] P. Yalagandula and M. Dahlin.",
                "SDIMS: A scalable distributed information management system.",
                "Technical Report TR-03-47, Dept. of Computer Sciences, UT Austin, Sep 2003. [45] Z. Zhang, S.-M. Shi, and J. Zhu.",
                "SOMO: Self-Organized Metadata Overlay for Resource Management in P2P DHT.",
                "In IPTPS, 2003. [46] B. Y. Zhao, J. D. Kubiatowicz, and A. D. Joseph.",
                "Tapestry: An Infrastructure for Fault-tolerant Wide-area Location and Routing.",
                "Technical Report UCB/CSD-01-1141, UC Berkeley, Apr. 2001. 390"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}