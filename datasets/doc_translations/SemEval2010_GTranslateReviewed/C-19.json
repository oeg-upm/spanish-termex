{
    "id": "C-19",
    "original_text": "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols. The most common approach uses events as the main abstraction for a local interaction between protocol modules. We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols. It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols. We then describe an experimental implementation of a service-based protocol framework in Java. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1. INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols. They allow complex protocols to be implemented by decomposing them into several modules cooperating together. This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications. Moreover, protocol modules can be plugged in to the system dynamically. All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications. Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction). Events are used for asynchronous communication between different modules on the same machine. However, the use of events raises some problems [4, 13]. For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4]. Protocol frameworks such as Appia and Eva extend the event-based approach with channels. However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult. In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction. We compare this new approach with the common, event-based approach. We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols. To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation. The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware. The paper is organized as follows. Section 2 defines general notions. Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework. Section 4 describes our new approach, which is based on service abstraction. Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework. The description of our experimental implementation is presented in Section 6. Finally, we conclude in Section 7. 2. PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks. Protocols and Protocol Modules. A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem. A protocol is implemented as a set of identical protocol modules located on different machines. Protocol Stacks. A stack is a set of protocol modules (of different protocols) that are located on the same machine. Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below. In the remainder of this paper, we use the terms machine and stack interchangeably. Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack. We represent protocol modules by capital letters indexed with a natural number, e.g. P1, Q1, R1 and S1. We write Pi to denote the protocol module of a protocol P in stack i. We use this notation throughout the paper. Modules are represented as white boxes. Arrows show module interactions. For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1). Protocol Module Interactions. Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules. A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request. A single request can generate several replies. Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies. For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event. Notifications may also be the results of a request. 3. EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based. Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17]. In this section, we define the notion of an event in protocol frameworks. We also explain how protocol modules are structured in event-based frameworks. Events. An event is a special object for indirect communication between protocol modules in the same stack. Events may transport some information, e.g. a network message or some other data. With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event. Events enable one-to-many communication within a protocol stack. Triggering an event can be done either synchronously or asynchronously. In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked. Protocol Modules. In event-based protocol frameworks, a protocol module consists of a set of handlers. Each handler is dedicated to handling of a specific event. Handlers of the same protocol module may share data. Handlers can be dynamically bound to events. Handlers can also be unbound dynamically. Upon triggering some event e, all handlers bound to e are executed. If no handler is bound, the behavior is usually unspecified. Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack. Events are represented by small letters, e.g. e, f, ... The fact that a protocol module can trigger an event is represented by an arrow starting from the module. A white trapezoid inside a module box represents a handler defined by the protocol module. To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e). For example, the protocol module P1 triggers event e and handles event f (see Fig. 2). Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine). Specific Features. Some protocol frameworks have unique features. Below, we present the features that influence composition and implementation of protocol modules. In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event. When an event is triggered, all handlers are executed following the order of priority. A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed. Appia [1, 16] and Eva [3] introduce the notion of channels. Channels allow to build routes of events in protocol stacks. Each protocol module has to subscribe to one or many channels. All events are triggered by specifying a channel they belong to. When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4. SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks. Service Interface. In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces. Requests, replies and notifications are all issued to service interfaces. Protocol Modules. A protocol module is a set of executers, listeners and interceptors. Executers handle requests. An executer can be dynamically bound to a service interface. It can be later unbound. A request issued to a service interface si leads to the execution of the executer bound to si. If no executer is bound to si, the request is delayed until some executer is bound to si. Contrary to events, at most one executer at any time can be bound to a service interface on every machine. Listeners handle replies and notifications. A listener can be dynamically bound and unbound to/from a service interface si. A notification issued to a service interface si is handled by all listeners bound to si in the local stack. A reply issued to a service interface is handled by one single listener. To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply. If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply. If the listener that must handle the reply does not exist, the reply is delayed until the listener is created. Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack. We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box. The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si. Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si. We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border. A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si. In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u. Note that the service interface nt allows to access the network. P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole. Similarly to executers, interceptors can be dynamically bound or unbound to a service interface. They are activated each time a request, a reply or a notification is issued to the service interface they are bound to. This is illustrated in Figure 4. In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box. The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener. When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed. Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 . When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed. Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications. Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding. Upon replies and notifications, the order is reversed. 5. ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks. We structure our discussion in three parts. Firstly, we present how protocol interactions are modeled in each of the protocol frameworks. Then, we discuss the composition of protocol modules in each of these frameworks. Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it. The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules. For each protocol interaction, we show how it is modeled in both frameworks. We also explain that an inadequate model may lead to problems. Requests. In service-based frameworks, a request is generated to a service interface. Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time. On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event. There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors. Replies. When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed. This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol). This is not the case in event-based frameworks, as we now show. Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request. Module S1 handles the request. When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h). This behavior is not correct: only protocol modules Qi should handle the reply. Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors. Solutions to solve this problem exist. However, they introduce an unnecessary burden on the protocol programmers and the stack composer. For instance, channels allow to route events to ensure that modules handle only events concerning them. However, the protocol programmer must take channels into account when implementing protocols. Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly. An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead. Notifications. Contrary to requests and replies, notifications are well modeled in event-based frameworks. The reason is that notifications correspond to the one-to-many communication scheme provided by events. In service-based frameworks, notifications are also well modeled. When a module generates a notification to a service interface si, all listeners bound to s are executed. Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request. Thus, there is a semantic link between them. The composer of protocol modules must preserve this link in order to compose correct stacks. We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition. In service-based frameworks, requests, replies and notifications are issued to a service interface. Thus, a service interface introduces a link between these interactions. To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si. The same must be done for one executer that is part of a module that issues replies or notifications. Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si. In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies. Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests. Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply. Note that these problems can be partially solved by typing events and handlers. However, it does not prevent from errors if there are several instances of the same event type. Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events. The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem. Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i. This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18]. Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.) In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure). The two-sided arrows point to the protocol modules P1 and newP1 that are switched. It can be seen that the approach that uses the Service Interface mechanism has advantages. The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1. The code of the module P1 can therefore remain unchanged. In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1. Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference. The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6. IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7]. Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics). In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules). Finally, we present an example protocol stack that we have implemented to validate the service-based approach. The Service Class. A Service object is characterized by the arguments of requests and the arguments of responses. A response is either a reply or a notification. A special argument, called message, determines the kind of interactions modeled by the response. A message represents a piece of information sent over the network. When a protocol module issues a request, it can give a message as an argument. The message can specify the listener that must handle the reply. When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener. Otherwise, a notification is issued. Executers, listeners and interceptors are encoded as innerclasses of the Service class. This allows to provide type-safe protocol interactions. For instance, executers can only be bound to the Service object, they belong to. Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers. The type of a Service object is determined by the type of the arguments of requests and responses. A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules. The Protocol Class. A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor). Protocol objects are characterized by names to retrieve them easily. Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects. Protocol objects can be loaded to a stack dynamically. All these features made it easy to implement dynamic replacement of network protocols. Protocol Stack Implementation. To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches. Fig. 6 shows the corresponding stacks of the AGC middleware. Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated. The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15]. The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport. The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc. Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc. Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9]. The CT module provides a distributed consensus service using the ChandraToueg algorithm [10]. The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order. The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details). The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules. Note that each arrow in the event-based architecture represents an event. We do not name events in the figure for readability. The left stack in Figure 6 shows the implementation of AGC with our service-based framework. The right stack shows the same implementation with an event-based framework. Performance Evaluation. To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware. The latter implementation of AGC uses the Cactus protocol framework [5, 2]. In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows. Consider a message m sent using ABcast. We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i. We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks. Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM. All PCs are interconnected by a 100 Base-TX duplex Ethernet hub. Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second. In Figure 7, we show the results of our experiment for different loads. Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis. The solid line shows the results obtained with our service-based framework. The dashed line shows the results obtained with the Cactus framework. The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%. This can be explained as follows. Firstly, the servicebased framework provides a higher level abstraction, which has a small cost. Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework. However, it is possible to optimize the AGC middleware for the service-based framework. 7. CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events. We believe that the service-based framework has several advantages over event-based frameworks. It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates. A prototype implementation allowed us to validate our ideas. 8. REFERENCES [1] The Appia project. Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu. Coyote: a system for constructing fine-grain configurable communication services. ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul. Eva: An event-based framework for developing specialized communication protocols. In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann. Protocol composition frameworks. A header-driven model. In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project. Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project. Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project. Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project. Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg. The weakest failure detector for solving consensus. Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg. Unreliable failure detectors for reliable distributed systems. Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting. Constructing adaptive software in distributed systems. In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project. Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper. Towards flexible finite-state-machine-based protocol composition. In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng. Composing adaptive software. IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski. A step towards a new generation of group communication systems. In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues. Appia, a flexible protocol kernel supporting multiple coordinated channels. In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev. The architecture and performance of security protocols in the Ensemble group communication system. Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper. Dynamic update of distributed agreement protocols. TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper. Dynamic Group Communication. Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003. To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper. Neko: A single environment to simulate and prototype distributed algorithms. In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti. On correctness of dynamic protocol update. In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535. Springer, June 2005. 696",
    "original_translation": "Interfaz de servicio: una nueva abstracción para implementar y componer protocolos ∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ED´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.rutti, Pawel.wojciechawski, yeRe, yeRe, yeReChowski..Schiper}@epfl.ch Resumen En este documento comparamos dos enfoques con el diseño de marcos de protocolo: herramientas para implementar protocolos de red modulares. El enfoque más común utiliza los eventos como la principal abstracción para una interacción local entre los módulos de protocolo. Argumentamos que un enfoque alternativo, que se basa en la abstracción del servicio, es más adecuado para expresar protocolos modulares. También facilita las características avanzadas en el diseño de protocolos, como la actualización dinámica de los protocolos distribuidos. Luego describimos una implementación experimental de un marco de protocolo basado en servicios en Java. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: Aplicaciones distribuidas 1. Introducción de los marcos de protocolo, tales cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] y Neko [6, 20], son herramientas de programación para desarrollar una red modularProtocolos. Permiten que los protocolos complejos se implementen descomponiéndolos en varios módulos que cooperan juntos. Este enfoque facilita la reutilización y personalización del código de los protocolos distribuidos para satisfacer las necesidades de diferentes aplicaciones. Además, los módulos de protocolo se pueden conectar al sistema dinámicamente. Todas estas características de los marcos de protocolo las convierten en una tecnología interesante para implementar sistemas adaptables [14], una clase importante de aplicaciones. La mayoría de los marcos de protocolo se basan en eventos (todos los marcos citados anteriormente se basan en esta abstracción). Los eventos se utilizan para la comunicación asincrónica entre diferentes módulos en la misma máquina. Sin embargo, el uso de eventos plantea algunos problemas [4, 13]. Por ejemplo, la composición de los módulos puede requerir conectores a eventos de ruta, lo que introduce una carga para un compositor de protocolo [4]. Los marcos de protocolo como APPIA y EVA amplían el enfoque basado en eventos con los canales. Sin embargo, en nuestra opinión, esta solución no es satisfactoria ya que la composición de pilas de protocolo complejos se vuelve más difícil. En este documento, proponemos un nuevo enfoque para construir protocolos modulares, que se basa en una abstracción de servicio. Comparamos este nuevo enfoque con el enfoque común basado en eventos. Mostramos que los marcos de protocolo basados en servicios tienen varias ventajas, p.Permitir una composición de protocolo bastante sencilla, implementación clara y un mejor soporte del reemplazo dinámico de protocolos distribuidos. Para validar nuestras afirmaciones, hemos implementado Samoa, un marco de protocolo experimental que se basa exclusivamente en el enfoque basado en servicios para la composición e implementación del módulo. El marco nos permitió comparar las implementaciones basadas en el servicio y los eventos de un middleware de comunicación de grupo adaptativo. El papel está organizado de la siguiente manera. La Sección 2 define las nociones generales. La Sección 3 presenta las características principales de los marcos basados en eventos y las características que son distintas para cada marco. La Sección 4 describe nuestro nuevo enfoque, que se basa en la abstracción del servicio. La Sección 5 analiza las ventajas de un marco de protocolo basado en servicios en comparación con un marco de protocolo basado en eventos. La descripción de nuestra implementación experimental se presenta en la Sección 6. Finalmente, concluimos en la Sección 7. 2. Marcos de protocolo En esta sección, describimos nociones que son comunes a todos los marcos de protocolo. Protocolos y módulos de protocolo. Un protocolo es un algoritmo distribuido que resuelve un problema específico en un sistema distribuido, p.Un protocolo TCP resuelve el problema de canal confiable. Un protocolo se implementa como un conjunto de módulos de protocolo idénticos ubicados en diferentes máquinas. Pilas de protocolo. Una pila es un conjunto de módulos de protocolo (de diferentes protocolos) que se encuentran en la misma máquina. Tenga en cuenta que, a pesar de su nombre, una pila no está estrictamente en capas, 691, es decir, un módulo de protocolo puede interactuar con todos los demás módulos de protocolo en la misma pila, no solo con los módulos de protocolo directamente arriba y abajo. En el resto de este documento, utilizamos los términos máquina y la pila intercambiable. Pila 1 S1 Q1 R1 P1 Red Figura 1: Ejemplo de una pila de protocolo En la Figura 1, mostramos una pila de protocolo de ejemplo. Representamos módulos de protocolo por letras mayúsculas indexadas con un número natural, p. P1, Q1, R1 y S1. Escribimos Pi para denotar el módulo de protocolo de un protocolo P en la pila i. Usamos esta notación en todo el papel. Los módulos se representan como cajas blancas. Las flechas muestran interacciones del módulo. Por ejemplo, el módulo de protocolo P1 interactúa con el módulo de protocolo Q1 y, por el contrario, (ver Fig. 1). Interacciones del módulo de protocolo. A continuación, definimos los diferentes tipos de interacción entre los módulos de protocolo.• Las solicitudes se emiten mediante módulos de protocolo. Una solicitud de un módulo de protocolo PI es una llamada asincrónica de PI de otro módulo de protocolo.• Las respuestas son los resultados de una solicitud. Una sola solicitud puede generar varias respuestas. Solo los módulos de protocolo que pertenecen al mismo protocolo que el módulo que ha emitido la solicitud se refiere a las respuestas correspondientes. Por ejemplo, una solicitud de PI genera respuestas que se refieren solo a los módulos de protocolo PJ.• Las notificaciones pueden ser utilizadas mediante un módulo de protocolo para informar (posiblemente muchos) módulos de protocolo en la misma pila sobre la aparición de un evento específico. Las notificaciones también pueden ser los resultados de una solicitud.3. Diseño del marco de protocolo basado en eventos La mayoría de los marcos de protocolo existentes están basados en eventos. Ejemplos son cactus [5, 2], Appia [1, 16] y conjunto [12, 17]. En esta sección, definimos la noción de un evento en los marcos de protocolo. También explicamos cómo se estructuran los módulos de protocolo en los marcos basados en eventos. Eventos. Un evento es un objeto especial para la comunicación indirecta entre los módulos de protocolo en la misma pila. Los eventos pueden transportar información, p.un mensaje de red o algunos otros datos. Con los eventos, la comunicación es indirecta, es decir, un módulo de protocolo que desencadena un evento no es consciente de los módulos que manejan el evento. Los eventos permiten una comunicación de uno a muchos dentro de una pila de protocolo. Activar un evento se puede realizar sincrónicamente o asincrónicamente. En el primer caso, el hilo que desencadena un evento E se bloquea hasta que todos los módulos de protocolo que manejen E hayan terminado el manejo del evento E.En el último caso, el hilo que desencadena el evento no está bloqueado. Módulos de protocolo. En los marcos de protocolo basados en eventos, un módulo de protocolo consiste en un conjunto de manejadores. Cada manejador está dedicado al manejo de un evento específico. Los manejadores del mismo módulo de protocolo pueden compartir datos. Los manejadores pueden estar dinámicamente vinculados a los eventos. Los manejadores también pueden estar descensurados dinámicamente. Al activar algún evento E, todos los manejadores unidos a E se ejecutan. Si no está atado ningún controlador, el comportamiento generalmente no se especifica. Pila 1 P1 Q1 R1 S1 Red F e GG Entrega Send H Figura 2: Ejemplo de una pila de protocolo basada en eventos en la Figura 2, mostramos un ejemplo de una pila basada en eventos. Los eventos están representados por letras pequeñas, p.E, F, ... El hecho de que un módulo de protocolo pueda activar un evento está representado por una flecha que comienza desde el módulo. Un trapezoide blanco dentro de un cuadro de módulo representa un controlador definido por el módulo de protocolo. Para marcar que algún controlador está obligado al evento E, usamos una flecha que apunta al controlador (la etiqueta de la flecha representa el evento E). Por ejemplo, el módulo de protocolo P1 desencadena el evento E y maneja el evento F (ver Fig. 2). Tenga en cuenta que la red se representa como un módulo de protocolo especial que maneja el evento de envío (para enviar un mensaje a otra máquina) y desencadena el evento de entrega (al recibir un mensaje de otra máquina). Características específicas. Algunos marcos de protocolo tienen características únicas. A continuación, presentamos las características que influyen en la composición e implementación de los módulos de protocolo. En Cactus [5, 2], el programador puede dar un número de prioridad a un controlador al vincularlo a un evento. Cuando se activa un evento, todos los manejadores se ejecutan después del orden de prioridad. Un controlador H también puede cancelar la ejecución de un desencadenante del evento: todos los manejadores que deben ejecutarse después de H de acuerdo con la prioridad no se ejecutan. Appia [1, 16] y Eva [3] introducen la noción de canales. Los canales permiten construir rutas de eventos en pilas de protocolos. Cada módulo de protocolo tiene que suscribirse a uno o muchos canales. Todos los eventos se activan especificando un canal al que pertenecen. Cuando un módulo de protocolo desencadena un evento E que especifica el Canal C, todos los manejadores unidos a E que forman parte de un protocolo que se suscribe a C (en el orden prescrito por la definición del canal C).4. Marco de protocolo basado en servicios En esta sección, describimos nuestro nuevo enfoque para implementar y componer protocolos que se basan en los servicios.692 mostramos en la Sección 5 las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos. Interfaz de servicio. En nuestro marco basado en servicios, los módulos de protocolo en la misma pila se comunican a través de objetos llamados interfaces de servicio. Las solicitudes, respuestas y notificaciones se emiten a las interfaces de servicio. Módulos de protocolo. Un módulo de protocolo es un conjunto de ejecutores, oyentes e interceptores. Los ejecutores manejan solicitudes. Un ejecutor puede estar vinculado dinámicamente a una interfaz de servicio. Puede ser desatado más tarde. Una solicitud emitida a una interfaz de servicio SI conduce a la ejecución del ejecutor vinculado a SI. Si ningún ejecutor está vinculado a SI, la solicitud se retrasa hasta que algún ejecutor está vinculado a SI. Contrariamente a los eventos, a lo sumo, un ejecutor en cualquier momento puede estar vinculado a una interfaz de servicio en cada máquina. Los oyentes manejan respuestas y notificaciones. Un oyente puede estar dinámicamente unido y sin consolidar hacia/desde una interfaz de servicio SI. Una notificación emitida a una interfaz de servicio SI es manejada por todos los oyentes unidos a SI en la pila local. Una respuesta emitida a una interfaz de servicio es manejada por un solo oyente. Para asegurarse de que un solo oyente maneje una respuesta, un módulo PI tiene que identificar, cada vez que emite una solicitud, el oyente para manejar la posible respuesta. Si la solicitud y la respuesta ocurren respectivamente, en Stack I y en Stack J, la interfaz de servicio SI en I Communicate a la interfaz de servicio SI en j El oyente que debe manejar la respuesta. Si el oyente que debe manejar la respuesta no existe, la respuesta se retrasa hasta que se crea el oyente. Pila 1 P1 Q1 R1 S1 Red T u Nt Figura 3: Ejemplo de una pila de protocolo basada en servicios en la Figura 3, mostramos un ejemplo de una pila basada en servicios. Denotamos una interfaz de servicio mediante una pequeña carta (por ejemplo, T, U y NT) en una caja hexagonal. El hecho de que un módulo PI pueda generar una solicitud a una interfaz de servicio SI está representado por una flecha negra discontinua que va de PI a Si. Del mismo modo, una flecha blanca discontinua que va del módulo Pi a la interfaz de servicio SI representa el hecho de que PI puede generar una respuesta o una notificación a SI. Representamos a los ejecutores con cajas blancas dentro de módulos de protocolo y oyentes con cajas blancas con un borde gris. Una línea de conexión entre una interfaz de servicio SI y un ejecutor E (resp. Un oyente l) muestra que E (resp. L) está vinculado a SI. En la Figura 3, el módulo Q1 contiene un ejecutor vinculado a la interfaz de servicio T y un oyente vinculado a la interfaz de servicio u.El módulo Q1 puede generar respuestas y notificaciones a la interfaz de servicio T y solicita a la interfaz de servicio u. Tenga en cuenta que la interfaz de servicio NT permite acceder a la red. P1 Q1 P1 Q1 T1T1 T T T Figura 4: Ejecución de interacciones de protocolo con interceptores Un interceptor juega un rˆole especial. De manera similar a los ejecutores, los interceptores pueden estar dinámicamente unidos o noándose a una interfaz de servicio. Se activan cada vez que se emite una solicitud, una respuesta o una notificación a la interfaz de servicio a la que están obligados. Esto se ilustra en la Figura 4. En la parte derecha de la figura, el interceptor del módulo de protocolo T1 está representado por un cuadro redondeado. El interceptor está obligado a la interfaz de servicio t.La parte izquierda de la figura muestra que un interceptor puede verse como un ejecutor más un oyente. Cuando P1 emite una solicitud REQ a la interfaz de servicio t, se ejecuta el ejecutor-interceptor de T1. Luego, el módulo T1 puede reenviar una solicitud REQ a la interfaz de servicio t, donde podemos tener REQ = REQ 1. Cuando el módulo Q1 emite una respuesta o una notificación, se utiliza un mecanismo similar, excepto que esta vez se ejecuta el inyectador-interceptor de T1. Tenga en cuenta que un módulo de protocolo TI, que tiene un interceptor vinculado a una interfaz de servicio, puede modificar solicitudes, respuestas y notificaciones. Según las solicitudes, si varios interceptores están vinculados a la misma interfaz de servicio, se ejecutan en el orden de enlace. Tras respuestas y notificaciones, el orden se invierte.5. Ventajas del diseño del marco de protocolo basado en servicios que mostramos en esta sección las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos. Estructuramos nuestra discusión en tres partes. En primer lugar, presentamos cómo se modelan las interacciones de protocolo en cada uno de los marcos de protocolo. Luego, discutimos la composición de los módulos de protocolo en cada uno de estos marcos. Finalmente, presentamos el problema del reemplazo de protocolo dinámico y las ventajas de las interfaces de servicio para implementarlo. La discusión se resume en la Tabla 1. 5.1 Interacciones del módulo de protocolo Un modelo natural de interacciones de protocolo (como se presenta en la Sección 2) facilita la implementación de módulos de protocolo. Para cada interacción del protocolo, mostramos cómo se modela en ambos marcos. También explicamos que un modelo inadecuado puede conducir a problemas. Peticiones. En los marcos basados en servicios, se genera una solicitud en una interfaz de servicio. Cada solicitud es manejada como máximo un ejecutor, ya que permitimos que solo un ejecutor esté vinculado a una interfaz de servicio en cualquier momento. Por otro lado, en los marcos basados en eventos, un módulo de protocolo emula una solicitud al activar un evento. No hay garantía 1 Las dos interfaces de servicio t en la parte izquierda de la Figura 4 representan la misma interfaz de servicio t.La duplicación es solo para que la figura sea legible.693 que este evento está ligado a un solo controlador, lo que puede conducir a errores de programación. Respuestas. Cuando un módulo de protocolo genera una respuesta en un marco basado en servicios, solo se ejecuta el oyente correcto (identificado en el momento en que se emitió la solicitud correspondiente). Esto asegura que una solicitud emitida por algún módulo de protocolo Qi, conduce a respuestas manejadas por módulos de protocolo QJ (es decir, módulos de protocolo del mismo protocolo). Este no es el caso en los marcos basados en eventos, como ahora mostramos. Considere el Módulo de Protocolo Q1 en la Figura 2 que desencadena el evento G para emular una solicitud. El módulo S1 maneja la solicitud. Cuando los módulos SI desencadenan el evento H para emular una respuesta (recuerde que puede ocurrir una respuesta en muchas pilas), tanto los módulos Qi como RI manejarán la respuesta (ambos contienen un controlador unido a H). Este comportamiento no es correcto: solo los módulos de protocolo Qi deben manejar la respuesta. Además, como los módulos RI no se implementan necesariamente para interactuar con los módulos Qi, este comportamiento puede conducir a errores. Existen soluciones para resolver este problema. Sin embargo, introducen una carga innecesaria en los programadores de protocolo y el compositor de pila. Por ejemplo, los canales permiten enrutar eventos para garantizar que los módulos manejen solo los eventos relacionados con ellos. Sin embargo, el programador de protocolo debe tener en cuenta los canales al implementar protocolos. Además, la composición de pilas complejas se vuelve más difícil debido al hecho de que el compositor tiene que crear muchos canales para garantizar que los módulos manejen los eventos correctamente. Una adición de módulos de protocolo especiales (conectores nombrados) para eventos de enrutamiento tampoco es satisfactoria, ya que requiere trabajo adicional del compositor e introduce gastos generales. Notificaciones. Al contrario de las solicitudes y respuestas, las notificaciones están bien modeladas en los marcos basados en eventos. La razón es que las notificaciones corresponden al esquema de comunicación de uno a muchos proporcionado por los eventos. En los marcos basados en servicios, las notificaciones también están bien modeladas. Cuando un módulo genera una notificación a una interfaz de servicio SI, todos los oyentes vinculados a S se ejecutan. Tenga en cuenta que en este caso, las interfaces de servicio proporcionan el mismo patrón de comunicación que los eventos.5.2 Las respuestas de composición del módulo de protocolo (y a veces las notificaciones) son los resultados de una solicitud. Por lo tanto, hay un vínculo semántico entre ellos. El compositor de módulos de protocolo debe preservar este enlace para componer pilas correctas. Explicamos ahora que los marcos basados en servicios proporcionan un mecanismo para preservar este enlace, mientras que en los marcos basados en eventos, la falta de dicho mecanismo conduce a una composición propensa a errores. En los marcos basados en servicios, las solicitudes, las respuestas y las notificaciones se emiten a una interfaz de servicio. Por lo tanto, una interfaz de servicio introduce un enlace entre estas interacciones. Para componer una pila correcta, el compositor tiene que limitar a un oyente a la interfaz de servicio SI para cada módulo que emite una solicitud a SI. Se debe hacer lo mismo para un ejecutor que forma parte de un módulo que emite respuestas o notificaciones. La aplicación de esta metodología simple asegura que cada solicitud emitida a una interfaz de servicio SI eventualmente resulte en varias respuestas o notificaciones emitidas a la misma interfaz de servicio SI. En los marcos basados en eventos, todas las interacciones de protocolo se emiten a través de diferentes eventos: no existe un enlace explícito entre un evento activado por las solicitudes y un evento activado en las respuestas correspondientes. Por lo tanto, el compositor de una pila de protocolo debe conocer el significado de cada evento para preservar el vínculo semántico entre las respuestas (y notificaciones) y las solicitudes. Además, nada evita que vincule un controlador que debería manejar una solicitud a un evento utilizado para emitir una respuesta. Tenga en cuenta que estos problemas pueden resolverse parcialmente escribiendo eventos y manejadores. Sin embargo, no evita los errores si hay varias instancias del mismo tipo de evento. Tenga en cuenta que la composición del protocolo es más clara en los marcos de protocolo que se basan en servicios, en lugar de en eventos. La razón es que varios eventos que se utilizan para modelar diferentes interacciones de protocolo pueden ser modelados por una sola interfaz de servicio.5.3 Reemplazo dinámico de protocolos Reemplazo dinámico de protocolos consiste en cambiar la marcha entre protocolos que resuelven el mismo problema. El reemplazo de un protocolo P por un nuevo protocolo NEWP significa que un módulo de protocolo PI es reemplazado por NewPI en cada pila i. Este reemplazo es problemático ya que los reemplazos locales (dentro de las pilas) deben sincronizarse para garantizar la corrección del protocolo [21, 18]. Q1 Q1 R1 P1 1P 1NEWP 1 REPLA DE REPLACIÓN - P1 REPLACIÓN REWP1 GG H H G T Figura 5: Reemplazo dinámico del protocolo P para los algoritmos de sincronización para funcionar, las interacciones del módulo se interceptan para detectar un momento en que PI debe ser reemplazado por NewPI.(Otras soluciones, por ejemplo, en [11], son más complejas). En la Fig. 5, mostramos cómo esta intercepción se puede implementar en marcos de protocolo que se basan en los servicios (en la parte izquierda de la figura) y los eventos (en la parte derecha de la figura). Las flechas de dos lados apuntan a los módulos de protocolo P1 y Newp1 que se conmutan. Se puede ver que el enfoque que utiliza el mecanismo de interfaz de servicio tiene ventajas. El módulo de interceptación replic-P1 tiene un interceptor vinculado a la interfaz de servicio T que intercepta todas las solicitudes manejadas por los módulos P1 y todas las respuestas y notificaciones emitidas por P1. Por lo tanto, el código del módulo P1 puede permanecer sin cambios. En los marcos basados en eventos, la solución es agregar un módulo intermedio REPL-P1 que intercepta las solicitudes emitidas a P1 y también las respuestas y notificaciones emitidas por P1. Aunque esta solución ad-hoc puede parecer similar al enfoque basado en el servicio, hay una diferencia importante. La solución basada en el evento requiere modificar ligeramente el módulo P1 ya que en lugar de manejar el evento G y activar el evento H, P1 ahora debe manejar diferentes eventos G y H (ver Fig. 5).6. Implementación Hemos implementado un marco de protocolo experimental basado en servicios (llamado Samoa) [7]. Nuestra implementación es liviana: consta de aproximadamente 1200 líneas de código en Java 1.5 (con genéricos). En esta sección, describimos las dos clases principales de nuestra implementación: servicio (codificación de la interfaz de servicio) y 694 interacción de protocolo basada en eventos basada en el servicio, una composición de protocolo de representación inadecuada de representación, reemplazo dinámico de complejo y propenso a errores, un complejo y un reemplazo dinámico propensoMecanismo integrado de soluciones AD-Hoc Tabla 1: Protocolo basado en servicios versus protocolo basado en eventos (módulos de protocolo de codificación). Finalmente, presentamos una pila de protocolo de ejemplo que hemos implementado para validar el enfoque basado en servicios. La clase de servicio. Un objeto de servicio se caracteriza por los argumentos de las solicitudes y los argumentos de las respuestas. Una respuesta es una respuesta o una notificación. Un argumento especial, llamado mensaje, determina el tipo de interacciones modeladas por la respuesta. Un mensaje representa una información enviada a través de la red. Cuando un módulo de protocolo emite una solicitud, puede dar un mensaje como argumento. El mensaje puede especificar el oyente que debe manejar la respuesta. Cuando un módulo de protocolo emite una respuesta a una interfaz de servicio, se emite una respuesta si uno de los argumentos de la respuesta es un mensaje que especifica a un oyente. De lo contrario, se emite una notificación. Los ejecutores, oyentes e interceptores están codificados como las clases intermedias de la clase de servicio. Esto permite proporcionar interacciones con protocolo a prueba de tipo. Por ejemplo, los ejecutores solo pueden estar vinculados al objeto de servicio, pertenecen. Por lo tanto, los parámetros pasados a las solicitudes (que se verifican estáticamente) siempre corresponden a los parámetros aceptados por los ejecutores correspondientes. El tipo de objeto de servicio está determinado por el tipo de argumentos de solicitudes y respuestas. Un objeto de servicio t es compatible con otro objeto de servicio si el tipo de argumentos de solicitudes (y respuestas) de t es un subtipo de los argumentos de solicitudes (y respuestas) de s.En la práctica, si un módulo de protocolo PI puede emitir una solicitud a un protocolo UDP, entonces también puede emitir una solicitud a TCP (compatible con UDP) debido a la relación de subtipo en los parámetros de los módulos de comunicación. La clase de protocolo. Un objeto de protocolo consta de tres conjuntos de componentes, un conjunto para cada tipo de componente (un oyente, un ejecutor y un interceptor). Los objetos de protocolo se caracterizan por nombres para recuperarlos fácilmente. Además, hemos agregado algunas características para unir y desabrochar a todos los ejecutores o interceptores hacia/desde los objetos de servicio correspondientes. Los objetos de protocolo se pueden cargar a una pila dinámicamente. Todas estas características facilitaron la implementación de un reemplazo dinámico de los protocolos de red. Implementación de la pila de protocolo. Para validar nuestras ideas, hemos desarrollado un middleware de comunicación grupal adaptativa (AGC), adoptando los enfoques basados en el servicio y los eventos. La figura 6 muestra las pilas correspondientes del middleware AGC. Ambas pilas permiten que el consenso y los protocolos de transmisión atómica se actualicen dinámicamente. La arquitectura de nuestro middleware, que se muestra en la Fig. 6, se basa en la pila de comunicación grupal descrita en [15]. Los módulos UDP y RP2P proporcionan un transporte punto a punto respectivamente, poco confiable y confiable. El módulo FD implementa un detector de falla;Suponemos que garantiza la pila 1 UDP1RP2P1 REPL CT1 1ABC. REPL CT1 ABC.1 Red FD1 GM1 RP2P NT UDP D F ABCAST CONSENSUS PISTA 1 REPL CT1 1ABC. REPL ABC.1 UDP1 FD1 RP2P1 CT1 RED 1GM Enviar entrega Figura 6: Middleware de comunicación de grupo adaptativo: Propiedades basadas en servicios (izquierda) versus eventos (derecha) del detector de falla 3S [9]. El módulo CT proporciona un servicio de consenso distribuido utilizando el algoritmo Chandratoueg [10]. El ABC.El módulo implementa la transmisión atómica: una comunicación grupal primitiva que entrega mensajes a todos los procesos en el mismo orden. El módulo GM proporciona un servicio de membresía grupal que mantiene datos de membresía consistentes entre los miembros del grupo (ver [19] para más detalles). El replic de ABC.y los módulos CT replican los algoritmos de reemplazo [18] para, respectivamente, el ABC.y los módulos de protocolo CT. Tenga en cuenta que cada flecha en la arquitectura basada en eventos representa un evento. No nombramos eventos en la figura para su legibilidad. La pila izquierda en la Figura 6 muestra la implementación de AGC con nuestro marco basado en servicios. La pila correcta muestra la misma implementación con un marco basado en eventos. Evaluación del desempeño. Para evaluar la sobrecarga de las interfaces de servicio, comparamos el rendimiento de las implementaciones de eventos de servicio y el Middleware AGC. La última implementación de AGC utiliza el marco del protocolo Cactus [5, 2]. En nuestro experimento, comparamos la latencia promedio de la transmisión atómica (ABCast), que se define de la siguiente manera. Considere un mensaje m enviado usando ABCast. Denotamos por ti (m) el tiempo entre el momento de enviar my el momento de entregar M en una máquina (pila) i. Definimos la latencia promedio de M como el promedio de Ti (M) para todas las máquinas (pilas) I dentro de un grupo de pilas. Se han realizado pruebas de rendimiento utilizando un clúster de PC que ejecutan Red Hat Linux 7.2, donde cada PC tiene un procesador Pentium III 766 MHz y 128 MB de RAM. Todas las PC están interconectadas por un concentrador Ethernet Duplex de 100 Base-TX. Nuestro experimento ha involucrado 7 máquinas (pilas) que ABCast Mensajes de 4 MB bajo una carga constante, donde una carga es una serie de mensajes por segundo. En la Figura 7, mostramos los resultados de nuestro experimento para diferentes cargas. Las latencias se muestran en el eje vertical, mientras que las cargas de mensajes se muestran en el eje horizontal. La línea continua muestra los resultados obtenidos con nuestro marco basado en servicios. La línea discontinua muestra los resultados obtenidos con el marco Cactus. El 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatencia [MS] Carga [MSG/S] Marco basado en servicios Cactus Figura 7: Comparación entre nuestro marco basado en servicios y gastos generales de cactus de la cabeza basada en el servicioEl marco es de aproximadamente el 10%. Esto se puede explicar de la siguiente manera. En primer lugar, el marco basado en el servicio proporciona una abstracción de nivel superior, que tiene un pequeño costo. En segundo lugar, el AGC Middleware se implementó y optimizó inicialmente para el marco Cactus basado en eventos. Sin embargo, es posible optimizar el Middleware AGC para el marco basado en servicios.7. Conclusión En el documento, propusimos un nuevo enfoque para la composición del protocolo que se basa en la noción de interfaz de servicio, en lugar de eventos. Creemos que el marco basado en servicios tiene varias ventajas sobre los marcos basados en eventos. Nos permite: (1) modelar las interacciones de protocolo con precisión, (2) reducir el riesgo de errores durante la fase de composición y (3) simplemente implementar actualizaciones de protocolo dinámico. Una implementación prototipo nos permitió validar nuestras ideas.8. Referencias [1] El proyecto Appia. Documentación disponible electrónicamente en http://appia.di.fc.ul.pt/.[2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting y Wanda Chiu. Coyote: un sistema para construir servicios de comunicación configurables de grano fino. Transacciones ACM en sistemas informáticos, 16 (4): 321-366, noviembre de 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin y Jean-Pierre Le Narzul. EVA: Un marco basado en eventos para desarrollar protocolos de comunicación especializados. En Actas del primer Simposio Internacional IEEE sobre computación y aplicaciones de redes (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena y Uwe Nestmann. Marcos de composición del protocolo. Un modelo dirigido por encabezado. En Actas del 4to Simposio Internacional IEEE sobre Computación y Aplicaciones de Redes (NCA 05), julio de 2005. [5] El Proyecto Cactus. Documentación disponible electrónicamente en http://www.cs.arizona.edu/ cactus/.[6] El proyecto Neko. Documentación disponible electrónicamente en http://lsrwww.epfl.ch/neko/.[7] El proyecto Samoa. Documentación disponible electrónicamente en http://lsrwww.epfl.ch/samoa/.[8] El proyecto SDL. Documentación disponible electrónicamente en http://www.sdl-forum.org/sdl/.[9] Tushar Deepak Chandra, Vassos Hadzilacos y Sam Toueg. El detector de falla más débil para resolver el consenso. Journal of the ACM, 43 (4): 685-722, 1996. [10] Tushar Deepak Chandra y Sam Toueg. Detectores de fallas poco confiables para sistemas distribuidos confiables. Journal of the ACM, 43 (2): 225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen y Richard D. Schlichting. Construcción del software adaptativo en sistemas distribuidos. En Actas de la 21ª Conferencia Internacional IEEE sobre el Sistema de Computación Distribuido (ICDCS 01), abril de 2001. [12] El proyecto del conjunto. Documentación disponible electrónicamente en http://www.cs.cornell.edu/info/ proyects/ensemble/.[13] Richard Ekwall, Sergio Mena, Stefan Pleisch y Andr´e Schiper. Hacia la composición flexible de protocolo de estado finito-estatal. En Actas del 3er Simposio Internacional IEEE sobre Computación y Aplicaciones de Redes (NCA 04), agosto de 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten y Betty H.C.Cheng. Componiendo software adaptativo. IEEE Computer, 37 (7): 56-64, 2004. [15] Sergio Mena, Andr´e Schiper y Pawel T. Wojciechowski. Un paso hacia una nueva generación de sistemas de comunicación grupal. En Actas de la 4ta Conferencia Internacional de Middleware ACM/IFIP/Usenix (Middleware 03), LNCS 2672, junio de 2003. [16] Hugo Miranda, Alexandre Pinto y Lu´ıs Rodrigues. Appia, un núcleo de protocolo flexible que admite múltiples canales coordinados. En Actas de la 21a Conferencia Internacional IEEE sobre Sistemas de Computación distribuida (ICDCS 01), abril de 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao y Danny Dolev. La arquitectura y el rendimiento de los protocolos de seguridad en el sistema de comunicación del grupo conjunto. Informe técnico TR-98-1703, Departamento de Ciencias de la Computación, Universidad de Cornell, septiembre de 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski y Andr´e Schiper. Actualización dinámica de protocolos de acuerdo distribuido. TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), marzo de 2005. [19] Andr´e Schiper. Comunicación de grupo dinámico. Informe técnico IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), abril de 2003. Aparecer en la computación distribuida ACM.[20] P´eter Urb´an, Xavier D´efago y Andr´e Schiper. Neko: un entorno único para simular y prototipos de algoritmos distribuidos. En Actas de la 15ª Conferencia Internacional sobre Redes de Información (ICOIN 01), febrero de 2001. [21] Pawel T. Wojciechowski y Olivier R¨utti. Sobre la corrección de la actualización del protocolo dinámico. En Actas de la 7ª Conferencia IFIP sobre métodos formales para sistemas distribuidos abiertos basados en objetos (FMoods 05), LNCS 3535. Springer, junio de 2005. 696",
    "original_sentences": [
        "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
        "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
        "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
        "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
        "We then describe an experimental implementation of a service-based protocol framework in Java.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
        "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
        "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
        "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
        "Moreover, protocol modules can be plugged in to the system dynamically.",
        "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
        "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
        "Events are used for asynchronous communication between different modules on the same machine.",
        "However, the use of events raises some problems [4, 13].",
        "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
        "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
        "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
        "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
        "We compare this new approach with the common, event-based approach.",
        "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
        "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
        "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
        "The paper is organized as follows.",
        "Section 2 defines general notions.",
        "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
        "Section 4 describes our new approach, which is based on service abstraction.",
        "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
        "The description of our experimental implementation is presented in Section 6.",
        "Finally, we conclude in Section 7. 2.",
        "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
        "Protocols and Protocol Modules.",
        "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
        "A protocol is implemented as a set of identical protocol modules located on different machines.",
        "Protocol Stacks.",
        "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
        "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
        "In the remainder of this paper, we use the terms machine and stack interchangeably.",
        "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
        "We represent protocol modules by capital letters indexed with a natural number, e.g.",
        "P1, Q1, R1 and S1.",
        "We write Pi to denote the protocol module of a protocol P in stack i.",
        "We use this notation throughout the paper.",
        "Modules are represented as white boxes.",
        "Arrows show module interactions.",
        "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
        "Protocol Module Interactions.",
        "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
        "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
        "A single request can generate several replies.",
        "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
        "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
        "Notifications may also be the results of a request. 3.",
        "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
        "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
        "In this section, we define the notion of an event in protocol frameworks.",
        "We also explain how protocol modules are structured in event-based frameworks.",
        "Events.",
        "An event is a special object for indirect communication between protocol modules in the same stack.",
        "Events may transport some information, e.g. a network message or some other data.",
        "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
        "Events enable one-to-many communication within a protocol stack.",
        "Triggering an event can be done either synchronously or asynchronously.",
        "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
        "Protocol Modules.",
        "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
        "Each handler is dedicated to handling of a specific event.",
        "Handlers of the same protocol module may share data.",
        "Handlers can be dynamically bound to events.",
        "Handlers can also be unbound dynamically.",
        "Upon triggering some event e, all handlers bound to e are executed.",
        "If no handler is bound, the behavior is usually unspecified.",
        "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
        "Events are represented by small letters, e.g. e, f, ...",
        "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
        "A white trapezoid inside a module box represents a handler defined by the protocol module.",
        "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
        "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
        "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
        "Specific Features.",
        "Some protocol frameworks have unique features.",
        "Below, we present the features that influence composition and implementation of protocol modules.",
        "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
        "When an event is triggered, all handlers are executed following the order of priority.",
        "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
        "Appia [1, 16] and Eva [3] introduce the notion of channels.",
        "Channels allow to build routes of events in protocol stacks.",
        "Each protocol module has to subscribe to one or many channels.",
        "All events are triggered by specifying a channel they belong to.",
        "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
        "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
        "Service Interface.",
        "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
        "Requests, replies and notifications are all issued to service interfaces.",
        "Protocol Modules.",
        "A protocol module is a set of executers, listeners and interceptors.",
        "Executers handle requests.",
        "An executer can be dynamically bound to a service interface.",
        "It can be later unbound.",
        "A request issued to a service interface si leads to the execution of the executer bound to si.",
        "If no executer is bound to si, the request is delayed until some executer is bound to si.",
        "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
        "Listeners handle replies and notifications.",
        "A listener can be dynamically bound and unbound to/from a service interface si.",
        "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
        "A reply issued to a service interface is handled by one single listener.",
        "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
        "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
        "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
        "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
        "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
        "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
        "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
        "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
        "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
        "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
        "Note that the service interface nt allows to access the network.",
        "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
        "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
        "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
        "This is illustrated in Figure 4.",
        "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
        "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
        "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
        "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
        "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
        "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
        "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
        "Upon replies and notifications, the order is reversed. 5.",
        "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
        "We structure our discussion in three parts.",
        "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
        "Then, we discuss the composition of protocol modules in each of these frameworks.",
        "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
        "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
        "For each protocol interaction, we show how it is modeled in both frameworks.",
        "We also explain that an inadequate model may lead to problems.",
        "Requests.",
        "In service-based frameworks, a request is generated to a service interface.",
        "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
        "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
        "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
        "Replies.",
        "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
        "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
        "This is not the case in event-based frameworks, as we now show.",
        "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
        "Module S1 handles the request.",
        "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
        "This behavior is not correct: only protocol modules Qi should handle the reply.",
        "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
        "Solutions to solve this problem exist.",
        "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
        "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
        "However, the protocol programmer must take channels into account when implementing protocols.",
        "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
        "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
        "Notifications.",
        "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
        "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
        "In service-based frameworks, notifications are also well modeled.",
        "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
        "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
        "Thus, there is a semantic link between them.",
        "The composer of protocol modules must preserve this link in order to compose correct stacks.",
        "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
        "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
        "Thus, a service interface introduces a link between these interactions.",
        "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
        "The same must be done for one executer that is part of a module that issues replies or notifications.",
        "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
        "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
        "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
        "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
        "Note that these problems can be partially solved by typing events and handlers.",
        "However, it does not prevent from errors if there are several instances of the same event type.",
        "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
        "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
        "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
        "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
        "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
        "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
        "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
        "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
        "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
        "The code of the module P1 can therefore remain unchanged.",
        "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
        "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
        "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
        "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
        "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
        "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
        "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
        "The Service Class.",
        "A Service object is characterized by the arguments of requests and the arguments of responses.",
        "A response is either a reply or a notification.",
        "A special argument, called message, determines the kind of interactions modeled by the response.",
        "A message represents a piece of information sent over the network.",
        "When a protocol module issues a request, it can give a message as an argument.",
        "The message can specify the listener that must handle the reply.",
        "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
        "Otherwise, a notification is issued.",
        "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
        "This allows to provide type-safe protocol interactions.",
        "For instance, executers can only be bound to the Service object, they belong to.",
        "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
        "The type of a Service object is determined by the type of the arguments of requests and responses.",
        "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
        "The Protocol Class.",
        "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
        "Protocol objects are characterized by names to retrieve them easily.",
        "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
        "Protocol objects can be loaded to a stack dynamically.",
        "All these features made it easy to implement dynamic replacement of network protocols.",
        "Protocol Stack Implementation.",
        "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
        "Fig. 6 shows the corresponding stacks of the AGC middleware.",
        "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
        "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
        "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
        "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
        "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
        "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
        "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
        "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
        "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
        "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
        "Note that each arrow in the event-based architecture represents an event.",
        "We do not name events in the figure for readability.",
        "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
        "The right stack shows the same implementation with an event-based framework.",
        "Performance Evaluation.",
        "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
        "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
        "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
        "Consider a message m sent using ABcast.",
        "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
        "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
        "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
        "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
        "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
        "In Figure 7, we show the results of our experiment for different loads.",
        "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
        "The solid line shows the results obtained with our service-based framework.",
        "The dashed line shows the results obtained with the Cactus framework.",
        "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
        "This can be explained as follows.",
        "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
        "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
        "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
        "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
        "We believe that the service-based framework has several advantages over event-based frameworks.",
        "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
        "A prototype implementation allowed us to validate our ideas. 8.",
        "REFERENCES [1] The Appia project.",
        "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
        "Coyote: a system for constructing fine-grain configurable communication services.",
        "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
        "Eva: An event-based framework for developing specialized communication protocols.",
        "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
        "Protocol composition frameworks.",
        "A header-driven model.",
        "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
        "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
        "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
        "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
        "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
        "The weakest failure detector for solving consensus.",
        "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
        "Unreliable failure detectors for reliable distributed systems.",
        "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
        "Constructing adaptive software in distributed systems.",
        "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
        "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
        "Towards flexible finite-state-machine-based protocol composition.",
        "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
        "Composing adaptive software.",
        "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
        "A step towards a new generation of group communication systems.",
        "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
        "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
        "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
        "The architecture and performance of security protocols in the Ensemble group communication system.",
        "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
        "Dynamic update of distributed agreement protocols.",
        "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
        "Dynamic Group Communication.",
        "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
        "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
        "Neko: A single environment to simulate and prototype distributed algorithms.",
        "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
        "On correctness of dynamic protocol update.",
        "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
        "Springer, June 2005. 696"
    ],
    "error_count": 0,
    "keys": {
        "protocol framework": {
            "translated_key": "marco de protocolo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based <br>protocol framework</br> in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental <br>protocol framework</br> that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based <br>protocol framework</br> compared to an event-based <br>protocol framework</br>.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED <br>protocol framework</br> DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED <br>protocol framework</br> In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED <br>protocol framework</br> DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based <br>protocol framework</br> (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus <br>protocol framework</br> [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Luego describimos una implementación experimental de un \"marco de protocolo\" basado en servicios en Java.",
                "Para validar nuestras afirmaciones, hemos implementado Samoa, un \"marco de protocolo\" experimental que se basa exclusivamente en el enfoque basado en servicios para la composición e implementación del módulo.",
                "La Sección 5 analiza las ventajas de un \"marco de protocolo\" basado en servicios en comparación con un \"marco de protocolo\" basado en eventos.",
                "Diseño de \"Marco de protocolo\" basado en eventos La mayoría de los marcos de protocolo existentes están basados en eventos.",
                "\"Marco de protocolo\" basado en servicios En esta sección, describimos nuestro nuevo enfoque para implementar y componer protocolos que se basan en los servicios.692 mostramos en la Sección 5 las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos.",
                "Ventajas del diseño de \"Marco de protocolo\" basado en servicios que mostramos en esta sección las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos.",
                "Implementación Hemos implementado un \"marco de protocolo\" experimental basado en servicios (llamado Samoa) [7].",
                "La última implementación de AGC utiliza el \"marco de protocolo\" de Cactus [5, 2]."
            ],
            "translated_text": "",
            "candidates": [
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "Marco de protocolo",
                "marco de protocolo",
                "Marco de protocolo",
                "marco de protocolo",
                "Marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo",
                "marco de protocolo"
            ],
            "error": []
        },
        "distributed algorithm": {
            "translated_key": "algoritmo distribuido",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a <br>distributed algorithm</br> that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un protocolo es un \"algoritmo distribuido\" que resuelve un problema específico en un sistema distribuido, p.Un protocolo TCP resuelve el problema de canal confiable."
            ],
            "translated_text": "",
            "candidates": [
                "algoritmo distribuido",
                "algoritmo distribuido"
            ],
            "error": []
        },
        "distributed system": {
            "translated_key": "Sistema distribuido",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a <br>distributed system</br>, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un protocolo es un algoritmo distribuido que resuelve un problema específico en un \"sistema distribuido\", p.Un protocolo TCP resuelve el problema de canal confiable."
            ],
            "translated_text": "",
            "candidates": [
                "Sistema distribuido",
                "sistema distribuido"
            ],
            "error": []
        },
        "service interface": {
            "translated_key": "interfaz de servicio",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>service interface</br>: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "<br>service interface</br>.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a <br>service interface</br>.",
                "It can be later unbound.",
                "A request issued to a <br>service interface</br> si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a <br>service interface</br> on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a <br>service interface</br> si.",
                "A notification issued to a <br>service interface</br> si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a <br>service interface</br> is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the <br>service interface</br> si on i communicates to the <br>service interface</br> si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a <br>service interface</br> by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a <br>service interface</br> si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to <br>service interface</br> si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a <br>service interface</br> si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to <br>service interface</br> t and a listener bound to <br>service interface</br> u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the <br>service interface</br> nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a <br>service interface</br>.",
                "They are activated each time a request, a reply or a notification is issued to the <br>service interface</br> they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to <br>service interface</br> t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the <br>service interface</br> t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the <br>service interface</br> t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a <br>service interface</br>, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same <br>service interface</br>, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a <br>service interface</br>.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a <br>service interface</br> at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same <br>service interface</br> t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a <br>service interface</br> si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a <br>service interface</br>.",
                "Thus, a <br>service interface</br> introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to <br>service interface</br> si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a <br>service interface</br> si eventually results in several replies or notifications issued to the same <br>service interface</br> si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single <br>service interface</br>. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the <br>service interface</br> mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to <br>service interface</br> t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the <br>service interface</br>) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a <br>service interface</br>, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of <br>service interface</br>, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "\"Interfaz de servicio\": una nueva abstracción para implementar y componer protocolos ∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ED´erale de Lausanne (Epfl) 1015 Lausanne, Switzerland {Olivier.rutti, Pawel.wojcieChiEct, Andre.schiper}@epfl.ch Resumen En este documento comparamos dos enfoques con el diseño de marcos de protocolo: herramientas para implementar protocolos de red modulares.",
                "\"Interfaz de servicio\".",
                "Un ejecutor puede estar dinámicamente unido a una \"interfaz de servicio\".",
                "Una solicitud emitida a una \"interfaz de servicio\" SI conduce a la ejecución del ejecutor vinculado a SI.",
                "Al contrario de los eventos, a lo sumo, un ejecutor en cualquier momento puede estar vinculado a una \"interfaz de servicio\" en cada máquina.",
                "Un oyente puede estar dinámicamente unido y sin consentimiento hacia/desde una \"interfaz de servicio\" SI.",
                "Una notificación emitida a una \"interfaz de servicio\" SI es manejada por todos los oyentes vinculados a SI en la pila local.",
                "Una respuesta emitida a una \"interfaz de servicio\" es manejada por un solo oyente.",
                "Si la solicitud y la respuesta ocurren respectivamente, en Stack I y en Stack J, la \"interfaz de servicio\" SI On I Communicate a la \"Interfaz de servicio\" si al oyente que debe manejar la respuesta.",
                "Denotamos una \"interfaz de servicio\" por una pequeña carta (por ejemplo, T, U y NT) en una caja hexagonal.",
                "El hecho de que un módulo PI pueda generar una solicitud a una \"interfaz de servicio\" SI está representado por una flecha negra discontinua que va de PI a SI.",
                "Del mismo modo, una flecha blanca discontinua que va del módulo Pi a la \"interfaz de servicio\" SI representa el hecho de que PI puede generar una respuesta o una notificación a SI.",
                "Una línea de conexión entre una \"interfaz de servicio\" SI y un ejecutor E (resp. Un oyente l) muestra que E (resp. L) está vinculado a SI.",
                "En la Figura 3, el módulo Q1 contiene un ejecutor vinculado a la \"interfaz de servicio\" T y un oyente unido a la \"interfaz de servicio\" u.El módulo Q1 puede generar respuestas y notificaciones a la interfaz de servicio T y solicita a la interfaz de servicio u.",
                "Tenga en cuenta que la \"interfaz de servicio\" NT permite acceder a la red.",
                "De manera similar a los ejecutores, los interceptores pueden estar dinámicamente unidos o noándose a una \"interfaz de servicio\".",
                "Se activan cada vez que se emite una solicitud, una respuesta o una notificación a la \"interfaz de servicio\" a la que están obligados.",
                "El interceptor está obligado a \"interfaz de servicio\" t.La parte izquierda de la figura muestra que un interceptor puede verse como un ejecutor más un oyente.",
                "Cuando P1 emite una solicitud REQ a la \"interfaz de servicio\" T, se ejecuta el ejecutor-interceptor de T1.",
                "Luego, el módulo T1 puede reenviar una solicitud REQ a la \"interfaz de servicio\" t, donde podemos tener req = req 1.",
                "Tenga en cuenta que un módulo de protocolo TI, que tiene un interceptor vinculado a una \"interfaz de servicio\", puede modificar solicitudes, respuestas y notificaciones.",
                "Según las solicitudes, si varios interceptores están vinculados a la misma \"interfaz de servicio\", se ejecutan en el orden de enlace.",
                "En los marcos basados en servicios, se genera una solicitud en una \"interfaz de servicio\".",
                "Cada solicitud es manejada por la mayoría de un ejecutor, ya que permitimos que solo un ejecutor esté vinculado a una \"interfaz de servicio\" en cualquier momento.",
                "No hay garantía 1 Las dos interfaces de servicio t en la parte izquierda de la Figura 4 representan la misma \"interfaz de servicio\" t.La duplicación es solo para que la figura sea legible.693 que este evento está ligado a un solo controlador, lo que puede conducir a errores de programación.",
                "Cuando un módulo genera una notificación a una \"interfaz de servicio\" SI, se ejecutan todos los oyentes vinculados a S.",
                "En los marcos basados en servicios, las solicitudes, las respuestas y las notificaciones se emiten a una \"interfaz de servicio\".",
                "Por lo tanto, una \"interfaz de servicio\" introduce un enlace entre estas interacciones.",
                "Para componer una pila correcta, el compositor tiene que limitar a un oyente a la \"interfaz de servicio\" SI para cada módulo que emite una solicitud a SI.",
                "La aplicación de esta metodología simple asegura que cada solicitud emitida a una \"interfaz de servicio\" SI finalmente resulte en varias respuestas o notificaciones emitidas a la misma \"interfaz de servicio\" SI.",
                "La razón es que varios eventos que se utilizan para modelar diferentes interacciones de protocolo pueden ser modelados por una sola \"interfaz de servicio\".5.3 Reemplazo dinámico de protocolos Reemplazo dinámico de protocolos consiste en cambiar la marcha entre protocolos que resuelven el mismo problema.",
                "Se puede ver que el enfoque que utiliza el mecanismo de \"interfaz de servicio\" tiene ventajas.",
                "El módulo de interceptación replic-P1 tiene un interceptor vinculado a la \"interfaz de servicio\" que intercepta todas las solicitudes manejadas por los módulos P1 y todas las respuestas y notificaciones emitidas por P1.",
                "En esta sección, describimos las dos clases principales de nuestra implementación: servicio (codificación de la \"interfaz de servicio\") y 694 interacción de protocolo basada en eventos basada en servicios una composición de protocolo de representación inadecuada de representación adecuada y dinámica compleja y propensa a errores.Reemplazo Un mecanismo integrado de soluciones AD-Hoc Tabla 1: Protocolo basado en servicios versus protocolo basado en eventos (módulos de protocolo de codificación).",
                "Cuando un módulo de protocolo emite una respuesta a una \"interfaz de servicio\", se emite una respuesta si uno de los argumentos de la respuesta es un mensaje que especifica a un oyente.",
                "Conclusión En el documento, propusimos un nuevo enfoque para la composición del protocolo que se basa en la noción de \"interfaz de servicio\", en lugar de eventos."
            ],
            "translated_text": "",
            "candidates": [
                "interfaz de servicio",
                "Interfaz de servicio",
                "interfaz de servicio",
                "Interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "Interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio",
                "interfaz de servicio"
            ],
            "error": []
        },
        "network": {
            "translated_key": "red",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular <br>network</br> protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular <br>network</br> protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 <br>network</br> Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a <br>network</br> message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 <br>network</br> f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the <br>network</br> is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 <br>network</br> t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the <br>network</br>.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the <br>network</br>.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of <br>network</br> protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 <br>network</br> FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 <br>network</br> 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on <br>network</br> Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on <br>network</br> Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on <br>network</br> Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Interfaz de servicio: una nueva abstracción para implementar y componer protocolos ∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ED´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.rutti, Pawel.wojciechawski, yeRe, yeRe, yeReChowski..Schiper}@epfl.ch Resumen En este documento comparamos dos enfoques con el diseño de marcos de protocolo: herramientas para implementar protocolos modulares de \"red\".",
                "Marcos de protocolo de introducción, tales cactus [5, 2], Appia [1, 16], conjunto [12, 17], Eva [3], SDL [8] y Neko [6, 20], son herramientas de programación para desarrollar modular \"Protocolos de red \".",
                "Pila 1 S1 Q1 R1 P1 \"Red\" Figura 1: Ejemplo de una pila de protocolo en la Figura 1, mostramos una pila de protocolo de ejemplo.",
                "Los eventos pueden transportar información, p.un mensaje de \"red\" o algunos otros datos.",
                "Pila 1 P1 Q1 R1 S1 \"Red\" F E GG Entrega Send H Figura 2: Ejemplo de una pila de protocolo basada en eventos en la Figura 2, mostramos un ejemplo de una pila basada en eventos.",
                "Tenga en cuenta que la \"red\" se representa como un módulo de protocolo especial que maneja el evento de envío (para enviar un mensaje a otra máquina) y desencadena el evento de entrega (al recibir un mensaje de otra máquina).",
                "Pila 1 P1 Q1 R1 S1 \"Red\" T u Nt Figura 3: Ejemplo de una pila de protocolo basada en servicios en la Figura 3, mostramos un ejemplo de una pila basada en servicios.",
                "Tenga en cuenta que la interfaz de servicio NT permite acceder a la \"red\".",
                "Un mensaje representa una información enviada a través de la \"red\".",
                "Todas estas características facilitaron la implementación de un reemplazo dinámico de los protocolos de \"red\".",
                "REPL CT1 ABC.1 \"Red\" FD1 GM1 RP2P NT UDP D F ABCAST CONSENSUS PISTA 1 REPL CT1 1ABC.",
                "REPL ABC.1 UDP1 FD1 RP2P1 CT1 \"Red\" 1GM Enviar entrega Figura 6: Middleware de comunicación de grupo adaptativo: Propiedades basadas en servicios (izquierda) versus eventos (derecha) del detector de falla 3S [9].",
                "En Actas del primer Simposio Internacional IEEE sobre computación y aplicaciones de \"red\" (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena y Uwe Nestmann.",
                "En Actas del 4º Simposio Internacional IEEE sobre Computación y Aplicaciones de \"Redes\" (NCA 05), julio de 2005. [5] El Proyecto Cactus.",
                "En Actas del 3er Simposio Internacional IEEE sobre Computación y Aplicaciones de \"Redes\" (NCA 04), agosto de 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten y Betty H.C.Cheng."
            ],
            "translated_text": "",
            "candidates": [
                "red",
                "red",
                "red",
                "Protocolos de red ",
                "red",
                "Red",
                "red",
                "red",
                "red",
                "Red",
                "red",
                "red",
                "red",
                "Red",
                "red",
                "red",
                "red",
                "red",
                "red",
                "red",
                "red",
                "Red",
                "red",
                "Red",
                "red",
                "red",
                "red",
                "Redes",
                "red",
                "Redes"
            ],
            "error": []
        },
        "communication": {
            "translated_key": "comunicación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-<br>communication</br> Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous <br>communication</br> between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group <br>communication</br> middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect <br>communication</br> between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the <br>communication</br> is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many <br>communication</br> within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many <br>communication</br> scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of <br>communication</br> as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group <br>communication</br> (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group <br>communication</br> stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group <br>communication</br> Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group <br>communication</br> primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable <br>communication</br> services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized <br>communication</br> protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group <br>communication</br> systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group <br>communication</br> system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and <br>communication</br> Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group <br>communication</br>.",
                "Technical Report IC-2003-27, School of Computer and <br>communication</br> Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Categorías y descriptores de asignaturas c.2.4 [Computer- Redes de \"comunicación\"]: aplicaciones distribuidas 1.",
                "Los eventos se utilizan para la \"comunicación\" asincrónica entre diferentes módulos en la misma máquina.",
                "El marco nos permitió comparar las implementaciones basadas en el servicio y los eventos de un middleware de \"comunicación\" de grupo adaptativo.",
                "Un evento es un objeto especial para la \"comunicación\" indirecta entre los módulos de protocolo en la misma pila.",
                "Con los eventos, la \"comunicación\" es indirecta, es decir, un módulo de protocolo que desencadena un evento no es consciente de los módulos que manejan el evento.",
                "Los eventos permiten uno a muchos \"comunicación\" dentro de una pila de protocolo.",
                "La razón es que las notificaciones corresponden al esquema de \"comunicación\" de uno a muchos proporcionado por los eventos.",
                "Tenga en cuenta que en este caso, las interfaces de servicio proporcionan el mismo patrón de \"comunicación\" que los eventos.5.2 Las respuestas de composición del módulo de protocolo (y a veces las notificaciones) son los resultados de una solicitud.",
                "Para validar nuestras ideas, hemos desarrollado un middleware de \"comunicación\" (AGC) de grupo adaptativo, adoptando los enfoques basados en el servicio y los eventos.",
                "La arquitectura de nuestro middleware, que se muestra en la Fig. 6, se basa en la pila de \"comunicación\" del grupo descrita en [15].",
                "REPL ABC.1 UDP1 FD1 RP2P1 CT1 Red 1GM Enviar entrega Figura 6: Middleware \"Comunicación\" de grupo adaptativo: propiedades basadas en servicios (izquierda) versus eventos basados en eventos (derecha) del detector de falla 3S [9].",
                "El ABC.El módulo implementa la transmisión atómica: un grupo de \"comunicación\" primitivo que entrega mensajes a todos los procesos en el mismo orden.",
                "Coyote: un sistema para construir servicios de \"comunicación\" configurables de grano fino.",
                "EVA: Un marco basado en eventos para desarrollar protocolos especializados de \"comunicación\".",
                "Un paso hacia una nueva generación de sistemas grupales de \"comunicación\".",
                "La arquitectura y el rendimiento de los protocolos de seguridad en el sistema de \"comunicación\" del grupo conjunto.",
                "TR IC-2005-12, School of Computer and \"Communication\", Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), marzo de 2005. [19] Andr´e Schiper.",
                "Grupo dinámico \"Comunicación\".",
                "Informe técnico IC-2003-27, School of Computer and \"Communication\", Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), abril de 2003."
            ],
            "translated_text": "",
            "candidates": [
                "Comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "Comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "comunicación",
                "Communication",
                "comunicación",
                "Comunicación",
                "Comunicación",
                "Communication"
            ],
            "error": []
        },
        "event-based framework": {
            "translated_key": "Marco basado en eventos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an <br>event-based framework</br>.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An <br>event-based framework</br> for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La pila correcta muestra la misma implementación con un \"marco basado en eventos\".",
                "EVA: Un \"marco basado en eventos\" para desarrollar protocolos de comunicación especializados."
            ],
            "translated_text": "",
            "candidates": [
                "Marco basado en eventos",
                "marco basado en eventos",
                "Marco basado en eventos",
                "marco basado en eventos"
            ],
            "error": []
        },
        "stack": {
            "translated_key": "pila",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A <br>stack</br> is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a <br>stack</br> is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same <br>stack</br>, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and <br>stack</br> interchangeably.",
                "<br>stack</br> 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol <br>stack</br> In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in <br>stack</br> i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same <br>stack</br> about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same <br>stack</br>.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol <br>stack</br>.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "<br>stack</br> 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol <br>stack</br> In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same <br>stack</br> communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local <br>stack</br>.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in <br>stack</br> i and in <br>stack</br> j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "<br>stack</br> 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol <br>stack</br> In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the <br>stack</br> composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct <br>stack</br>, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol <br>stack</br> must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every <br>stack</br> i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol <br>stack</br> that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a <br>stack</br> dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol <br>stack</br> Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication <br>stack</br> described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the <br>stack</br> 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus <br>stack</br> 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left <br>stack</br> in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right <br>stack</br> shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (<br>stack</br>) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Una \"pila\" es un conjunto de módulos de protocolo (de diferentes protocolos) que se encuentran en la misma máquina.",
                "Tenga en cuenta que, a pesar de su nombre, una \"pila\" no está estrictamente en capas, 691, es decir, un módulo de protocolo puede interactuar con todos los demás módulos de protocolo en la misma \"pila\", no solo con los módulos de protocolo directamente arriba y abajo.",
                "En el resto de este documento, utilizamos la máquina de los términos y la \"pila\" indistintamente.",
                "\"Pila\" 1 S1 Q1 R1 P1 Red Figura 1: Ejemplo de un protocolo \"Pila\" en la Figura 1, mostramos una pila de protocolo de ejemplo.",
                "Escribimos Pi para denotar el módulo de protocolo de un protocolo p en \"pila\" i.",
                "Por ejemplo, una solicitud de PI genera respuestas que se refieren solo a los módulos de protocolo PJ.• Las notificaciones pueden ser utilizadas mediante un módulo de protocolo para informar (posiblemente muchos) módulos de protocolo en la misma \"pila\" sobre la aparición de un evento específico.",
                "Un evento es un objeto especial para la comunicación indirecta entre los módulos de protocolo en la misma \"pila\".",
                "Los eventos permiten una comunicación de uno a muchos dentro de un protocolo \"pila\".",
                "\"Pila\" 1 P1 Q1 R1 S1 Red F e GG Entrega Send H Figura 2: Ejemplo de un protocolo basado en eventos \"Pila\" en la Figura 2, mostramos un ejemplo de una pila basada en eventos.",
                "En nuestro marco basado en servicios, los módulos de protocolo en la misma \"pila\" se comunican a través de objetos llamados interfaces de servicio.",
                "Una notificación emitida a una interfaz de servicio SI es manejada por todos los oyentes vinculados a SI en la \"pila\" local.",
                "Si la solicitud y la respuesta ocurren respectivamente, en \"Stack\" I y en \"Stack\" J, la interfaz de servicio SI On I Communicate a la interfaz de servicio SI en j El oyente que debe manejar la respuesta.",
                "\"Pila\" 1 P1 Q1 R1 S1 Red T u Nt Figura 3: Ejemplo de un protocolo basado en el servicio \"Pila\" en la Figura 3, mostramos un ejemplo de una pila basada en servicios.",
                "Sin embargo, introducen una carga innecesaria sobre los programadores de protocolo y el compositor de \"pila\".",
                "Para componer una \"pila\" correcta, el compositor tiene que limitar a un oyente a la interfaz de servicio SI para cada módulo que emite una solicitud a SI.",
                "Por lo tanto, el compositor de un protocolo \"pila\" debe conocer el significado de cada evento para preservar el vínculo semántico entre las respuestas (y notificaciones) y las solicitudes.",
                "El reemplazo de un protocolo P por un nuevo protocolo NEWP significa que un módulo de protocolo PI es reemplazado por NewPI en cada \"pila\" i.",
                "Finalmente, presentamos un protocolo de ejemplo \"pila\" que hemos implementado para validar el enfoque basado en servicios.",
                "Los objetos de protocolo se pueden cargar dinámicamente a una \"pila\".",
                "Implementación de \"pila\" de protocolo.",
                "La arquitectura de nuestro middleware, que se muestra en la Fig. 6, se basa en la \"pila\" de comunicación grupal descrita en [15].",
                "El módulo FD implementa un detector de falla;Suponemos que garantiza la \"pila\" 1 UDP1RP2P1 REPL CT1 1ABC.",
                "REPL CT1 ABC.1 RED FD1 GM1 RP2P NT UDP D F ABCAST CONSENSUS \"PISTA\" 1 REPL CT1 1ABC.",
                "La \"pila\" izquierda en la Figura 6 muestra la implementación de AGC con nuestro marco basado en servicios.",
                "La \"pila\" correcta muestra la misma implementación con un marco basado en eventos.",
                "Denotamos por ti (m) el tiempo entre el momento de enviar my el momento de entregar M en una máquina (\"pila\") i."
            ],
            "translated_text": "",
            "candidates": [
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "Pila",
                "Pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "Pila",
                "Pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "Stack",
                "Stack",
                "pila",
                "Pila",
                "Pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "PISTA",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila",
                "pila"
            ],
            "error": []
        },
        "module": {
            "translated_key": "módulo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to <br>module</br> composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol <br>module</br> can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol <br>module</br> of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show <br>module</br> interactions.",
                "For instance, protocol <br>module</br> P1 interacts with the protocol <br>module</br> Q1 and conversely (See Fig. 1).",
                "Protocol <br>module</br> Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol <br>module</br> Pi is an asynchronous call by Pi of another protocol <br>module</br>. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the <br>module</br> that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol <br>module</br> to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol <br>module</br> that triggers an event is not aware of the <br>module</br>(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol <br>module</br> consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol <br>module</br> may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol <br>module</br> can trigger an event is represented by an arrow starting from the <br>module</br>.",
                "A white trapezoid inside a <br>module</br> box represents a handler defined by the protocol <br>module</br>.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol <br>module</br> P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol <br>module</br> that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol <br>module</br> has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol <br>module</br> triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol <br>module</br> is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a <br>module</br> Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a <br>module</br> Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from <br>module</br> Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, <br>module</br> Q1 contains an executer bound to service interface t and a listener bound to service interface u. <br>module</br> Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol <br>module</br> T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, <br>module</br> T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When <br>module</br> Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol <br>module</br> Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol <br>module</br> Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol <br>module</br> emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol <br>module</br> generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol <br>module</br> Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol <br>module</br> Q1 in Figure 2 that triggers event g to emulate a request.",
                "<br>module</br> S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a <br>module</br> generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol <br>module</br> Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each <br>module</br> that issues a request to si.",
                "The same must be done for one executer that is part of a <br>module</br> that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol <br>module</br> Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, <br>module</br> interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting <br>module</br> Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the <br>module</br> P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate <br>module</br> Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the <br>module</br> P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol <br>module</br> issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol <br>module</br> issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol <br>module</br> Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD <br>module</br> implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT <br>module</br> provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. <br>module</br> implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM <br>module</br> provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Para validar nuestras afirmaciones, hemos implementado Samoa, un marco de protocolo experimental que se basa exclusivamente en el enfoque basado en servicios para la composición e implementación de \"módulo\".",
                "Tenga en cuenta que, a pesar de su nombre, una pila no está estrictamente en capas, 691, es decir, un \"módulo\" de protocolo puede interactuar con todos los demás módulos de protocolo en la misma pila, no solo con los módulos de protocolo directamente arriba y abajo.",
                "Escribimos Pi para denotar el \"módulo\" del protocolo de un protocolo P en la pila i.",
                "Las flechas muestran interacciones \"módulo\".",
                "Por ejemplo, el protocolo \"Módulo\" P1 interactúa con el protocolo \"Módulo\" Q1 y, por el contrario, (ver Fig. 1).",
                "Protocolo de interacciones \"módulo\".",
                "Una solicitud de un protocolo \"Módulo\" PI es una llamada asincrónica de PI de otro protocolo \"Módulo\".• Las respuestas son los resultados de una solicitud.",
                "Solo los módulos de protocolo que pertenecen al mismo protocolo que el \"módulo\" que ha emitido la solicitud se refiere a las respuestas correspondientes.",
                "Por ejemplo, una solicitud de PI genera respuestas que se refieren solo a los módulos de protocolo PJ.• Las notificaciones pueden ser utilizadas por un \"módulo\" de protocolo para informar (posiblemente muchos) módulos de protocolo en la misma pila sobre la aparición de un evento específico.",
                "Con los eventos, la comunicación es indirecta, es decir, un \"módulo\" de protocolo que desencadena un evento no es consciente del \"módulo\" que maneja el evento.",
                "En los marcos de protocolo basados en eventos, un \"módulo\" de protocolo consiste en un conjunto de manejadores.",
                "Los manejadores del mismo \"módulo\" del protocolo pueden compartir datos.",
                "El hecho de que un \"módulo\" de protocolo pueda activar un evento está representado por una flecha que comienza desde el \"módulo\".",
                "Un trapezoide blanco dentro de una caja de \"módulo\" representa un controlador definido por el protocolo \"módulo\".",
                "Por ejemplo, el protocolo \"Módulo\" P1 desencadena el evento E y maneja el evento F (ver Fig. 2).",
                "Tenga en cuenta que la red se representa como un \"módulo\" de protocolo especial que maneja el evento de envío (para enviar un mensaje a otra máquina) y desencadena el evento de entrega (al recibir un mensaje de otra máquina).",
                "Cada \"módulo\" de protocolo tiene que suscribirse a uno o muchos canales.",
                "Cuando un \"módulo\" de protocolo desencadena un evento E que especifica el canal C, todos los manejadores unidos a E que forman parte de un protocolo que se suscribe a C se ejecutan (en el orden prescrito por la definición del canal C).4.",
                "Un \"módulo\" de protocolo es un conjunto de ejecutores, oyentes e interceptores.",
                "Para asegurarse de que un solo oyente maneje una respuesta, un PI \"Módulo\" tiene que identificar, cada vez que emite una solicitud, el oyente para manejar la posible respuesta.",
                "El hecho de que un \"módulo\" PI pueda generar una solicitud a una interfaz de servicio SI está representado por una flecha negra discontinua que va de PI a SI.",
                "Del mismo modo, una flecha blanca discontinua que pasa de la interfaz de \"módulo\" a la interfaz de servicio SI representa el hecho de que PI puede generar una respuesta o una notificación a SI.",
                "En la Figura 3, el \"Módulo\" Q1 contiene un ejecutor vinculado a la interfaz de servicio T y un oyente vinculado a la interfaz de servicio u.El \"módulo\" Q1 puede generar respuestas y notificaciones a la interfaz de servicio T y solicita a la interfaz de servicio u.",
                "En la parte derecha de la figura, el interceptor del protocolo \"Módulo\" T1 está representado por una caja redondeada.",
                "Luego, el \"módulo\" T1 puede reenviar una solicitud REQ a la interfaz de servicio t, donde podemos tener req = req 1.",
                "Cuando el \"módulo\" Q1 emite una respuesta o una notificación, se usa un mecanismo similar, excepto que esta vez se ejecuta el inyerceptor del oyente de T1.",
                "Tenga en cuenta que un protocolo \"Módulo\" TI, que tiene un interceptor vinculado a una interfaz de servicio, puede modificar solicitudes, respuestas y notificaciones.",
                "La discusión se resume en la Tabla 1. 5.1 Interacciones del \"módulo\" del protocolo Un modelo natural de interacciones de protocolo (como se presenta en la Sección 2) facilita la implementación de módulos de protocolo.",
                "Por otro lado, en los marcos basados en eventos, un \"módulo\" de protocolo emula una solicitud activando un evento.",
                "Cuando un \"módulo\" de protocolo genera una respuesta en un marco basado en servicios, solo se ejecuta el oyente correcto (identificado en el momento en que se emitió la solicitud correspondiente).",
                "Esto asegura que una solicitud emitida por algún protocolo \"módulo\" Qi conduzca a respuestas manejadas por módulos de protocolo QJ (es decir, módulos de protocolo del mismo protocolo).",
                "Considere el protocolo \"Módulo\" Q1 en la Figura 2 que desencadena el evento G para emular una solicitud.",
                "\"Módulo\" S1 maneja la solicitud.",
                "Cuando un \"módulo\" genera una notificación a una interfaz de servicio SI, se ejecutan todos los oyentes vinculados a S.",
                "Tenga en cuenta que en este caso, las interfaces de servicio proporcionan el mismo patrón de comunicación que los eventos.5.2 Protocolo Las respuestas de composición del \"módulo\" (y a veces las notificaciones) son los resultados de una solicitud.",
                "Para componer una pila correcta, el compositor tiene que limitar a un oyente a la interfaz de servicio SI para cada \"módulo\" que emite una solicitud a SI.",
                "Lo mismo debe hacerse para un ejecutor que forme parte de un \"módulo\" que emite respuestas o notificaciones.",
                "El reemplazo de un protocolo P por un nuevo protocolo NEWP significa que un protocolo \"Módulo\" PI es reemplazado por NewPI en cada pila i.",
                "Q1 Q1 R1 P1 1P 1NEWP 1 REPLACIÓN - P1 REPLACIÓN - P1 R NEWP1 GG H H G T Figura 5: Reemplazo dinámico del protocolo P para los algoritmos de sincronización para que funcionen, las interacciones del \"módulo\" se interceptan para detectar un momento en que PI debe reemplazarse porNewpi.(Otras soluciones, por ejemplo, en [11], son más complejas.)",
                "El \"módulo\" de interceptación replic-P1 tiene un interceptor vinculado a la interfaz de servicio T que intercepta todas las solicitudes manejadas por los módulos P1 y todas las respuestas y notificaciones emitidas por P1.",
                "Por lo tanto, el código del \"módulo\" P1 puede permanecer sin cambios.",
                "En los marcos basados en eventos, la solución es agregar un \"módulo\" intermedio REPL-P1 que intercepta las solicitudes emitidas a P1 y también las respuestas y notificaciones emitidas por P1.",
                "La solución basada en el evento requiere modificar ligeramente el \"módulo\" P1 ya que en lugar de manejar el evento G y activar el evento H, P1 ahora debe manejar diferentes eventos G y H (ver Fig. 5).6.",
                "Cuando un \"módulo\" de protocolo emite una solicitud, puede dar un mensaje como argumento.",
                "Cuando un \"módulo\" de protocolo emite una respuesta a una interfaz de servicio, se emite una respuesta si uno de los argumentos de la respuesta es un mensaje que especifica a un oyente.",
                "Un objeto de servicio t es compatible con otro objeto de servicio si el tipo de argumentos de solicitudes (y respuestas) de t es un subtipo de los argumentos de solicitudes (y respuestas) de s.En la práctica, si un protocolo \"Módulo\" PI puede emitir una solicitud a un protocolo UDP, entonces también puede emitir una solicitud a TCP (compatible con UDP) debido a la relación de subtipo en los parámetros de los módulos de comunicación.",
                "El \"módulo\" FD implementa un detector de falla;Suponemos que garantiza la pila 1 UDP1RP2P1 REPL CT1 1ABC.",
                "El \"módulo\" de CT proporciona un servicio de consenso distribuido utilizando el algoritmo Chandratoueg [10].",
                "El ABC.\"Módulo\" implementa la transmisión atómica: una comunicación grupal primitiva que entrega mensajes a todos los procesos en el mismo orden.",
                "El \"módulo\" de GM proporciona un servicio de membresía grupal que mantiene datos de membresía consistentes entre los miembros del grupo (ver [19] para más detalles)."
            ],
            "translated_text": "",
            "candidates": [
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "módulo",
                "Módulo",
                "módulo",
                "módulo"
            ],
            "error": []
        },
        "request": {
            "translated_key": "solicitud",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A <br>request</br> by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a <br>request</br>.",
                "A single <br>request</br> can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the <br>request</br> are concerned by the corresponding replies.",
                "For example, a <br>request</br> by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a <br>request</br>. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A <br>request</br> issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the <br>request</br> is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a <br>request</br>, the listener to handle the possible reply.",
                "If the <br>request</br> and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a <br>request</br> to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a <br>request</br>, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a <br>request</br> req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a <br>request</br> req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a <br>request</br> is generated to a service interface.",
                "Each <br>request</br> is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a <br>request</br> by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding <br>request</br> was issued) is executed.",
                "This ensures that a <br>request</br> issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a <br>request</br>.",
                "Module S1 handles the <br>request</br>.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a <br>request</br>.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a <br>request</br> to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every <br>request</br> issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a <br>request</br> to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every <br>request</br> handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a <br>request</br>, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a <br>request</br> to a protocol UDP, then it may also issue a <br>request</br> to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Una \"solicitud\" de un módulo de protocolo PI es una llamada asincrónica de PI de otro módulo de protocolo.• Las respuestas son los resultados de una \"solicitud\".",
                "Una sola \"solicitud\" puede generar varias respuestas.",
                "Solo los módulos de protocolo que pertenecen al mismo protocolo que el módulo que ha emitido la \"solicitud\" se refiere a las respuestas correspondientes.",
                "Por ejemplo, una \"solicitud\" de PI genera respuestas que se refieren solo a los módulos de protocolo PJ.• Las notificaciones pueden ser utilizadas mediante un módulo de protocolo para informar (posiblemente muchos) módulos de protocolo en la misma pila sobre la aparición de un evento específico.",
                "Las notificaciones también pueden ser los resultados de una \"solicitud\".3.",
                "Una \"solicitud\" emitida a una interfaz de servicio SI conduce a la ejecución del ejecutor vinculado a SI.",
                "Si ningún ejecutor está vinculado a SI, la \"solicitud\" se retrasa hasta que algún ejecutor está vinculado a SI.",
                "Para asegurarse de que un solo oyente maneje una respuesta, un módulo PI tiene que identificar, cada vez que emite una \"solicitud\", el oyente para manejar la posible respuesta.",
                "Si la \"solicitud\" y la respuesta ocurren respectivamente, en Stack I y en Stack J, la interfaz de servicio SI en I Communicate a la interfaz de servicio SI en j El oyente que debe manejar la respuesta.",
                "El hecho de que un módulo Pi pueda generar una \"solicitud\" a una interfaz de servicio Si está representado por una flecha negra discontinua que va de PI a SI.",
                "Se activan cada vez que una \"solicitud\", una respuesta o una notificación se emite a la interfaz de servicio a la que están obligados.",
                "Cuando P1 emite una \"solicitud\" REQ a la interfaz de servicio T, se ejecuta el ejecutor-interceptor de T1.",
                "Luego, el módulo T1 puede reenviar una \"solicitud\" REQ a la interfaz de servicio t, donde podemos tener REQ = REQ 1.",
                "En los marcos basados en servicios, se genera una \"solicitud\" en una interfaz de servicio.",
                "Cada \"solicitud\" es manejada por la mayoría de un ejecutor, ya que solo permitimos que solo un ejecutor esté vinculado a una interfaz de servicio en cualquier momento.",
                "Por otro lado, en los marcos basados en eventos, un módulo de protocolo emula una \"solicitud\" activando un evento.",
                "Cuando un módulo de protocolo genera una respuesta en un marco basado en servicios, solo se ejecuta el oyente correcto (identificado en el momento en que se emitió la \"solicitud\" correspondiente).",
                "Esto asegura que una \"solicitud\" emitida por algún módulo de protocolo Qi Qi, conduzca a respuestas manejadas por módulos de protocolo QJ (es decir, módulos de protocolo del mismo protocolo).",
                "Considere el Módulo de Protocolo Q1 en la Figura 2 que desencadena el evento G para emular una \"solicitud\".",
                "El módulo S1 maneja la \"solicitud\".",
                "Tenga en cuenta que en este caso, las interfaces de servicio proporcionan el mismo patrón de comunicación que los eventos.5.2 Las respuestas de composición del módulo de protocolo (y a veces las notificaciones) son los resultados de una \"solicitud\".",
                "Para componer una pila correcta, el compositor tiene que limitar a un oyente a la interfaz de servicio SI para cada módulo que emite una \"solicitud\" a SI.",
                "La aplicación de esta metodología simple asegura que cada \"solicitud\" emitida a una interfaz de servicio SI finalmente resulte en varias respuestas o notificaciones emitidas a la misma interfaz de servicio SI.",
                "Además, nada evita que vincule un controlador que debería manejar una \"solicitud\" a un evento utilizado para emitir una respuesta.",
                "El módulo de interceptación replic-P1 tiene un interceptor vinculado a la interfaz de servicio t que intercepta cada \"solicitud\" manejada por los módulos P1 y todas las respuestas y notificaciones emitidas por P1.",
                "Cuando un módulo de protocolo emite una \"solicitud\", puede dar un mensaje como argumento.",
                "Un objeto de servicio t es compatible con otro objeto de servicio si el tipo de argumentos de solicitudes (y respuestas) de t es un subtipo de los argumentos de solicitudes (y respuestas) de s.En la práctica, si un módulo de protocolo PI puede emitir una \"solicitud\" a un protocolo UDP, entonces también puede emitir una \"solicitud\" a TCP (compatible con UDP) debido a la relación de subtipo en los parámetros de módulos de comunicación."
            ],
            "translated_text": "",
            "candidates": [
                "pedido",
                "solicitud",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "Solicitud",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "pedido",
                "solicitud",
                "solicitud"
            ],
            "error": []
        },
        "reply": {
            "translated_key": "respuesta",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A <br>reply</br> issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a <br>reply</br>, a module Pi has to identify, each time it issues a request, the listener to handle the possible <br>reply</br>.",
                "If the request and the <br>reply</br> occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the <br>reply</br>.",
                "If the listener that must handle the <br>reply</br> does not exist, the <br>reply</br> is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a <br>reply</br> or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a <br>reply</br> or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a <br>reply</br> or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a <br>reply</br> in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a <br>reply</br> (remember that a <br>reply</br> can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the <br>reply</br>.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a <br>reply</br>.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a <br>reply</br> or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the <br>reply</br>.",
                "When a protocol module issues a response to a service interface, a <br>reply</br> is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un solo oyente maneja una \"respuesta\" a una interfaz de servicio.",
                "Para asegurarse de que un solo oyente maneje una \"respuesta\", un módulo PI tiene que identificar, cada vez que emite una solicitud, el oyente para manejar la posible \"respuesta\".",
                "Si la solicitud y la \"respuesta\" ocurren respectivamente, en Stack I y en Stack J, la interfaz de servicio SI en I Communicate a la interfaz de servicio SI en j El oyente que debe manejar la \"respuesta\".",
                "Si el oyente que debe manejar la \"respuesta\" no existe, la \"respuesta\" se retrasa hasta que se crea el oyente.",
                "Del mismo modo, una flecha blanca discontinua que va del módulo Pi a la interfaz de servicio SI representa el hecho de que PI puede generar una \"respuesta\" o una notificación a SI.",
                "Se activan cada vez que una solicitud, una \"respuesta\" o una notificación se emite a la interfaz de servicio a la que están obligados.",
                "Cuando el módulo Q1 emite una \"respuesta\" o una notificación, se usa un mecanismo similar, excepto que esta vez se ejecuta el inyerceptor del oyente de T1.",
                "Cuando un módulo de protocolo genera una \"respuesta\" en un marco basado en servicios, solo se ejecuta el oyente correcto (identificado en el momento en que se emitió la solicitud correspondiente).",
                "Cuando los módulos SI desencadenan el evento H para emular una \"respuesta\" (recuerde que puede ocurrir una \"respuesta\" en muchas pilas), ambos módulos Qi y Ri manejarán la respuesta (ambos contienen un controlador vinculado a H).",
                "Este comportamiento no es correcto: solo los módulos de protocolo Qi deben manejar la \"respuesta\".",
                "Además, nada evita que vincule un controlador que debería manejar una solicitud a un evento utilizado para emitir una \"respuesta\".",
                "Una respuesta es una \"respuesta\" o una notificación.",
                "El mensaje puede especificar el oyente que debe manejar la \"respuesta\".",
                "Cuando un módulo de protocolo emite una respuesta a una interfaz de servicio, se emite una \"respuesta\" si uno de los argumentos de la respuesta es un mensaje que especifica a un oyente."
            ],
            "translated_text": "",
            "candidates": [
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "respuesta",
                "responder",
                "respuesta",
                "respuesta",
                "responder",
                "respuesta",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta",
                "responder",
                "respuesta"
            ],
            "error": []
        },
        "modularity": {
            "translated_key": "modularidad",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of dynamic protocol replacement and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "dynamic protocol replacement": {
            "translated_key": "Reemplazo de protocolo dinámico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Service Interface: A New Abstraction for Implementing and Composing Protocols∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ed´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.Rutti, Pawel.Wojciechowski, Andre.Schiper}@epfl.ch ABSTRACT In this paper we compare two approaches to the design of protocol frameworks - tools for implementing modular network protocols.",
                "The most common approach uses events as the main abstraction for a local interaction between protocol modules.",
                "We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols.",
                "It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols.",
                "We then describe an experimental implementation of a service-based protocol framework in Java.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Applications 1.",
                "INTRODUCTION Protocol frameworks, such Cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] and Neko[6, 20], are programming tools for developing modular network protocols.",
                "They allow complex protocols to be implemented by decomposing them into several modules cooperating together.",
                "This approach facilitates code reuse and customization of distributed protocols in order to fit the needs of different applications.",
                "Moreover, protocol modules can be plugged in to the system dynamically.",
                "All these features of protocol frameworks make them an interesting enabling technology for implementing adaptable systems [14] - an important class of applications.",
                "Most protocol frameworks are based on events (all frameworks cited above are based on this abstraction).",
                "Events are used for asynchronous communication between different modules on the same machine.",
                "However, the use of events raises some problems [4, 13].",
                "For instance, the composition of modules may require connectors to route events, which introduces burden for a protocol composer [4].",
                "Protocol frameworks such as Appia and Eva extend the event-based approach with channels.",
                "However, in our opinion, this solution is not satisfactory since composition of complex protocol stacks becomes more difficult.",
                "In this paper, we propose a new approach for building modular protocols, that is based on a service abstraction.",
                "We compare this new approach with the common, event-based approach.",
                "We show that protocol frameworks based on services have several advantages, e.g. allow for a fairly straightforward protocol composition, clear implementation, and better support of dynamic replacement of distributed protocols.",
                "To validate our claims, we have implemented SAMOA - an experimental protocol framework that is purely based on the service-based approach to module composition and implementation.",
                "The framework allowed us to compare the service- and event-based implementations of an adaptive group communication middleware.",
                "The paper is organized as follows.",
                "Section 2 defines general notions.",
                "Section 3 presents the main characteristics of event-based frameworks, and features that are distinct for each framework.",
                "Section 4 describes our new approach, which is based on service abstraction.",
                "Section 5 discusses the advantages of a service-based protocol framework compared to an event-based protocol framework.",
                "The description of our experimental implementation is presented in Section 6.",
                "Finally, we conclude in Section 7. 2.",
                "PROTOCOL FRAMEWORKS In this section, we describe notions that are common to all protocol frameworks.",
                "Protocols and Protocol Modules.",
                "A protocol is a distributed algorithm that solves a specific problem in a distributed system, e.g. a TCP protocol solves the reliable channel problem.",
                "A protocol is implemented as a set of identical protocol modules located on different machines.",
                "Protocol Stacks.",
                "A stack is a set of protocol modules (of different protocols) that are located on the same machine.",
                "Note that, despite its name, a stack is not strictly layered, 691 i.e. a protocol module can interact with all other protocol modules in the same stack, not only with the protocol modules directly above and below.",
                "In the remainder of this paper, we use the terms machine and stack interchangeably.",
                "Stack 1 S1 Q1 R1 P1 Network Figure 1: Example of a protocol stack In Figure 1, we show an example protocol stack.",
                "We represent protocol modules by capital letters indexed with a natural number, e.g.",
                "P1, Q1, R1 and S1.",
                "We write Pi to denote the protocol module of a protocol P in stack i.",
                "We use this notation throughout the paper.",
                "Modules are represented as white boxes.",
                "Arrows show module interactions.",
                "For instance, protocol module P1 interacts with the protocol module Q1 and conversely (See Fig. 1).",
                "Protocol Module Interactions.",
                "Below, we define the different kinds of interaction between protocol modules. • Requests are issued by protocol modules.",
                "A request by a protocol module Pi is an asynchronous call by Pi of another protocol module. • Replies are the results of a request.",
                "A single request can generate several replies.",
                "Only protocol modules belonging to the same protocol as the module that has issued the request are concerned by the corresponding replies.",
                "For example, a request by Pi generates replies that concern only protocol modules Pj. • Notifications can be used by a protocol module to inform (possibly many) protocol modules in the same stack about the occurrence of a specific event.",
                "Notifications may also be the results of a request. 3.",
                "EVENT-BASED PROTOCOL FRAMEWORK DESIGN Most existing protocol frameworks are event-based.",
                "Examples are Cactus [5, 2], Appia [1, 16] and Ensemble [12, 17].",
                "In this section, we define the notion of an event in protocol frameworks.",
                "We also explain how protocol modules are structured in event-based frameworks.",
                "Events.",
                "An event is a special object for indirect communication between protocol modules in the same stack.",
                "Events may transport some information, e.g. a network message or some other data.",
                "With events, the communication is indirect, i.e. a protocol module that triggers an event is not aware of the module(s) that handle the event.",
                "Events enable one-to-many communication within a protocol stack.",
                "Triggering an event can be done either synchronously or asynchronously.",
                "In the former case, the thread that triggers an event e is blocked until all protocol modules that handle e have terminated handling of event e. In the latter case, the thread that triggers the event is not blocked.",
                "Protocol Modules.",
                "In event-based protocol frameworks, a protocol module consists of a set of handlers.",
                "Each handler is dedicated to handling of a specific event.",
                "Handlers of the same protocol module may share data.",
                "Handlers can be dynamically bound to events.",
                "Handlers can also be unbound dynamically.",
                "Upon triggering some event e, all handlers bound to e are executed.",
                "If no handler is bound, the behavior is usually unspecified.",
                "Stack 1 P1 Q1 R1 S1 Network f e gg deliver send h Figure 2: Example of an event-based protocol stack In Figure 2, we show an example of an event-based stack.",
                "Events are represented by small letters, e.g. e, f, ...",
                "The fact that a protocol module can trigger an event is represented by an arrow starting from the module.",
                "A white trapezoid inside a module box represents a handler defined by the protocol module.",
                "To mark that some handler is bound to event e, we use an arrow pointing to the handler (the label on the arrow represents the event e).",
                "For example, the protocol module P1 triggers event e and handles event f (see Fig. 2).",
                "Note that the network is represented as a special protocol module that handles the send event (to send a message to another machine) and triggers the deliver event (upon receipt of a message from another machine).",
                "Specific Features.",
                "Some protocol frameworks have unique features.",
                "Below, we present the features that influence composition and implementation of protocol modules.",
                "In Cactus [5, 2], the programmer can give a priority number to a handler upon binding it to an event.",
                "When an event is triggered, all handlers are executed following the order of priority.",
                "A handler h is also able to cancel the execution of an event trigger: all handlers that should be executed after h according to the priority are not executed.",
                "Appia [1, 16] and Eva [3] introduce the notion of channels.",
                "Channels allow to build routes of events in protocol stacks.",
                "Each protocol module has to subscribe to one or many channels.",
                "All events are triggered by specifying a channel they belong to.",
                "When a protocol module triggers an event e specifying channel c, all handlers bound to e that are part of a protocol that subscribes to c are executed (in the order prescribed by the definition of channel c). 4.",
                "SERVICE-BASED PROTOCOL FRAMEWORK In this section, we describe our new approach for implementing and composing protocols that is based on services. 692 We show in Section 5 the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "Service Interface.",
                "In our service-based framework, protocol modules in the same stack communicate through objects called service interfaces.",
                "Requests, replies and notifications are all issued to service interfaces.",
                "Protocol Modules.",
                "A protocol module is a set of executers, listeners and interceptors.",
                "Executers handle requests.",
                "An executer can be dynamically bound to a service interface.",
                "It can be later unbound.",
                "A request issued to a service interface si leads to the execution of the executer bound to si.",
                "If no executer is bound to si, the request is delayed until some executer is bound to si.",
                "Contrary to events, at most one executer at any time can be bound to a service interface on every machine.",
                "Listeners handle replies and notifications.",
                "A listener can be dynamically bound and unbound to/from a service interface si.",
                "A notification issued to a service interface si is handled by all listeners bound to si in the local stack.",
                "A reply issued to a service interface is handled by one single listener.",
                "To ensure that one single listener handles a reply, a module Pi has to identify, each time it issues a request, the listener to handle the possible reply.",
                "If the request and the reply occur respectively, in stack i and in stack j, the service interface si on i communicates to the service interface si on j the listener that must handle the reply.",
                "If the listener that must handle the reply does not exist, the reply is delayed until the listener is created.",
                "Stack 1 P1 Q1 R1 S1 Network t u nt Figure 3: Example of a service-based protocol stack In Figure 3, we show an example of a service-based stack.",
                "We denote a service interface by a small letter (e.g. t, u and nt) in a hexagonal box.",
                "The fact that a module Pi can generate a request to a service interface si is represented by a dashed black arrow going from Pi to si.",
                "Similarly, a dashed white arrow going from module Pi to service interface si represents the fact that Pi can generate a reply or a notification to si.",
                "We represent executers with white boxes inside protocol modules and listeners with white boxes with a gray border.",
                "A connecting line between a service interface si and an executer e (resp. a listener l) shows that e (resp. l) is bound to si.",
                "In Figure 3, module Q1 contains an executer bound to service interface t and a listener bound to service interface u. Module Q1 can generate replies and notifications to service interface t and requests to service interface u.",
                "Note that the service interface nt allows to access the network.",
                "P1 Q1 P1 Q1 T1T1 t t t Figure 4: Execution of protocol interactions with interceptors An interceptor plays a special rˆole.",
                "Similarly to executers, interceptors can be dynamically bound or unbound to a service interface.",
                "They are activated each time a request, a reply or a notification is issued to the service interface they are bound to.",
                "This is illustrated in Figure 4.",
                "In the right part of the figure, the interceptor of the protocol module T1 is represented by a rounded box.",
                "The interceptor is bound to service interface t. The left part of the figure shows that an interceptor can be seen as an executer plus a listener.",
                "When P1 issues a request req to the service interface t, the executer-interceptor of T1 is executed.",
                "Then, module T1 may forward a request req to the service interface t, where we can have req = req 1 .",
                "When module Q1 issues a reply or a notification, a similar mechanism is used, except that this time the listener-interceptor of T1 is executed.",
                "Note that a protocol module Ti, that has an interceptor bound to a service interface, is able to modify requests, replies and notifications.",
                "Upon requests, if several interceptors are bound to the same service interface, they are executed in the order of binding.",
                "Upon replies and notifications, the order is reversed. 5.",
                "ADVANTAGES OF SERVICE-BASED PROTOCOL FRAMEWORK DESIGN We show in this section the advantages of service-based protocol frameworks over event-based protocol frameworks.",
                "We structure our discussion in three parts.",
                "Firstly, we present how protocol interactions are modeled in each of the protocol frameworks.",
                "Then, we discuss the composition of protocol modules in each of these frameworks.",
                "Finally, we present the problem of <br>dynamic protocol replacement</br> and the advantages of service interfaces in order to implement it.",
                "The discussion is summarized in Table 1. 5.1 Protocol Module Interactions A natural model of protocol interactions (as presented in Section 2) facilitates the implementation of protocol modules.",
                "For each protocol interaction, we show how it is modeled in both frameworks.",
                "We also explain that an inadequate model may lead to problems.",
                "Requests.",
                "In service-based frameworks, a request is generated to a service interface.",
                "Each request is handled by at most one executer, since we allow only one executer to be bound to a service interface at any time.",
                "On the other hand, in event-based frameworks, a protocol module emulates a request by triggering an event.",
                "There is no guarantee 1 The two service interfaces t in the left part of Figure 4 represent the same service interface t. The duplication is only to make the figure readable. 693 that this event is bound to only one handler, which may lead to programming errors.",
                "Replies.",
                "When a protocol module generates a reply in a service-based framework, only the correct listener (identified at the time the corresponding request was issued) is executed.",
                "This ensures that a request issued by some protocol module Qi, leads to replies handled by protocol modules Qj (i.e. protocol modules of the same protocol).",
                "This is not the case in event-based frameworks, as we now show.",
                "Consider protocol module Q1 in Figure 2 that triggers event g to emulate a request.",
                "Module S1 handles the request.",
                "When modules Si triggers event h to emulate a reply (remember that a reply can occur in many stacks), both modules Qi and Ri will handle the reply (they both contain a handler bound to h).",
                "This behavior is not correct: only protocol modules Qi should handle the reply.",
                "Moreover, as modules Ri are not necessarily implemented to interact with modules Qi, this behavior may lead to errors.",
                "Solutions to solve this problem exist.",
                "However, they introduce an unnecessary burden on the protocol programmers and the stack composer.",
                "For instance, channels allow to route events to ensure that modules handle only events concerning them.",
                "However, the protocol programmer must take channels into account when implementing protocols.",
                "Moreover, the composition of complex stacks becomes more difficult due to the fact that the composer has to create many channels to ensure that modules handle events correctly.",
                "An addition of special protocol modules (named connectors) for routing events is also not satisfactory, since it requires additional work from the composer and introduces overhead.",
                "Notifications.",
                "Contrary to requests and replies, notifications are well modeled in event-based frameworks.",
                "The reason is that notifications correspond to the one-to-many communication scheme provided by events.",
                "In service-based frameworks, notifications are also well modeled.",
                "When a module generates a notification to a service interface si, all listeners bound to s are executed.",
                "Note that in this case, service interfaces provide the same pattern of communication as events. 5.2 Protocol Module Composition Replies (and sometimes notifications) are the results of a request.",
                "Thus, there is a semantic link between them.",
                "The composer of protocol modules must preserve this link in order to compose correct stacks.",
                "We explain now that service based frameworks provide a mechanism to preserve this link, while in event-based frameworks, the lack of such mechanism leads to error-prone composition.",
                "In service-based frameworks, requests, replies and notifications are issued to a service interface.",
                "Thus, a service interface introduces a link between these interactions.",
                "To compose a correct stack, the composer has to bound a listener to service interface si for each module that issues a request to si.",
                "The same must be done for one executer that is part of a module that issues replies or notifications.",
                "Applying this simple methodology ensures that every request issued to a service interface si eventually results in several replies or notifications issued to the same service interface si.",
                "In event-based frameworks, all protocol interactions are issued through different events: there is no explicit link between an event triggered upon requests and an event triggered upon the corresponding replies.",
                "Thus, the composer of a protocol stack must know the meaning of each event in order to preserve the semantic link between replies (and notifications) and requests.",
                "Moreover, nothing prevents from binding a handler that should handle a request to an event used to issue a reply.",
                "Note that these problems can be partially solved by typing events and handlers.",
                "However, it does not prevent from errors if there are several instances of the same event type.",
                "Note that protocol composition is clearer in the protocol frameworks that are based on services, rather than on events.",
                "The reason is that several events that are used to model different protocol interactions can be modeled by a single service interface. 5.3 Dynamic Replacement of Protocols Dynamic replacement of protocols consists in switching on-the-fly between protocols that solve the same problem.",
                "Replacement of a protocol P by a new protocol newP means that a protocol module Pi is replaced by newPi in every stack i.",
                "This replacement is problematic since the local replacements (within stacks) must be synchronized in order to guarantee protocol correctness [21, 18].",
                "Q1 Q1 R1 P1 1P 1newP 1 Repl−P1 Repl−P1 R newP1 gg h h g t Figure 5: Dynamic replacement of protocol P For the synchronization algorithms to work, module interactions are intercepted in order to detect a time when Pi should be replaced by newPi. (Other solutions, e.g. in [11], are more complex.)",
                "In Fig. 5, we show how this interception can be implemented in protocol frameworks that are based on services (in the left part of the figure) and events (in the right part of the figure).",
                "The two-sided arrows point to the protocol modules P1 and newP1 that are switched.",
                "It can be seen that the approach that uses the Service Interface mechanism has advantages.",
                "The intercepting module Repl-P1 has an interceptor bound to service interface t that intercepts every request handled by modules P1 and all replies and notifications issued by P1.",
                "The code of the module P1 can therefore remain unchanged.",
                "In event-based frameworks, the solution is to add an intermediate module Repl-P1 that intercepts the requests issued to P1 and also the replies and notifications issued by P1.",
                "Although this ad-hoc solution may seem similar to the servicebased approach, there is an important difference.",
                "The eventbased solution requires to slightly modify the module P1 since instead of handling event g and triggering event h, P1 must now handle different events g and h (see Fig. 5). 6.",
                "IMPLEMENTATION We have implemented an experimental service-based protocol framework (called SAMOA) [7].",
                "Our implementation is light-weight: it consists of approximately 1200 lines of code in Java 1.5 (with generics).",
                "In this section, we describe the main two classes of our implementation: Service (encoding the Service Interface) and 694 service-based event-based Protocol Interaction an adequate an inadequate representation representation Protocol Composition clear and safe complex and error-prone Dynamic Replacement an integrated ad-hoc solutions mechanism Table 1: Service-based vs. event-based Protocol (encoding protocol modules).",
                "Finally, we present an example protocol stack that we have implemented to validate the service-based approach.",
                "The Service Class.",
                "A Service object is characterized by the arguments of requests and the arguments of responses.",
                "A response is either a reply or a notification.",
                "A special argument, called message, determines the kind of interactions modeled by the response.",
                "A message represents a piece of information sent over the network.",
                "When a protocol module issues a request, it can give a message as an argument.",
                "The message can specify the listener that must handle the reply.",
                "When a protocol module issues a response to a service interface, a reply is issued if one of the arguments of the response is a message specifying a listener.",
                "Otherwise, a notification is issued.",
                "Executers, listeners and interceptors are encoded as innerclasses of the Service class.",
                "This allows to provide type-safe protocol interactions.",
                "For instance, executers can only be bound to the Service object, they belong to.",
                "Thus, the parameters passed to requests (that are verified statically) always correspond to the parameters accepted by the corresponding executers.",
                "The type of a Service object is determined by the type of the arguments of requests and responses.",
                "A Service object t is compatible with another Service object s if the type of the arguments of requests (and responses) of t is a subtype of the arguments of requests (and responses) of s. In practice, if a protocol module Pi can issue a request to a protocol UDP, then it may also issue a request to TCP (compatible with UDP) due to the subtyping relation on parameters of communicating modules.",
                "The Protocol Class.",
                "A Protocol object consists of three sets of components, one set for each component type (a listener, an executer, and an interceptor).",
                "Protocol objects are characterized by names to retrieve them easily.",
                "Moreover, we have added some features to bind and unbind all executers or interceptors to/from the corresponding Service objects.",
                "Protocol objects can be loaded to a stack dynamically.",
                "All these features made it easy to implement dynamic replacement of network protocols.",
                "Protocol Stack Implementation.",
                "To validate our ideas, we have developed an Adaptive Group Communication (AGC) middleware, adopting both the service- and the event-based approaches.",
                "Fig. 6 shows the corresponding stacks of the AGC middleware.",
                "Both stacks allow the Consensus and Atomic Broadcast protocols to be dynamically updated.",
                "The architecture of our middleware, shown in Fig. 6, builds on the group communication stack described in [15].",
                "The UDP and RP2P modules provide respectively, unreliable and reliable point-to-point transport.",
                "The FD module implements a failure detector; we assume that it ensures the Stack 1 UDP1RP2P1 Repl CT1 1ABc.",
                "Repl CT1 ABc.1 Network FD1 GM1 rp2p nt udp d f abcast consensus Stack 1 Repl CT1 1ABc.",
                "Repl ABc.1 UDP1 FD1 RP2P1 CT1 Network 1GM send deliver Figure 6: Adaptive Group Communication Middleware: service-based (left) vs. event-based (right) properties of the 3S failure detector [9].",
                "The CT module provides a distributed consensus service using the ChandraToueg algorithm [10].",
                "The ABc. module implements atomic broadcast - a group communication primitive that delivers messages to all processes in the same order.",
                "The GM module provides a group membership service that maintains consistent membership data among group members (see [19] for details).",
                "The Repl ABc. and the Repl CT modules implement the replacement algorithms [18] for, respectively, the ABc. and the CT protocol modules.",
                "Note that each arrow in the event-based architecture represents an event.",
                "We do not name events in the figure for readability.",
                "The left stack in Figure 6 shows the implementation of AGC with our service-based framework.",
                "The right stack shows the same implementation with an event-based framework.",
                "Performance Evaluation.",
                "To evaluate the overhead of service interfaces, we compared performance of the serviceand event-based implementations of the AGC middleware.",
                "The latter implementation of AGC uses the Cactus protocol framework [5, 2].",
                "In our experiment, we compared the average latency of Atomic Broadcast (ABcast), which is defined as follows.",
                "Consider a message m sent using ABcast.",
                "We denote by ti(m) the time between the moment of sending m and the moment of delivering m on a machine (stack) i.",
                "We define the average latency of m as the average of ti(m) for all machines (stacks) i within a group of stacks.",
                "Performance tests have been made using a cluster of PCs running Red Hat Linux 7.2, where each PC has a Pentium III 766 MHz processor and 128MB of RAM.",
                "All PCs are interconnected by a 100 Base-TX duplex Ethernet hub.",
                "Our experiment has involved 7 machines (stacks) that ABcast messages of 4Mb under a constant load, where a load is a number of messages per second.",
                "In Figure 7, we show the results of our experiment for different loads.",
                "Latencies are shown on the vertical axis, while message loads are shown on the horizontal axis.",
                "The solid line shows the results obtained with our service-based framework.",
                "The dashed line shows the results obtained with the Cactus framework.",
                "The 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatency[ms] Load [msg/s] Service-Based Framework Cactus Figure 7: Comparison between our service-based framework and Cactus overhead of the service-based framework is approximately 10%.",
                "This can be explained as follows.",
                "Firstly, the servicebased framework provides a higher level abstraction, which has a small cost.",
                "Secondly, the AGC middleware was initially implemented and optimized for the event-based Cactus framework.",
                "However, it is possible to optimize the AGC middleware for the service-based framework. 7.",
                "CONCLUSION In the paper, we proposed a new approach to the protocol composition that is based on the notion of Service Interface, instead of events.",
                "We believe that the service-based framework has several advantages over event-based frameworks.",
                "It allows us to: (1) model accurately protocol interactions, (2) reduce the risk of errors during the composition phase, and (3) simply implement dynamic protocol updates.",
                "A prototype implementation allowed us to validate our ideas. 8.",
                "REFERENCES [1] The Appia project.",
                "Documentation available electronically at http://appia.di.fc.ul.pt/. [2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu.",
                "Coyote: a system for constructing fine-grain configurable communication services.",
                "ACM Transactions on Computer Systems, 16(4):321-366, November 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin, and Jean-Pierre Le Narzul.",
                "Eva: An event-based framework for developing specialized communication protocols.",
                "In Proceedings of the 1st IEEE International Symposium on Network Computing and Applications (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena, and Uwe Nestmann.",
                "Protocol composition frameworks.",
                "A header-driven model.",
                "In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications (NCA 05), July 2005. [5] The Cactus project.",
                "Documentation available electronically at http://www.cs.arizona.edu/ cactus/. [6] The Neko project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/neko/. [7] The SAMOA project.",
                "Documentation available electronically at http://lsrwww.epfl.ch/samoa/. [8] The SDL project.",
                "Documentation available electronically at http://www.sdl-forum.org/SDL/. [9] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg.",
                "The weakest failure detector for solving consensus.",
                "Journal of the ACM, 43(4):685-722, 1996. [10] Tushar Deepak Chandra and Sam Toueg.",
                "Unreliable failure detectors for reliable distributed systems.",
                "Journal of the ACM, 43(2):225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen, and Richard D. Schlichting.",
                "Constructing adaptive software in distributed systems.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing System (ICDCS 01), April 2001. [12] The Ensemble project.",
                "Documentation available electronically at http://www.cs.cornell.edu/Info/ Projects/Ensemble/. [13] Richard Ekwall, Sergio Mena, Stefan Pleisch, and Andr´e Schiper.",
                "Towards flexible finite-state-machine-based protocol composition.",
                "In Proceedings of the 3rd IEEE International Symposium on Network Computing and Applications (NCA 04), August 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.",
                "Composing adaptive software.",
                "IEEE Computer, 37(7):56-64, 2004. [15] Sergio Mena, Andr´e Schiper, and Pawel T. Wojciechowski.",
                "A step towards a new generation of group communication systems.",
                "In Proceedings of the 4th ACM/IFIP/USENIX International Middleware Conference (Middleware 03), LNCS 2672, June 2003. [16] Hugo Miranda, Alexandre Pinto, and Lu´ıs Rodrigues.",
                "Appia, a flexible protocol kernel supporting multiple coordinated channels.",
                "In Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS 01), April 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao, and Danny Dolev.",
                "The architecture and performance of security protocols in the Ensemble group communication system.",
                "Technical Report TR-98-1703, Computer Science Department, Cornell University, September 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski, and Andr´e Schiper.",
                "Dynamic update of distributed agreement protocols.",
                "TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), March 2005. [19] Andr´e Schiper.",
                "Dynamic Group Communication.",
                "Technical Report IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´ed´erale de Lausanne (EPFL), April 2003.",
                "To appear in ACM Distributed Computing. [20] P´eter Urb´an, Xavier D´efago, and Andr´e Schiper.",
                "Neko: A single environment to simulate and prototype distributed algorithms.",
                "In Proceedings of the 15th International Conference on Information Networking (ICOIN 01), February 2001. [21] Pawel T. Wojciechowski and Olivier R¨utti.",
                "On correctness of dynamic protocol update.",
                "In Proceedings of the 7th IFIP Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 05), LNCS 3535.",
                "Springer, June 2005. 696"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Finalmente, presentamos el problema del \"reemplazo de protocolo dinámico\" y las ventajas de las interfaces de servicio para implementarlo."
            ],
            "translated_text": "",
            "candidates": [
                "Reemplazo de protocolo dinámico",
                "reemplazo de protocolo dinámico"
            ],
            "error": []
        }
    }
}