{
    "id": "C-22",
    "original_text": "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware. The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects. A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system. The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead. Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1. INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications. One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage. Effective adaptation requires detailed and up to date information about both the system and the software itself. Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8]. Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required. For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4]. On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves. With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process. In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them. Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications. This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine. Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3). The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3. Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2. BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain. Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts. At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13]. A runtime is a container process for the management of mobile objects. For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads. The applications themselves comprise mobile objects, which interact with each other through proxies [14]. Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with. Upon migration, proxy objects move with the source object. The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components. Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects. Secondly, MobJeX has a per-application mobile object container called a transport manager (TM). As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case. Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3. METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration. The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated. Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment. It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios. As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation. This subset is listed below and categorised according to metric type. Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1. Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2. Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3. Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec). Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario. As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU. Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack. In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call. Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured. Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service. However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime. The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself. NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer. In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller. In order to collect IT metrics, another additional metric is needed. Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET. The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation. Once the Response Time (RT) is known, IT can derived by subtracting RT from ET. Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e. RT measured in the proxy, ET measured in the method body of the object implementation. In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object). Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there. The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application. To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively. In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load. Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread. Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework. The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection. Note that this containment captures the different granularity of measurement attributes and their corresponding metrics. Consider the case of measuring memory consumption. At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method. As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation. The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level. Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9]. However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process. Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine. Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine). A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9]. Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call. Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive. Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine. Consequently, an abstract representation or model [17] of the system needs to be maintained. Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system. Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects). Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine. The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine. This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not. This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested. These four criteria are described in the following subsections. Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not. This is most useful in the case where it is expensive to measure a particular metric. Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained. Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history. Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer. This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing. A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer. A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery. Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer. Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below. This decision making is facilitated by the notifications received from individual Metric objects as described above. A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity. For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed. A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process. Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer. The purpose of this criterion is twofold. For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved. For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer. Furthermore, this criterion is evaluated using information from two sources. Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target. In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers. Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1. Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers. Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject. This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times. A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent. Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e. TransportManager) have undergone substantial changes. For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push. With shallow push, a list of metrics containers that contain updated metrics is pushed. In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics. In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4. EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead. All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08. The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario. Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system. In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests. The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured. In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine. All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted. Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario. It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear. Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains. Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2. Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach. Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself. In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion. This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation. Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics. These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5]. Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance. The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3. Performance characteristics with simple criteria 5. SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware. Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria. In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy. A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead. While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria. One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push. Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured. Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper. Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6. REFERENCES 1. Katz, R.H., Adaptation and Mobility in Wireless Information Systems. IEEE Personal Communications, 1994. 1: p. 6-17. 2. Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3. Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4. Noble, B.D., et al. Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997. Saint-Malo, France. 5. Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005. Larnaca, Cyprus: SpringerVerlag. 6. Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004. Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8. Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003. Sydney: IEEE. 9. Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005. Como, Italy. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf. Software Engineering (ICSE99). 1999: ACM Press. 13. Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java. Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl. Conference on Distributed Computing Systems. 1986. Cambridge, Mass. (USA): IEEE. 15. Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16. Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., and Bolmsjö, G.S. Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999. Phoenix, Arizona. 18. Waldo, J., Remote Procedure Calls and Java Remote Method Invocation. IEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. and Lin, B. Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994. Toronto, Canada. 20. Henricksen, K. and Indulska, J. A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004. Orlando.",
    "original_translation": "Recopilación de métricas de tiempo de ejecución para el middleware Adaptación de aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne,Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa el peor de los casos de rendimiento, una estrategia de recolección de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móvil y admitir middleware. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico que incluye gerentes de host, tiempos de ejecución y objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y la propagación de métricas a través del sistema. La plataforma MobJex se utilizó como base para la implementación y las pruebas con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, la eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de la recolección. Categorías y descriptores de sujetos c.2.4 Sistemas distribuidos;D.2.8 Métricas Medición de términos generales, rendimiento.1. Introducción Las diferentes capacidades de los dispositivos móviles, más la velocidad variable, la tasa de error y las características de desconexión de las redes móviles [1], dificultan predecir de antemano el entorno de ejecución exacta de las aplicaciones móviles. Una solución que recibe una atención cada vez mayor en la comunidad de investigación es la adaptación de la aplicación [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como la red, el procesador o el uso de la memoria. La adaptación efectiva requiere información detallada y actualizada sobre el sistema y el software en sí. Las métricas relacionadas con la información del sistema (por ejemplo, procesador, memoria y carga de red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas requeridas para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifican en respuesta a los cambios en el entorno de tiempo de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de los objetos [6], también requiere métricas de software detalladas [9] ya que la colocación de objetos depende de las características de ejecución de los objetos móviles. Con la excepción de Mobjex [6], los sistemas de objetos móviles existentes como Voyager [10], Fargo [11, 12] y Javaparty [13] no proporcionan una adaptación automatizada y, por lo tanto, carecen del proceso de recolección de métricas requerido para respaldar este proceso. En el caso de MobJex, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas sintéticas pre-escritas ya que hay poco trabajo previo en la colección dinámica de métricas de software en marcos de objetos móviles, y no hay medios existentes derecolectándolos automáticamente. En consecuencia, la principal contribución de este documento es una solución para la colección de métricas dinámicas para admitir la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicaciones y middleware, y por lo tanto, la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados propagados de manera eficiente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recolectar cada métrica no se fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión en función de la eficiencia de la solución elegida (ver Sección 3). El resto de este documento se organiza de la siguiente manera: la Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recolección, propagación y entrega de métricas como se describe en la Sección 3. La Sección 4 describe algunas pruebas y resultados iniciales y la Sección 5 se cierra con un resumen, conclusiones y discusión del trabajo futuro.2. Antecedentes en general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos se etiqueten como objetos móviles, proporcionando soporte de middleware para que dichos objetos se muevan en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso de contenedor para la administración de objetos móviles. Por ejemplo, en Fargo [15] este componente se conoce como un núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso con MobJex, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizandohilos. Las aplicaciones en sí comprenden objetos móviles, que interactúan entre sí a través de proxies [14]. Se requieren proxies, que tienen la misma interfaz de método que el objeto en sí mismo pero agregan la comunicación remota y la funcionalidad de seguimiento de objetos, para cada objeto objetivo con el que se comunica un objeto fuente. Tras la migración, los objetos proxy se mueven con el objeto de origen. El sistema MobJex basado en Java, que se utiliza como plataforma de implementación para la solución de recolección de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un gerente de host (conocido como servicio en Mobjex) proporciona un punto de comunicación central al ejecutar en un puerto conocido por host por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución o objetos móviles. En segundo lugar, MobJex tiene un contenedor de objetos móviles por aplicación llamado Administrador de transporte (TM). Como tal, los gerentes de host y de transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJex puede tener un controlador de sistema centralizado que incorpore un motor de adaptación global para realizar una optimización del sistema.3. Colección de métricas Esta sección analiza el diseño y la derivación de una solución para recopilar métricas para apoyar la adaptación de las aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJex, se discute en su mayor parte en términos genéricos, excepto que explícitamente es específico de MobJex.3.1 Selección de métricas Las métricas de Ryan y Rossi [9] se han elegido como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles, además de haber sido derivadas de una serie de modelos matemáticos y validados empíricamente validados. Además, se demostró empíricamente las métricas para mejorar el rendimiento de la aplicación en un escenario de adaptación real después de un cambio en el entorno de ejecución. Sin embargo, estaría más allá del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9] y, por lo tanto, para proporcionar un subconjunto útil no aleatorio, elegimos implementar el conjunto mínimo de métricas necesarias para implementarAdaptación local y global [9] y, por lo tanto, satisface una variedad de escenarios de adaptación reales. Como tal, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a respaldar la implementación de las métricas restantes, así como otras métricas no especificadas, como las relacionadas con la calidad y la utilización de recursos. Este subconjunto se enumera a continuación y se clasifica de acuerdo con el tipo métrico. Tenga en cuenta que algunas métricas adicionales se utilizaron para fines de implementación para obtener métricas centrales o ayudar a la evaluación, y como tal se definen en contexto cuando corresponda.1. Métricas de software: número de invocaciones (NI), la frecuencia de las invocaciones en métodos de una clase.2. Métricas de rendimiento: tiempo de ejecución del método (ET), el tiempo necesario para ejecutar un cuerpo de método (MS).- Tiempo de invocación del método (IT), el tiempo necesario para invocar un método, excluyendo el tiempo de ejecución del método (MS).3. Métricas de utilización de recursos: uso de memoria (MU), el uso de la memoria de un proceso (en bytes).- Uso del procesador (PU), el porcentaje de la carga de la CPU de un host.- Uso de la red (NU), el ancho de banda de la red entre dos hosts (en bytes/seg). Los siguientes son breves ejemplos de varias de estas métricas para demostrar su uso en un escenario de adaptación. A medida que aumenta el uso del procesador (PU) en cierto host, el tiempo de ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], lo que facilita la decisión de mover un objeto con alto ET a otro host con bajoPU. El tiempo de invocación (IT) muestra la sobrecarga de invocar un determinado método, con la sobrecarga de invocación de los parámetros de ensarching y la transmisión de datos remotos para una llamada remota que sean órdenes de magnitud más altas que el costo de presionar y hacer estallar datos de la pila de llamadas de método. En otras palabras, la invocación del método remoto es costosa y, por lo tanto, debe evitarse a menos que las ganancias obtengan un objeto a un host con más potencia de procesamiento (reduciendo así ET) superan a la mayor cantidad de la llamada remota. Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 Medición de métricas Esta subsección analiza cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el marco de objetos móviles se deben medir tales métricas. De las métricas de recursos ambientales, el uso del procesador (PU) y el uso de la red (NU) se relacionan con una máquina individual y, por lo tanto, se pueden medir directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJex. Sin embargo, el uso de la memoria (MU), que representa el estado de memoria de un proceso de ejecución en lugar del uso de memoria de un host, debe recolectarse dentro de un tiempo de ejecución individual. La medición del número de métricas de invocaciones (NI) y tiempo de ejecución (ET) también se puede realizar mediante medición directa, sin embargo, en este caso dentro de la implementación de objetos móviles (Mobject). Ni implica simplemente incrementar un valor de contador al comienzo o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al comienzo del método y deteniéndolo al finaldel método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recopilación de tiempo de invocación (IT) no es tan sencillo porque el tiempo necesario para invocar un método solo se puede medir después de que el método termina su ejecución y regresa a la persona que llama. Para recolectar métricas, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrica (RT), como el tiempo total tomado para una llamada de método a la finalización, que es la suma de IT y ET. El tiempo de respuesta se puede medir directamente utilizando la misma técnica basada en el temporizador utilizada para medir ET, aunque al comienzo y al final de la llamada proxy en lugar de la implementación del método. Una vez que se conoce el tiempo de respuesta (RT), puede derivarse restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores RT y ET de los cuales se derivan se miden por la necesidad utilizando el código de temporizador en diferentes ubicaciones, es decir, RT medido en el proxy, ET medido en el cuerpo del método de la implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de Mobjex, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente para un objeto móvil (mobject) tener referencias hacia atrás a todos los muchos proxies que referenIT (uno por objeto de origen). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la Sección 3.5 en el que la métrica RT se empuja al mobjeto para que pueda derivarse del valor ET almacenado allí. El valor derivado del mismo se almacena y se propaga aún más según sea necesario de acuerdo con los criterios de la Sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de medición El enfoque de encuesta se identificó como el método más apropiado para recolectar métricas de utilización de recursos, como el uso del procesador (PU), el uso de la red (NU) y el uso de la memoria (MU), ya que no son parte del flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos encuesta el sistema operativo para la CPU actual o la carga de red respectivamente. En el caso del uso de la memoria (MU), la máquina virtual Java (JVM) [16] está encuestada para la carga de memoria actual. Tenga en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de encuesta debe hacerse de manera asincrónica en un hilo separado. Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación se agregan en un metro de metroiner con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que les permite propagarse fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan entregarse al motor de adaptación, como se discute en la siguiente subsección. Tenga en cuenta que esta contención captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considere el caso de medir el consumo de memoria. En un nivel grueso de granularidad, esto podría medirse para una aplicación completa o incluso un sistema, pero también podría medirse a nivel de un objeto individual;o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en la movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representan tanto la duración de una ejecución del método como la sobrecarga de una invocación de método. El uso de contenedores de métricas facilita la recolección de métricas a niveles de granularidad que van desde una sola máquina hasta el nivel de método individual. Tenga en cuenta que algunos contenedores de métricas no contienen ningún objeto métrico, ya que como se describió anteriormente, la implementación de la muestra usa solo un subconjunto de las métricas de adaptación de [9]. Sin embargo, en aras de la consistencia y para promover la flexibilidad en términos de agregar nuevas métricas en el futuro, estos contenedores todavía se consideran en el diseño actual para la integridad y el trabajo futuro.3.5 Propagación y entrega de métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas del administrador/servicio del host (o tiempo de ejecución si el administrador del host no está presente) al motor de adaptación. Con respecto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, objeto móvil), la métrica se presiona (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, tiempo de ejecucióno Manager de transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de mobjetos cambiados) se empujará al siguiente componente de nivel (es decir, el administrador del host o la adaptaciónmotor). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local es realizada por un motor que se ejecuta en el host local (por ejemplo, en Mobjex, esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada local entre procesos. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas es a través de una llamada remota, y en el caso de que existan múltiples tiempos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de latencia de comunicación de red, es importante que el gerente del host pase tantas métricas como sea posible al motor de adaptación en una sola invocación, lo que implica la necesidad de reunir estas métricas en el gerente del host, a través de alguna forma de empuje.o propagación, antes de enviarlos al motor de adaptación. En consecuencia, se debe mantener una representación abstracta o modelo [17] del sistema. Tal modelo contendría entidades modelo, correspondientes a cada uno de los componentes del sistema principal, conectados en un árbol como la jerarquía, que refleja con precisión la estructura y la jerarquía de contención del sistema real. Adjuntar los contenedores de métricas a las entidades modeladas permite que una entidad modelo que represente a un administrador de host se entregue al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo puede reutilizarse para la propagación, sino que también proporciona un medio efectivo para entregar información de métricas del administrador del huésped al motor de adaptación. La relación entre las entidades modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de propagación y entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), para queReduzca la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterio que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe tomarse o no. Este enfoque fue diseñado de tal manera que cada vez que no se satisface un solo criterio, los criterios posteriores no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio métrico de medición: este criterio está unido a los objetos métricos individuales para decidir si un nuevo valor métrico debe medirse o no. Esto es más útil en el caso en que es costoso medir una métrica particular. Además, este criterio puede usarse como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga la historia métrica. Ejemplos simples se basarían en el tiempo o la frecuencia, mientras que los criterios más complejos podrían ser específicos de dominio para una métrica particular o basada en la información almacenada en el historial de métricas. Notifique el criterio del contenedor de métricas: este criterio también se adjunta a objetos métricos individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto métrico debe notificar a su MetricScontainer. Esto se basa en la suposición de que puede haber casos en los que es deseable medir y almacenar una métrica en la historia para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativo como para notificar al MetricScontainer para su posterior procesamiento. Un ejemplo simple de este criterio sería un umbral basado en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de algún interés para el MetricScontainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para garantizar un procesamiento adicional y una posible entrega de métricas. Notifique el criterio de la entidad del modelo: a diferencia de los dos criterios anteriores, este criterio está asociado con un metrográfico. Dado que un MetricScontainer puede tener múltiples objetos métricos, de los cuales tiene conocimiento de dominio explícito, es capaz de determinar si, cuándo y cuántas de estas métricas deben propagarse a la modelos de entorno y, por lo tanto, convertirse en candidatos para ser parte del modelo de modelos jerárquicos.Proceso como se describe a continuación. Esta toma de decisiones se ve facilitada por las notificaciones recibidas de objetos métricos individuales como se describió anteriormente. Una implementación simple estaría esperando un cierto número de actualizaciones antes de enviar una notificación a la entidad modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un posible criterio sería verificar si dos o más de las métricas han cambiado. Se puede hacer una implementación un poco más avanzada dando a cada métrica un peso para indicar cuán significativo es en el proceso de toma de decisiones de adaptación. Criterio de empuje: el criterio push se aplica a todos los modelentitos que son contenedores, es decir, el transporte de la ganagermodeleNidad, RuntimeModelEntity y ServiceModelEntity, así como el caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el transporte de ManagermodelEntidad esto sirve como un criterio para determinar la notificación ya que como con los criterios descritos anteriormente, se trata de una referencia local. Para las otras entidades modelo, esto tiene como una oportunidad para determinar cuándo y qué métricas deben llevarse al contenedor principal en el que el caso de la empresa de servicio, el padre es el motor de adaptación en sí o en el caso del proxymetricscontainer el objetivo del empuje del empuje.es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio métrico, pero lo más importante es que sirve para realizar un seguimiento de las notificaciones de sus modelos de hijos para determinar cuándo y qué información de métricas se debe impulsar a su padre o objetivo. En el caso especializado del criterio push para el proxy, la toma de decisiones se basa tanto en el proxymetricscontainer en sí, como en la información acumulada de los proxymetodmetricscontainers individuales. Tenga en cuenta que no se requiere un criterio push para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que este ya es modelo de servicio, entidad de servicio, se notifica al contenedor de la entidad del modelo de entidad del criterio de ejecución de tiempo de ejecución de tiempo de ejecución de tiempo de ejecución de la entidad del contenedor del contenedor de criterio del modelo de entidad del modelo de transporte de transporte de entidad del modeloManager Metrics Contenedor Notificar el criterio de entidad modelo Criterio Mobject Model Entity Mobject Método Métricos Notificar Criterio de entidad Modelo Criterio Push Criterion a Adaptation Engine Mobject METRICRT Metric Nodify Metrics Criterion Criterio Proxymetrics Contenedor Criterio Medida Mética Criterio Métrico 2 Medición de Criterio Métrico Métrico 1 1..N No implementado actualmente Notificar Criterio de contenedores Métricos 1 Métricos Medición Medida Criterio MétoNotificar el criterio del contenedor de métricas et métrico IT Métrico Ni Medición Métrica Criterio Medida Criterio Medición Medida Criterio Métrico Notificar Criterio del contenedor Nu Métrica Métrica Métrica Criterio Medición Medida Criterio 1..n Figura 1. Descripción general estructural de las relaciones de notificación jerárquica y criterada entre métricas, contenedores de métricas y entidades modelo manejadas por el MobjectMetricsContainer y su MobjectMethodMetricsContainers individual. Aunque siempre es importante reducir el número de empujes, esto es especialmente de un servicio a un motor de adaptación global centralizado, o de un proxy a un mobjeto. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y el ensarjamiento de datos y la desaceleración de la sobrecarga, y por lo tanto es más eficiente enviar una cantidad dada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Se puede hacer una implementación simple para reducir el número de empujes utilizando el concepto de un período de proceso [19] en cuyo caso la entidad modelo acumula los empujes de sus entidades infantiles hasta que el período de proceso expira en cuyo momento empuja las métricas acumuladas a su padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de mobjetos en una aplicación particular (es decir, TransportManager) han sufrido cambios sustanciales. Para reducir el tamaño de los datos empujados, se consideraron dos tipos de empujes: empuje poco profundo y empuje profundo. Con un empuje superficial, se presiona una lista de contenedores de métricas que contienen métricas actualizadas. En un impulso profundo, la entidad modelo en sí misma se empuja, junto con su contenedor de métricas y sus entidades infantiles, que también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el proxymetricscontainer y todos los proxymetodmetricscontainers, mientras que un impulso poco profundo significa solo los proxymetodmetricscontainers que cumplen con un cierto criterio.4. Evaluación Las pruebas preliminares presentadas en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todas las pruebas se ejecutaron con dos Pentium 4 PC de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas se conectaron a un enrutador con una tercera computadora que actuaba como un servidor de archivos y alojaba el motor de adaptación externo implementado dentro del controlador del sistema MobJex, simulando así un escenario de adaptación global. Dado que solo se podría ejecutar un número limitado de pruebas, esta evaluación eligió medir el peor de los casos en el que se inició toda la recolección de métricas en Mobjects, en el que el costo de propagación es más alto que para cualquier otra métrica recolectada en el sistema. Además, dado que las pruebas exhaustivas de los criterios están más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. Se eligió el criterio de métricas de medida, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio push también se implementó en el servicio, para proporcionar una evaluación del control de la frecuencia de la entrega de métricas al motor de adaptación. Todos los demás criterios (actualizados y empuje) se establecieron siempre, lo que significa que siempre evaluaron como verdadero y, por lo tanto, se publicó una notificación. La Figura 2 muestra la sobrecarga de la colección métrica en el Mobject (MMCO), para diferentes números de mobjetos y métodos cuando todos los criterios siempre deben proporcionar la medición máxima y la propagación de métricas y, por lo tanto, un escenario de rendimiento absoluto en el peor de los casos. Se puede ver que los factores independientes de aumentar el número de mobjetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que está aproximadamente a N cuadrado, los resultados iniciales no son desalentadores ya que entregan todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (que constituye una aplicación bastante grande dada que los mobjetos generalmente representan grano grueso.Los grupos de objetos) son de aproximadamente 400 ms, lo que razonablemente se puede esperar que se compensa con las ganancias de adaptación. Tenga en cuenta que, en contraste, la sobrecarga de la colección de métricas proxy (PMCO) era relativamente pequeña y constante en <5 ms, ya que en ausencia de un criterio de empuje proxy (esto solo se implementó en el servicio) los datos del tiempo de respuesta (RT) para un soloEl método se empuja durante cada invocación.50 150 250 350 450 550 1 5 10 15 20 25 Número de mobjetos/métodos MobjectMetricsCollectionCoverHeadmmco (MS) Métodos Mobjects ambos Figura 2. Las características de rendimiento del peor de los casos, el siguiente paso, fue determinar la sobrecarga de la recopilación de métricas porcentuales en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de los objetos que serían adecuados para la adaptación utilizando este enfoque de recolección métrica. Claramente, no es práctico medir las métricas y realizar la adaptación en objetos con breves tiempos de ejecución que no pueden beneficiarse de la ejecución remota en hosts con mayor potencia de procesamiento, lo que lo compensa con la sobrecarga de la ejecución remota en comparación con la ejecución local, así como el costo de la migración de objetos yEl proceso de recolección de métricas en sí. Además, para demostrar el efecto del uso de criterios basados en frecuencia simples, los resultados de MMCO como porcentaje del tiempo de ejecución del método se trazaron como un gráfico tridimensional en la Figura 3 con el eje z que representa la frecuencia utilizada en ambos criterios de metrics de mediday el criterio de empuje del motor de adaptación al motor de adaptación. Esto significa que para un valor de frecuencia de 5 (n = 5), las métricas solo se miden en cada quinta llamada de método, lo que resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n = 5 también se aplicó al criterio de empuje del servicio, de modo que las métricas solo fueron empujadas al motor de adaptación después de cinco de dichas notificaciones, eso es, por ejemplo, cinco mobjetos diferentes habían actualizado sus métricas. Estos resultados son alentadores ya que incluso para el peor de los casos de n = 1, la sobrecarga de la colección métrica es un 20% aceptable para un método de duración de 1500 ms (que es relativamente corto para un componente o objeto de nivel de servicio en una aplicación de clase empresarial distribuida) conTrabajo previo sobre adaptación que muestra que tal sobrecarga podría recuperarse fácilmente por las ganancias de eficiencia realizadas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados sincrónicamente a través de una llamada remota al motor de adaptación en un host diferente, lo que normalmente se haría de manera asincrónica, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso el uso de criterios modestos para reducir la medición de las métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET.0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. Resumen y conclusiones Dados los desafíos de desarrollar aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la adaptación de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y admitir el middleware. Se realizaron estudios de laboratorio controlados para determinar el rendimiento del peor de los casos, así como mostrar la reducción en la sobrecarga de la recolección al aplicar criterios de recolección simples. Además, las pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basados en el tiempo de ejecución del método) que serían buenos candidatos para la adaptación utilizando la implementación del peor de los casos de la estrategia de recolección de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de la recolección. Si bien la potencialmente eficacia de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente la sobrecarga de la recolección mediante el uso de criterios más sofisticados. Uno de estos enfoques podría basarse en mantener el historial de métricas para determinar el comportamiento temporal de las métricas y, por lo tanto, tomar decisiones más inteligentes y conservadoras con respecto a si es probable que un cambio en una métrica particular sea de interés para el motor de adaptación y, por lo tanto, debería servir comoUna base para la notificación de inclusión en el siguiente impulso de métricas. Además, dicha historia temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en gran medida constante no es necesario medir con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de Mobjex a la cantidad de las ganancias que se pueden hacer a través de la adaptación a través de la movilidad de los objetos y, por lo tanto, se demuestran en la práctica, la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recolección de métricas descritos en este documento a un sistema de gestión del contexto más general y reutilizable [20].6. Referencias 1. Katz, R.H., Adaptación y movilidad en sistemas de información inalámbrica. IEEE Personal Communications, 1994. 1: p.6-17.2. Hirschfeld, R. y Kawamura, K. Adaptación del servicio dinámico.En talleres ICDCS04.2004. 3. Lemlouma, T. y Layaida, N. Adaptación consciente del contexto para dispositivos móviles.En Actas de la Conferencia Internacional IEEE sobre Gestión de datos móviles 2004. 2004. 4. Noble, B.D., et al. Adaptación ágil consciente de la aplicación para la movilidad.en Proc.del 16º Simposio ACM sobre sistemas operativos y principios Sosp.1997. Santo-Malo, Francia.5. Rossi, P. y Ryan, C. Una evaluación empírica de la adaptación local dinámica para aplicaciones móviles distribuidas.en Proc.del Simposio Internacional de 2005 sobre objetos y aplicaciones distribuidas (DOA 2005).2005. Larnaca, Chipre: Springerverlag.6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparentes y portátiles en Java.en Simposio internacional sobre objetos y aplicaciones distribuidas (DOA 2004).2004. Larnaca, Chipre: Springerverlag.7. Da Silva E Silva, F.J., Endler, M. y Kon, F. Desarrollo de aplicaciones distribuidas adaptativas: una descripción general del marco y resultados experimentales.En el movimiento hacia los sistemas de Internet significativos 2003: Coopis, DOA y Odbase (LNCS 2888).2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas.en el noveno Simposio Internacional de Métricos de Software.2003. Sydney: IEEE.9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes de contexto.En Actas del Simposio de Métricos de Software Internacional IEEE Métricos 2005. 2005. Como, Italia.10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm.2005. 11. Titular, O., Ben-Shaul, I., y Gazit, H., soporte del sistema para el diseño dinámico de aplicaciones distribuidas.1998, Instituto de Tecnología Techinonisrael.pag.163 - 173. 12. Titular, O., Ben-Shaul, I. y Gazit, H. Diseño dinámico de aplicaciones distribuidas en Fargo.en 21st intl conf. Ingeniería de software (ICSE99).1999: ACM Press.13. Philippsen, M. y Zenger, M., Javaparty - Objetos remotos transparentes en Java. Concurrencia: Práctica y experiencia, 1997. 9 (11): p.1225-1242.14. Shapiro, M. Estructura y encapsulación en sistemas distribuidos: el principio de proxy.En Proc.6th intl. Conferencia sobre sistemas informáticos distribuidos.1986. Cambridge, Massachusetts (EE. UU.): IEEE.15. Gazit, H., Ben-Shaul, I. y Holder, O. La reubicación dinámica de componentes basada en el monitoreo de los componentes en Fargo.En Actas del Segundo Simposio Internacional sobre Sistemas y Aplicaciones de Agentes y el Cuarto Simposio Internacional sobre Agentes Móviles.2000. 16. Lindholm, T. y Yellin, F., La especificación de la máquina virtual Java 2ª edición.1999: Addison-Wesley.17. Randell, L.G., Holst, L.G. y Bolmsjö, G.S. Desarrollo del sistema incremental de grandes modelos de simulación de eventos discretos.En Actas de la 31ª Conferencia sobre Simulación de Invierno.1999. Phoenix, Arizona.18. Waldo, J., Llamadas de procedimiento remoto e invocación de método remoto de Java. IEEE concurrencia, 1998. 6 (3): p.5-7.19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de la aplicación distribuida.En Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa.1994. Toronto Canada.20. Henricksen, K. e Indulska, J. Un marco de ingeniería de software para la informática generalizada con el contexto.En Actas de la 2da Conferencia IEEE sobre Computación y Comunicaciones Permanentes (PERCOM).2004. Orlando.",
    "original_sentences": [
        "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
        "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
        "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
        "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
        "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
        "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
        "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
        "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
        "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
        "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
        "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
        "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
        "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
        "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
        "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
        "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
        "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
        "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
        "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
        "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
        "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
        "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
        "A runtime is a container process for the management of mobile objects.",
        "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
        "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
        "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
        "Upon migration, proxy objects move with the source object.",
        "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
        "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
        "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
        "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
        "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
        "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
        "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
        "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
        "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
        "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
        "This subset is listed below and categorised according to metric type.",
        "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
        "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
        "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
        "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
        "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
        "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
        "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
        "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
        "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
        "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
        "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
        "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
        "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
        "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
        "In order to collect IT metrics, another additional metric is needed.",
        "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
        "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
        "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
        "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
        "RT measured in the proxy, ET measured in the method body of the object implementation.",
        "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
        "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
        "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
        "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
        "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
        "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
        "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
        "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
        "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
        "Consider the case of measuring memory consumption.",
        "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
        "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
        "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
        "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
        "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
        "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
        "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
        "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
        "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
        "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
        "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
        "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
        "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
        "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
        "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
        "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
        "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
        "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
        "These four criteria are described in the following subsections.",
        "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
        "This is most useful in the case where it is expensive to measure a particular metric.",
        "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
        "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
        "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
        "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
        "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
        "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
        "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
        "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
        "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
        "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
        "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
        "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
        "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
        "The purpose of this criterion is twofold.",
        "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
        "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
        "Furthermore, this criterion is evaluated using information from two sources.",
        "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
        "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
        "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
        "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
        "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
        "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
        "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
        "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
        "TransportManager) have undergone substantial changes.",
        "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
        "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
        "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
        "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
        "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
        "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
        "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
        "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
        "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
        "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
        "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
        "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
        "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
        "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
        "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
        "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
        "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
        "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
        "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
        "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
        "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
        "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
        "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
        "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
        "Performance characteristics with simple criteria 5.",
        "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
        "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
        "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
        "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
        "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
        "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
        "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
        "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
        "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
        "REFERENCES 1.",
        "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
        "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
        "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
        "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
        "Noble, B.D., et al.",
        "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
        "Saint-Malo, France. 5.",
        "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
        "Larnaca, Cyprus: SpringerVerlag. 6.",
        "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
        "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
        "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
        "Sydney: IEEE. 9.",
        "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
        "Como, Italy. 10.",
        "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
        "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
        "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
        "Software Engineering (ICSE99). 1999: ACM Press. 13.",
        "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
        "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
        "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
        "Conference on Distributed Computing Systems. 1986.",
        "Cambridge, Mass. (USA): IEEE. 15.",
        "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
        "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
        "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
        "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
        "Phoenix, Arizona. 18.",
        "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
        "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
        "Rolia, J. and Lin, B.",
        "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
        "Toronto, Canada. 20.",
        "Henricksen, K. and Indulska, J.",
        "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
        "Orlando."
    ],
    "error_count": 0,
    "keys": {
        "data": {
            "translated_key": "datos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote <br>data</br> for a remote call being orders of magnitude higher than the cost of pushing and popping <br>data</br> from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and <br>data</br> marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of <br>data</br> in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed <br>data</br>, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) <br>data</br> for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile <br>data</br> Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El tiempo de invocación (IT) muestra la sobrecarga de invocar un determinado método, con la sobrecarga de invocación de los parámetros de ensarchamiento y la transmisión de \"datos\" remotos para una llamada remota de órdenes de magnitud más altas que el costo de empujar y hacer estallar \"datos\" de la llamada de métodopila.",
                "Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y los \"datos\" que se ensanchan y desaceleran la sobrecarga, y por lo tanto es más eficiente enviar una cantidad determinada de \"datos\" en forma agregada en lugar de enviar más pequeñostrozos varias veces.",
                "Para reducir el tamaño de los \"datos\" empujados, se consideraron dos tipos de empujes: empuje poco profundo y empuje profundo.",
                "Tenga en cuenta que, en contraste, la sobrecarga de la colección de métricas proxy (PMCO) era relativamente pequeña y constante en <5 ms, ya que en ausencia de un criterio de empuje proxy (esto solo se implementó en el servicio) el tiempo de respuesta (RT) paraSe empuja un solo método durante cada invocación.50 150 250 350 450 550 1 5 10 15 20 25 Número de mobjetos/métodos MobjectMetricsCollectionCoverHeadmmco (MS) Métodos Mobjects Figura 2.",
                "Lemlouma, T. y Layaida, N. Adaptación consciente del contexto para dispositivos móviles.En Actas de la Conferencia Internacional IEEE sobre gestión de \"datos\" móviles 2004. 2004. 4."
            ],
            "translated_text": "",
            "candidates": [
                "datos",
                "datos",
                "datos",
                "datos",
                "datos",
                "datos",
                "datos",
                "datos",
                "Datos",
                "Datos",
                "datos"
            ],
            "error": []
        },
        "object-oriented application": {
            "translated_key": "aplicación orientada a objetos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an <br>object-oriented application</br> consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Antecedentes en general, una \"aplicación orientada a objetos\" consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado."
            ],
            "translated_text": "",
            "candidates": [
                "aplicación orientada a objetos",
                "aplicación orientada a objetos"
            ],
            "error": []
        },
        "mobile object framework": {
            "translated_key": "Marco de objetos móviles",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object framework</br> and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a <br>mobile object framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the <br>mobile object framework</br> such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the <br>mobile object framework</br>.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a <br>mobile object framework</br> and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Recopilación de métricas de tiempo de ejecución para el middleware Adaptación de aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne,Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa el peor de los casos de rendimiento, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de los objetos utilizando un \"marco de objetos móvil\" y admitir el middleware.",
                "Como mínimo, un \"marco de objetos móviles\" con al menos una aplicación en ejecución de la aplicación móvil consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13].",
                "Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 Medición de métricas Esta subsección discute cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el \"marco de objetos móviles\" se deben medir tales métricas.",
                "Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación están agregadas en un metro de metroiner con contenedores individuales correspondientes a componentes funcionales en el \"Marco de objetos móviles\".",
                "Resumen y conclusiones Dados los desafíos del desarrollo de aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la adaptación de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha adaptación utilizando un \"marco de objetos móvil\" y apoyarmiddleware."
            ],
            "translated_text": "",
            "candidates": [
                "Marco de objetos móviles",
                "marco de objetos móvil",
                "Marco de objetos móviles",
                "marco de objetos móviles",
                "Marco de objetos móviles",
                "marco de objetos móviles",
                "Marco de objetos móviles",
                "Marco de objetos móviles",
                "Marco de objetos móviles",
                "marco de objetos móvil"
            ],
            "error": []
        },
        "mobjex": {
            "translated_key": "mobjex",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The <br>mobjex</br> platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of <br>mobjex</br> [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of <br>mobjex</br>, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with <br>mobjex</br>, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system <br>mobjex</br>, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in <br>mobjex</br>) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, <br>mobjex</br> has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, <br>mobjex</br> can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the <br>mobjex</br> framework, is for the most part discussed in generic terms, except where explicitly stated to be <br>mobjex</br> specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the <br>mobjex</br> service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the <br>mobjex</br> containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in <br>mobjex</br> this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the <br>mobjex</br> system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the <br>mobjex</br> framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La plataforma \"MobJex\" se utilizó como base para la implementación y las pruebas con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, la eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de la recolección.",
                "Con la excepción de \"mobjex\" [6], los sistemas de objetos móviles existentes como Voyager [10], Fargo [11, 12] y Javaparty [13] no proporcionan una adaptación automatizada y, por lo tanto, carecen del proceso de recolección de métricas requerido para admitireste proceso.",
                "En el caso de \"mobjex\", aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas preescritas sintéticas ya que hay poco trabajo previo en la colección dinámica de métricas de software en marcos de objetos móviles, y no existen.medios para recolectarlos automáticamente.",
                "Por ejemplo, en Fargo [15] este componente se conoce como un núcleo y en la mayoría de los sistemas se requieren horarios de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso con \"mobjex\", que puede ejecutar múltiples aplicaciones en un solotiempo de ejecución usando hilos.",
                "El sistema basado en Java \"MobJex\", que se utiliza como plataforma de implementación para la solución de recolección de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales.",
                "En primer lugar, un gerente de host (conocido como servicio en \"MobJex\") proporciona un punto de comunicación central al ejecutar en un puerto conocido por host por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución o objetos móviles.",
                "En segundo lugar, \"MobJex\" tiene un contenedor de objetos móviles por aplicación llamado Gerente de Transporte (TM).",
                "Finalmente, dependiendo del modo de adaptación, \"MobJex\" puede tener un controlador de sistema centralizado que incorpore un motor de adaptación global para realizar la optimización del sistema.3.",
                "La solución, aunque implementada dentro del marco \"mobjex\", se discute en su mayor parte en términos genéricos, excepto que explícitamente es específico de \"mobjex\".3.1 Selección de métricas Las métricas de Ryan y Rossi [9] se han elegido como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles, además de haber sido derivadas de una serie de modelos matemáticos y validados empíricamente validados.",
                "De las métricas de recursos ambientales, el uso del procesador (PU) y el uso de la red (NU) se relacionan con una máquina individual y, por lo tanto, se pueden medir directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio \"mobjex\".",
                "Además, los proxies no forman parte de la jerarquía de contención \"mobjex\", ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente para un objeto móvil (mobject) tener referencias atrasadas a todos los muchos proxiesque hace referencia (uno por objeto de origen).",
                "La adaptación local es realizada por un motor que se ejecuta en el host local (por ejemplo, en \"mobjex\", esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada local entre procesos.",
                "Las dos máquinas se conectaron a un enrutador con una tercera computadora que actúa como un servidor de archivos y alojaba el motor de adaptación externo implementado dentro del controlador del sistema \"MobJex\", simulando así un escenario de adaptación global.",
                "El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de \"mobjex\" a la cantidad de las ganancias que se pueden obtener a través de la adaptación a través de la movilidad de los objetos y, por lo tanto, demuestran en la práctica, la eficacia de la solución descrita en este documento."
            ],
            "translated_text": "",
            "candidates": [
                "mobjex",
                "MobJex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "MobJex",
                "mobjex",
                "MobJex",
                "mobjex",
                "MobJex",
                "Mobjex",
                "MobJex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "mobjex",
                "MobJex",
                "mobjex",
                "mobjex"
            ],
            "error": []
        },
        "java": {
            "translated_key": "Java",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The <br>java</br> based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the <br>java</br> Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running <br>java</br> 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in <br>java</br>. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in <br>java</br>.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The <br>java</br> Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and <br>java</br> Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El sistema MobJex basado en \"Java\", que se utiliza como plataforma de implementación para la solución de colección de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales.",
                "En el caso del uso de la memoria (MU), la máquina virtual \"Java\" (JVM) [16] está encuestada para la carga de memoria actual.",
                "Todas las pruebas se ejecutaron con dos Pentium 4 PC de 3.0 GHz con 1,024 MB de RAM, ejecutando \"Java\" 1.4.2_08.",
                "Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparentes y portátiles en \"Java\".en Simposio internacional sobre objetos y aplicaciones distribuidas (DOA 2004).2004.",
                "Philippsen, M. y Zenger, M., Javaparty - Objetos remotos transparentes en \"Java\".",
                "Lindholm, T. y Yellin, F., la especificación de la máquina virtual \"Java\" 2ª edición.1999: Addison-Wesley.17.",
                "Waldo, J., Llamadas de procedimientos remotos e invocación de método remoto \"Java\"."
            ],
            "translated_text": "",
            "candidates": [
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java",
                "Java"
            ],
            "error": []
        },
        "metricscontainer": {
            "translated_key": "metricscontainer",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a <br>metricscontainer</br> with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its <br>metricscontainer</br>.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the <br>metricscontainer</br> for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the <br>metricscontainer</br>.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a <br>metricscontainer</br>.",
                "Since a <br>metricscontainer</br> can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own <br>metricscontainer</br> but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación se agregan en un \"Métrico de Container\" con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles.",
                "Notifique el criterio del contenedor de métricas: este criterio también está unido a los objetos métricos individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto métrico debe notificar a su \"MetricScontainer\".",
                "Esto se basa en la suposición de que puede haber casos en los que es deseable medir y almacenar una métrica en la historia para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativo como para notificar al \"Metricscontainer\" para su posterior procesamiento.",
                "Un ejemplo simple de este criterio sería un umbral basado en el cual el valor métrico más nuevo se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de algún interés para el \"Metricscontainer\".",
                "Notifique el criterio de la entidad del modelo: a diferencia de los dos criterios anteriores, este criterio está asociado con un \"Métrico de Container\".",
                "Dado que un \"MetricScontainer\" puede tener múltiples objetos métricos, de los cuales tiene conocimiento de dominio explícito, es capaz de determinar si, cuándo y cuántas de estas métricas deben propagarse a la modeleentro y, por lo tanto, convertirse en candidatos para ser parte de la jerárquicaProceso de empuje de modeleTity como se describe a continuación.",
                "En primer lugar, responde a la notificación recibida de su propio \"MétricoContainer\", pero lo más importante es que sirve para realizar un seguimiento de las notificaciones de sus modelos infantiles para determinar cuándo y qué información de métricas se debe impulsar a su padre o objetivo."
            ],
            "translated_text": "",
            "candidates": [
                "MetricScontainer",
                "Métrico de Container",
                "MetricScontainer",
                "MetricScontainer",
                "MetricScontainer",
                "Metricscontainer",
                "MetricScontainer",
                "Metricscontainer",
                "MetricScontainer",
                "Métrico de Container",
                "MetricScontainer",
                "MetricScontainer",
                "MetricScontainer",
                "MétricoContainer"
            ],
            "error": []
        },
        "metric collection": {
            "translated_key": "colección métrica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the <br>metric collection</br> overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this <br>metric collection</br> approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the <br>metric collection</br> overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La Figura 2 muestra la sobrecarga de \"colección métrica\" en el mobject (MMCO), para diferentes números de mobjetos y métodos cuando todos los criterios siempre deben proporcionar la medición máxima y la propagación de las métricas y, por lo tanto, un escenario de rendimiento absoluto en el peor de los casos.",
                "Las características de rendimiento del peor de los casos, el siguiente paso, fue determinar la sobrecarga de la recopilación de métricas porcentuales en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de los objetos que serían adecuados para la adaptación utilizando este enfoque de \"colección métrica\".",
                "Estos resultados son alentadores ya que incluso para el peor de los casos de n = 1, la sobrecarga de \"colección métrica\" es un 20% aceptable para un método de duración de 1500 ms (que es relativamente corto para un componente o objeto de nivel de servicio en una aplicación de clase empresarial distribuida) Con el trabajo previo sobre la adaptación que muestra que tal sobrecarga podría recuperarse fácilmente por las ganancias de eficiencia obtenidas por la adaptación [5]."
            ],
            "translated_text": "",
            "candidates": [
                "colección métrica",
                "colección métrica",
                "colección métrica",
                "colección métrica",
                "colección métrica",
                "colección métrica"
            ],
            "error": []
        },
        "proxy": {
            "translated_key": "proxy",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, <br>proxy</br> objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the <br>proxy</br> call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the <br>proxy</br>, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the <br>proxy</br>, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a <br>proxy</br> to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the <br>proxy</br>, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the <br>proxy</br> metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a <br>proxy</br> push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the <br>proxy</br> Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Tras la migración, los objetos \"proxy\" se mueven con el objeto de origen.",
                "El tiempo de respuesta se puede medir directamente utilizando la misma técnica basada en el temporizador utilizada para medir ET, aunque al comienzo y al final de la llamada \"proxy\" en lugar de la implementación del método.",
                "RT medido en el \"proxy\", ET medido en el cuerpo del método de la implementación del objeto.",
                "En el caso especializado del criterio push para el \"proxy\", la toma de decisiones se basa tanto en el proxymetricscontainer, así como en la información acumulada de los proxymethodmetricscontainers individuales.",
                "Aunque siempre es importante reducir el número de empujes, esto es especialmente de un servicio a un motor de adaptación global centralizado, o de un \"proxy\" a un mobject.",
                "En el caso del \"proxy\", un empuje profundo implica empujar el proxymetricscontainer y todos los proxymetodmetricscontainers, mientras que un impulso poco profundo significa solo los proximetodmetricscontainers que cumplen con un cierto criterio.4.",
                "Tenga en cuenta que, en contraste, la sobrecarga de la colección de métricas \"proxy\" (PMCO) era relativamente pequeña y constante en <5 ms, ya que en ausencia de un criterio de empuje \"proxy\" (esto solo se implementó en el servicio) el tiempo de respuesta (RT)Los datos para un solo método se impulsan durante cada invocación.50 150 250 350 450 550 1 5 10 15 20 25 Número de mobjetos/métodos MobjectMetricsCollectionCoverHeadmmco (MS) Métodos Mobjects Ambos Figura 2.",
                "Shapiro, M. Estructura y encapsulación en sistemas distribuidos: el principio \"proxy\".En Proc.6th intl."
            ],
            "translated_text": "",
            "candidates": [
                "apoderado",
                "proxy",
                "apoderado",
                "proxy",
                "apoderado",
                "proxy",
                "apoderado",
                "proxy",
                "apoderado",
                "proxy",
                "Proxy",
                "proxy",
                "Proxy",
                "proxy",
                "proxy",
                "apoderado",
                "proxy"
            ],
            "error": []
        },
        "performance and scalability": {
            "translated_key": "rendimiento y escalabilidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the <br>performance and scalability</br> of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Evaluación Las pruebas preliminares presentadas en esta sección tienen como objetivo analizar el \"rendimiento y la escalabilidad\" de la solución y evaluar el impacto en la ejecución de la aplicación en términos de gastos generales de la recolección de métricas."
            ],
            "translated_text": "",
            "candidates": [
                "rendimiento y escalabilidad",
                "rendimiento y la escalabilidad"
            ],
            "error": []
        },
        "measurement": {
            "translated_key": "medición",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the <br>measurement</br> and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple <br>measurement</br> and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms <br>measurement</br>, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics <br>measurement</br> This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct <br>measurement</br> or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The <br>measurement</br> of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct <br>measurement</br>, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 <br>measurement</br> Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of <br>measurement</br> attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the <br>measurement</br> and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the <br>measurement</br> process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum <br>measurement</br> and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the <br>measurement</br> time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics <br>measurement</br> to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la \"medición\" y la propagación de métricas a través del sistema.",
                "La plataforma MobJex se utilizó como base para la implementación y las pruebas con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, la eficiencia y la aplicación de criterios simples de \"medición\" y propagación para reducir la sobrecarga de la recolección.",
                "Categorías y descriptores de sujetos c.2.4 Sistemas distribuidos;D.2.8 Métricas Términos generales \"Medición\", rendimiento.1.",
                "Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 \"Medición\" de métricas Esta subsección analiza cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de \"medición\" directa o derivación, y en el lugar en el marco de objetos móviles se deben medir tales métricas.",
                "La \"medición\" del número de métricas de invocaciones (NI) y tiempo de ejecución (ET) también se puede realizar mediante \"medición\" directa, sin embargo, en este caso dentro de la implementación de objetos móviles (Mobject).",
                "El valor derivado del mismo se almacena y se propaga aún más según sea necesario de acuerdo con los criterios de la Sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de \"medición\" El enfoque de encuesta se identificó como el método más apropiado para recopilar el recursoLas métricas de utilización, como el uso del procesador (PU), el uso de la red (NU) y el uso de la memoria (MU), ya que no son parte del flujo directo de la aplicación.",
                "Tenga en cuenta que esta contención captura la diferente granularidad de los atributos de \"medición\" y sus métricas correspondientes.",
                "Este documento propone cuatro tipos diferentes de criterio que se ejecutan en varias etapas de la \"medición\" y el proceso de propagación para determinar si la siguiente acción debe tomarse o no.",
                "Se eligió el criterio de métricas de medida, ya que esto representa el punto de partida del proceso de \"medición\" y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas.",
                "La Figura 2 muestra la sobrecarga de la colección métrica en el Mobject (MMCO), para diferentes números de mobjetos y métodos cuando todos los criterios siempre deben proporcionar la \"medición\" máxima y la propagación de métricas y, por lo tanto, un escenario de rendimiento absoluto en el peor de los casos.",
                "Además, el tiempo de \"medición\" incluye la entrega de los resultados sincrónicamente a través de una llamada remota al motor de adaptación en un host diferente, lo que normalmente se realizaría de manera asincrónica, reduciendo así aún más el impacto en el rendimiento de la ejecución del método.",
                "El gráfico también demuestra que incluso el uso de criterios modestos para reducir la \"medición\" de las métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de la recolección al 20% durante 500 ms de ET.0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3."
            ],
            "translated_text": "",
            "candidates": [
                "medición",
                "medición",
                "medición",
                "medición",
                "Medición",
                "Medición",
                "medición",
                "Medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "medición",
                "Medición",
                "medición"
            ],
            "error": []
        },
        "propagation and delivery": {
            "translated_key": "propagación y entrega",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, <br>propagation and delivery</br> of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 <br>propagation and delivery</br> of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 <br>propagation and delivery</br> Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "",
                "Sin embargo, en aras de la consistencia y para promover la flexibilidad en términos de agregar nuevas métricas en el futuro, estos contenedores todavía se consideran en el diseño actual para la integridad y el trabajo futuro.3.5 \"Propagación y entrega\" de métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas.",
                "La relación entre las entidades modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de \"propagación y entrega\" Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), INEl para reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación."
            ],
            "translated_text": "",
            "candidates": [
                "",
                "propagación y entrega",
                "propagación y entrega",
                "Propagación y entrega",
                "propagación y entrega",
                "propagación y entrega"
            ],
            "error": []
        },
        "framework": {
            "translated_key": "marco",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object <br>framework</br> and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object <br>framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX <br>framework</br>, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object <br>framework</br> such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object <br>framework</br>.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility <br>framework</br> so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility <br>framework</br> and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility <br>framework</br> and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object <br>framework</br> and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX <br>framework</br> to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A <br>framework</br> Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering <br>framework</br> for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Recopilación de métricas de tiempo de ejecución para el middleware Adaptación de aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne,Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa el peor de los casos de rendimiento, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de los objetos utilizando un \"marco\" de objetos móviles y admitir middleware.",
                "Como mínimo, un \"marco\" de un objeto móvil con al menos una aplicación en ejecución de la aplicación móvil consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13].",
                "La solución, aunque implementada dentro del \"marco\" de MobJex, se discute en su mayor parte en términos genéricos, excepto que explícitamente es específico de MobJex.3.1 Selección de métricas Las métricas de Ryan y Rossi [9] se han elegido como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles, además de haber sido derivadas de una serie de modelos matemáticos y validados empíricamente validados.",
                "Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 Medición de métricas Esta subsección discute cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el objeto móvil \"marco\", tales métricas deberían medirse realmente.",
                "Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación están agregadas en un metro de metroiner con contenedores individuales correspondientes a componentes funcionales en el \"marco\" del objeto móvil.",
                "La principal ventaja de agregar métricas en contenedores es que les permite propagarse fácilmente como una unidad cohesiva a través de los componentes del \"marco\" de movilidad para que puedan entregarse al motor de adaptación, como se discute en la siguiente subsección.",
                "En primer lugar, la propagación de métricas a través de los componentes del \"marco\" de movilidad y, en segundo lugar, la entrega de esas métricas del administrador/servicio del host (o tiempo de ejecución si el administrador del host no está presente) al motor de adaptación.",
                "La relación entre las entidades modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de propagación y entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), para queReduzca la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del \"marco\" de movilidad y se entregan al motor de adaptación.",
                "Resumen y conclusiones Dados los desafíos de desarrollar aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la adaptación de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha adaptación utilizando un objeto móvil \"marco\" y apoyarmiddleware.",
                "El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el \"marco\" de Mobjex a la cantidad de las ganancias que se pueden hacer a través de la adaptación a través de la movilidad de los objetos y, por lo tanto, demuestran en la práctica, la eficacia de la solución descrita en este documento.",
                "Larnaca, Chipre: Springerverlag.7. Da Silva E Silva, F.J., Endler, M. y Kon, F. Desarrollo de aplicaciones distribuidas adaptativas: una descripción general de \"marco\" y resultados experimentales.En el movimiento hacia los sistemas de Internet significativos 2003: Coopis, DOA y Odbase (LNCS 2888).2003. 8.",
                "Un \"marco\" de ingeniería de software para la informática generalizada con el contexto.En Actas de la 2da Conferencia IEEE sobre Computación y Comunicaciones Permanentes (PERCOM).2004."
            ],
            "translated_text": "",
            "candidates": [
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "estructura",
                "marco",
                "Marco",
                "marco",
                "Marco",
                "marco"
            ],
            "error": []
        },
        "adaptation": {
            "translated_key": "adaptación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported <br>adaptation</br> of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application <br>adaptation</br> via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application <br>adaptation</br> [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective <br>adaptation</br> requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing <br>adaptation</br> is dependent upon the type of <br>adaptation</br> required.",
                "For example, service-based <br>adaptation</br>, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, <br>adaptation</br> via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated <br>adaptation</br>, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an <br>adaptation</br> engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support <br>adaptation</br> via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the <br>adaptation</br> engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on <br>adaptation</br> mode, MobJeX can have a centralised system controller incorporating a global <br>adaptation</br> engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the <br>adaptation</br> of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application <br>adaptation</br> as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real <br>adaptation</br> scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global <br>adaptation</br> [9] and thereby satisfy a range of real <br>adaptation</br> scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an <br>adaptation</br> scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the <br>adaptation</br> engine to predict the value over time of a particular <br>adaptation</br> decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the <br>adaptation</br> engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based <br>adaptation</br>, the local <br>adaptation</br> algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the <br>adaptation</br> metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the <br>adaptation</br> engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the <br>adaptation</br> engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global <br>adaptation</br> [9].",
                "Local <br>adaptation</br> is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global <br>adaptation</br> is handled by a centralised <br>adaptation</br> engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the <br>adaptation</br> engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the <br>adaptation</br> engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the <br>adaptation</br> engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an <br>adaptation</br> engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the <br>adaptation</br> engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the <br>adaptation</br> engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the <br>adaptation</br> decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the <br>adaptation</br> engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To <br>adaptation</br> engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global <br>adaptation</br> engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external <br>adaptation</br> engine implemented within the MobJeX system controller, thereby simulating a global <br>adaptation</br> scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the <br>adaptation</br> engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with <br>adaptation</br> gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for <br>adaptation</br> using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform <br>adaptation</br> on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to <br>adaptation</br> engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the <br>adaptation</br> engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on <br>adaptation</br> showing that such an overhead could easily be recovered by the efficiency gains made by <br>adaptation</br> [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the <br>adaptation</br> engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application <br>adaptation</br>, this paper has proposed and implemented an online metrics collection strategy to assist such <br>adaptation</br> using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for <br>adaptation</br> using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the <br>adaptation</br> engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of <br>adaptation</br> scenarios on the MobJeX framework to quantity the gains that can be made via <br>adaptation</br> through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., <br>adaptation</br> and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service <br>adaptation</br>. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware <br>adaptation</br> for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware <br>adaptation</br> for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local <br>adaptation</br> for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application <br>adaptation</br> through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Colección de métricas de tiempo de ejecución para el middleware compatible con la \"adaptación\" de las aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University,Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa en términos de peorRendimiento de casos, una estrategia de recolección de métricas en línea para facilitar la \"adaptación\" de la aplicación a través de la movilidad de los objetos utilizando un marco de objetos móvil y un middleware de soporte.",
                "Una solución que recibe una atención cada vez mayor en la comunidad de investigación es la \"adaptación\" de la aplicación [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como la red, el procesador o el uso de la memoria.",
                "La \"adaptación\" efectiva requiere información detallada y actualizada sobre el sistema y el software en sí.",
                "Además, el tipo de métricas requeridas para realizar una \"adaptación\" depende del tipo de \"adaptación\" requerida.",
                "Por ejemplo, la \"adaptación\" basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifican en respuesta a los cambios en el entorno de tiempo de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4].",
                "Por otro lado, la \"adaptación\" a través de la movilidad de los objetos [6], también requiere métricas de software detalladas [9] ya que la colocación de objetos depende de las características de ejecución de los objetos móviles.",
                "Con la excepción de Mobjex [6], los sistemas de objetos móviles existentes como Voyager [10], Fargo [11, 12] y Javaparty [13] no proporcionan una \"adaptación\" automatizada y, por lo tanto, carecen del proceso de recolección de métricas requerido para admitireste proceso.",
                "En el caso de MobJex, aunque se ha implementado un motor de \"adaptación\" [5], las pruebas preliminares se realizaron utilizando métricas preescritas sintéticas ya que hay poco trabajo previo en la colección dinámica de métricas de software en marcos de objetos móviles, y no existen.medios para recolectarlos automáticamente.",
                "En consecuencia, la principal contribución de este documento es una solución para la colección de métricas dinámicas para admitir la \"adaptación\" a través de la movilidad de objetos para aplicaciones móviles.",
                "Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicaciones y middleware, y por lo tanto, la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados se propagan eficientemente al motor de \"adaptación\".",
                "Finalmente, dependiendo del modo de \"adaptación\", Mobjex puede tener un controlador de sistema centralizado que incorpore un motor global de \"adaptación\" para realizar una optimización del sistema.3.",
                "Colección de métricas Esta sección analiza el diseño y la derivación de una solución para recopilar métricas para apoyar la \"adaptación\" de las aplicaciones a través de la migración de objetos.",
                "La solución, aunque implementada dentro del marco de MobJex, se discute en su mayor parte en términos genéricos, excepto que explícitamente es específico de MobJex.3.1 Selección de métricas Las métricas de Ryan y Rossi [9] se han elegido como base para esta solución, ya que están específicamente destinadas a la \"adaptación\" de la aplicación móvil, además de haber sido derivadas de una serie de modelos matemáticos y validados empíricamente validados.",
                "Además, se demostró empíricamente las métricas para mejorar el rendimiento de la aplicación en un escenario real de \"adaptación\" después de un cambio en el entorno de ejecución.",
                "Sin embargo, estaría más allá del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9] y, por lo tanto, para proporcionar un subconjunto útil no aleatorio, elegimos implementar el conjunto mínimo de métricas necesarias para implementar\"Adaptación\" local y global [9] y, por lo tanto, satisface una variedad de escenarios reales de \"adaptación\".",
                "Los siguientes son breves ejemplos de varias de estas métricas para demostrar su uso en un escenario de \"adaptación\".",
                "Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de \"adaptación\" predice el valor en el tiempo de una decisión particular de \"adaptación\".3.2 Medición de métricas Esta subsección analiza cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el marco de objetos móviles se deben medir tales métricas.",
                "La principal ventaja de agregar métricas en contenedores es que les permite propagarse fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan entregarse al motor de \"adaptación\", como se discute en la siguiente subsección.",
                "Como ejemplo del nivel de granularidad requerido para la \"adaptación\" basada en la movilidad, el algoritmo local de \"adaptación\" propuesto por Ryan y Rossi [9] requiere métricas que representan tanto la duración de una ejecución de métodos como la sobrecarga de una invocación de método.",
                "Tenga en cuenta que algunos contenedores de métricas no contienen ningún objeto métrico, ya que como se describió anteriormente, la implementación de la muestra usa solo un subconjunto de las métricas de \"adaptación\" de [9].",
                "En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas del administrador/servicio del host (o tiempo de ejecución si el administrador del host no está presente) al motor de \"adaptación\".",
                "Con respecto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, objeto móvil), la métrica se presiona (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, tiempo de ejecucióno Manager de transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de mobjetos modificados) será empujado al siguiente componente de nivel (es decir, el administrador del host o el \"adaptación \"motor).",
                "Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la \"adaptación\" local y global [9].",
                "La \"adaptación\" local es realizada por un motor que se ejecuta en el host local (por ejemplo, en Mobjex, esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada local entre procesos.",
                "Por el contrario, la \"adaptación global\" es manejada por un motor de \"adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas es a través de una llamada remota, y en el caso de que existan múltiples tiempos de ejecución sin un administrador de host por separado, el proceso de entrega seríaaún más caro.",
                "Por lo tanto, debido a la presencia de latencia de comunicación de red, es importante que el gerente del host pase tantas métricas como sea posible al motor de \"adaptación\" en una sola invocación, lo que implica la necesidad de reunir estas métricas en el gerente del host, a través de algún formulariode empuje o propagación, antes de enviarlos al motor de \"adaptación\".",
                "Adjuntar los contenedores de métricas a las entidades modeladas permite que una entidad modelo que represente a un gerente de host se entregue al motor de \"adaptación\" que le permite acceder a todas las métricas en ese componente y cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles).",
                "Además, generalmente se esperaría que un motor o controlador de sistema de \"adaptación\" ya mantenga un modelo del sistema que no solo puede reutilizarse para la propagación, sino que también proporciona un medio efectivo para entregar información de métricas del gerente del host a la \"adaptación\"motor.",
                "La relación entre las entidades modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de propagación y entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), para queReduzca la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de \"adaptación\".",
                "Se puede hacer una implementación un poco más avanzada dando a cada métrica un peso para indicar cuán significativo es en el proceso de toma de decisiones de \"adaptación\".",
                "Para las otras entidades modelo, esto sirve como una oportunidad para determinar cuándo y qué métricas deben llevarse al contenedor principal en el que el caso de la empresa de servicio, el padre es el motor de \"adaptación\" en sí o en el caso del proxymetricscontainer, el objetivo deEl empuje es el MobjectMetricsContainer.",
                "",
                "Aunque siempre es importante reducir el número de empujes, esto es especialmente de un servicio a un motor de \"adaptación\" global centralizado, o de un proxy a un mobject.",
                "Las dos máquinas estaban conectadas a un enrutador con una tercera computadora que actuaba como servidor de archivos y alojaba el motor de \"adaptación\" externo implementado dentro del controlador del sistema MobJex, simulando así un escenario global de \"adaptación\".",
                "Además, el criterio push también se implementó en el servicio, para proporcionar una evaluación del control de la frecuencia de la entrega de métricas al motor de \"adaptación\".",
                "Aunque combinarlos juntos proporciona un crecimiento exponencial que está aproximadamente a N cuadrado, los resultados iniciales no son desalentadores ya que entregan todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (que constituye una aplicación bastante grande dado que los mobjetos generalmente representan granetas gruesas.Los grupos de objetos) son de aproximadamente 400 ms, lo que razonablemente se podría esperar que se compensaran con ganancias de \"adaptación\".",
                "Las características de rendimiento del peor de los casos El siguiente paso fue determinar la sobrecarga de la recopilación de métricas porcentuales en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de los objetos que serían adecuados para la \"adaptación\" utilizando este enfoque de recolección métrica.",
                "Claramente, no es práctico medir las métricas y realizar la \"adaptación\" en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor potencia de procesamiento, lo que lo compensa con la sobrecarga de la ejecución remota en comparación con la ejecución local, así como el costo de los objetos.La migración y el proceso de recolección de métricas en sí.",
                "Además, para demostrar el efecto del uso de criterios basados en frecuencia simples, los resultados de MMCO como porcentaje del tiempo de ejecución del método se trazaron como un gráfico tridimensional en la Figura 3 con el eje z que representa la frecuencia utilizada en ambos criterios de metrics de mediday el servicio al criterio de empuje del motor de \"adaptación\".",
                "Además, el valor de n = 5 también se aplicó al criterio de empuje del servicio, de modo que las métricas solo fueron empujadas al motor de \"adaptación\" después de cinco de esas notificaciones, que es, por ejemplo, cinco mobjetos diferentes habían actualizado sus métricas.",
                "Estos resultados son alentadores ya que incluso para el peor de los casos de n = 1, la sobrecarga de la colección métrica es un 20% aceptable para un método de duración de 1500 ms (que es relativamente corto para un componente o objeto de nivel de servicio en una aplicación de clase empresarial distribuida) conTrabajo previo sobre \"adaptación\" que demuestra que tal sobrecarga podría recuperarse fácilmente por las ganancias de eficiencia realizadas por la \"adaptación\" [5].",
                "Además, el tiempo de medición incluye la entrega de los resultados sincrónicamente a través de una llamada remota al motor de \"adaptación\" en un host diferente, lo que normalmente se realizaría de manera asincrónica, reduciendo así aún más el impacto en el rendimiento de la ejecución del método.",
                "Resumen y conclusiones Dados los desafíos de desarrollar aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la \"adaptación\" de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha \"adaptación\" utilizando un marco de objetos móvilesy soporte de middleware.",
                "Además, las pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basados en el tiempo de ejecución del método) que serían buenos candidatos para la \"adaptación\" utilizando la implementación del peor de los casos de la estrategia de recolección de métricas propuesta.",
                "Uno de estos enfoques podría basarse en el mantenimiento del historial de métricas para determinar el comportamiento temporal de las métricas y, por lo tanto, tomar decisiones más inteligentes y conservadoras con respecto a si es probable que un cambio en una métrica particular sea de interés para el motor de \"adaptación\" y, por lo tanto.Servir como base para la notificación de inclusión en el siguiente impulso de métricas.",
                "El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de \"adaptación\" en el marco de Mobjex a la cantidad de las ganancias que se pueden hacer a través de la \"adaptación\" a través de la movilidad de los objetos y, por lo tanto, se demuestra en la práctica, la eficacia de la solución descrita en este documento.",
                "Katz, R.H., \"Adaptación\" y movilidad en los sistemas de información inalámbrica.",
                "Hirschfeld, R. y Kawamura, K. Servicio dinámico \"Adaptación\".En talleres ICDCS04.2004. 3.",
                "Lemlouma, T. y Layaida, N. Contexting \"Adaptation\" para dispositivos móviles.En Actas de la Conferencia Internacional IEEE sobre Gestión de datos móviles 2004. 2004. 4.",
                "La \"adaptación\" de la aplicación ágil para la movilidad.en Proc.del 16º Simposio ACM sobre sistemas operativos y principios Sosp.1997.",
                "Rossi, P. y Ryan, C. Una evaluación empírica de la \"adaptación\" local dinámica para aplicaciones móviles distribuidas.en Proc.del Simposio Internacional de 2005 sobre objetos y aplicaciones distribuidas (DOA 2005).2005.",
                "Ryan, C. y Westhorpe, C. Aplicación \"adaptación\" a través de la movilidad de objetos transparentes y portátiles en Java.en Simposio internacional sobre objetos y aplicaciones distribuidas (DOA 2004).2004."
            ],
            "translated_text": "",
            "candidates": [
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "Adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "Adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación ",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación global",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "",
                "Adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "adaptación",
                "Adaptación",
                "Adaptación",
                "Adaptación",
                "Adaptación",
                "Adaptation",
                "Adaptación",
                "adaptación",
                "Adaptación",
                "adaptación",
                "Adaptación",
                "adaptación"
            ],
            "error": []
        },
        "mobile object": {
            "translated_key": "objeto móvil",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object</br> framework and supporting middleware.",
                "The solution is based upon an abstract representation of the <br>mobile object</br> system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing <br>mobile object</br> systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in <br>mobile object</br> frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical <br>mobile object</br> frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of <br>mobile object</br> frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "<br>mobile object</br> frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a <br>mobile object</br> framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application <br>mobile object</br> container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the <br>mobile object</br> framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the <br>mobile object</br> implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a <br>mobile object</br> (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the <br>mobile object</br> framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. <br>mobile object</br>), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the <br>mobile object</br>), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a <br>mobile object</br> framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Recopilación de métricas de tiempo de ejecución para el middleware Adaptación de aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne,Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa el peor de los casos de rendimiento, una estrategia de recolección de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de los objetos utilizando un marco de \"objeto móvil\" y un middleware de soporte.",
                "La solución se basa en una representación abstracta del sistema \"Objeto móvil\", que contiene contenedores que agregan métricas para cada componente específico que incluye gerentes de host, tiempos de ejecución y objetos móviles.",
                "Con la excepción de Mobjex [6], los sistemas existentes de \"objeto móvil\" como Voyager [10], Fargo [11, 12] y Javaparty [13] no proporcionan una adaptación automatizada y, por lo tanto, carecen del proceso de recolección de métricas requerido para admitireste proceso.",
                "En el caso de MobJex, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas sintéticas preescritas ya que hay poco trabajo previo en la colección dinámica de métricas de software en marcos de \"objetos móviles\", y no existen.medios para recolectarlos automáticamente.",
                "Este problema no es trivial ya que los marcos típicos de \"objeto móvil\" consisten en múltiples componentes de aplicaciones y middleware, y por lo tanto, la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados se propagan eficientemente al motor de adaptación.",
                "El resto de este documento se organiza de la siguiente manera: la Sección 2 describe la estructura general y la implementación de marcos de \"objeto móvil\" para comprender los desafíos relacionados con la recolección, propagación y entrega de métricas como se describe en la Sección 3.",
                "Los marcos de \"objetos móviles\" permiten que algunos de estos objetos se etiqueten como objetos móviles, proporcionando soporte de middleware para que dichos objetos se muevan en tiempo de ejecución a otros hosts.",
                "Como mínimo, un marco de \"objeto móvil\" con al menos una aplicación en ejecución de la aplicación móvil consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13].",
                "En segundo lugar, Mobjex tiene un contenedor de \"objeto móvil\" por aplicación llamado Gerente de Transporte (TM).",
                "Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 Medición de métricas Esta subsección analiza cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el marco del \"objeto móvil\", se deben medir tales métricas.",
                "La medición del número de métricas de invocaciones (NI) y tiempo de ejecución (ET) también se puede realizar mediante medición directa, sin embargo, en este caso dentro de la implementación del \"objeto móvil\" (mobject).",
                "Además, los proxies no forman parte de la jerarquía de contención de Mobjex, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un \"objeto móvil\" (mobject) tenga referencias atrasadas a todos los muchos proxiesque hace referencia (uno por objeto de origen).",
                "Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación están agregadas en un metro de metroiner con contenedores individuales correspondientes a componentes funcionales en el marco de \"objeto móvil\".",
                "Con respecto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, \"objeto móvil\"), la métrica se impulsa (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, tiempo de ejecución o administrador de transporte que contiene el \"objeto móvil\"), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de mobjetos modificados) será empujado al siguiente componente de nivel (es decir, el host del hostgerente o el motor de adaptación).",
                "Resumen y conclusiones Dados los desafíos de desarrollar aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la adaptación de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha adaptación utilizando un marco de \"objeto móvil\" y apoyarmiddleware."
            ],
            "translated_text": "",
            "candidates": [
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "Objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objetos móviles",
                "objeto móvil",
                "objeto móvil",
                "Objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objetos móviles",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil",
                "objeto móvil"
            ],
            "error": []
        }
    }
}