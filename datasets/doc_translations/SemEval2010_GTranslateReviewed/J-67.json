{
    "id": "J-67",
    "original_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm. However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm. Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent. The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent. For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one. We then show a matching lower bound for deterministic mechanisms that never pay the agents. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1. INTRODUCTION We consider the problem of online scheduling of jobs on a single processor. Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline. The objective is to maximize the sum of the values of the jobs completed by their respective deadlines. The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time. Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution. One interpretation of this approach is as a game between the designer of the online algorithm and an adversary. First, the designer selects the online algorithm. Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm. Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs. For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms. The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm. The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release. However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs. Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting. Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent. Instead of being released to the algorithm, each job is now released only to its owning agent. Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job. Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15]. The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents. Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]). In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome. In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center. A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline. In order to evaluate a mechanism using competitive analysis, the adversary model must be updated. In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism. Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs. The rest of the paper is structured as follows. In Section 2, we formally define and review results from the original, non-strategic setting. After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3. In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio. We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job. Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents. Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2. NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand. Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively. The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous). Each job is released at time ri, at which point its three other characteristics are known. Nothing is known about the job before its arrival. Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline. Preemption of jobs is allowed, and it takes no time to switch between jobs. Thus, job i is completed if and only if the total time it executes on the processor before di is at least li. Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i. Thus, (θi, θ−i) denotes a complete vector of tuples. Define the value density ρi = vi li of job i to be the ratio of its value to its length. For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi. The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs. The algorithm is assumed to always know an upper bound k on the importance ratio. For simplicity, we normalize the range of possible value densities so that ρmin = 1. An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o. An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle. To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise. A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline. A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li). Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument. For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ. Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time. Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t). The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ. In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm. Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ). An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ). An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration. A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li). Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1. Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4]. In this section we provide a high-level description of TD1 (version 2) using an example. TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job. The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity. For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9]. No preemption is considered during this interval, because job 2 has laxity until time 1.5. Then, a new interval starts at tb = 0.9 when job 2 becomes active. Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity. In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss. The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted). In this case, te = 17.0. The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job. The other variable, p loss, is equal to the length of the first active job of the current interval. Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio). Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion. Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Table 1: Input used to recap TD1 (version 2) [4]. The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3. MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job. For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7. At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem. In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand. Each job i is owned by a separate agent i. The characteristics of the job define the agents type θi ∈ Θi. At time ri, agent i privately observes its type θi, and has no information about job i before ri. Thus, jobs are still released over time, but now each job is revealed only to the owning agent. Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O. An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism. In a standard mechanism design setting, the outcome is enforced at the end of the mechanism. However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent. That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time. This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms. Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism. Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center. We assume that each agent is a rational, expected utility maximizer. Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed. On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job. However, we will also consider a restricted formulation in which this type of lie is not possible. The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent. The agent can declare an arbitrary deadline or value. To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri. While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job. Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax. However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting. The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism. As before, preemption of jobs is allowed, and job switching takes no time. The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i. The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality. The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration. Definition 1. A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn. From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it. For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule. In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7. However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned). Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism. While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality. The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility. The rationale behind this goal is that participation in the mechanism is assumed to be voluntary. Definition 2. A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline). An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3. An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4. RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1). After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio. We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents. Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job. Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration. By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR. We now argue why it satisfies IC with respect to the other three characteristics. Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent. However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline. This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0. However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job. The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting). On the other hand, it is less obvious why agents do not have incentive to declare a later release time. Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1. However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1. Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13. Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22. Job 3 then executes to completion, forcing job 1 to be abandoned. However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22. Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30]. Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times. Intuitively, Γ1 avoids this problem because of two properties. First, when a job becomes active, it must have a greater priority than all other available jobs. Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics. These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas. Theorem 1. Mechanism Γ1 satisfies individual rationality. Proof. For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0. On the other hand, if job i is completed, then its value must exceed agent is payment. Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition. To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li. We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed. We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline. Lemma 2. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof. Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri. We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center. Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi). First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta . Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i. We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y . Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active. Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor. Assume by contradiction that this is not true. Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time. The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y . Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri. We now show that job i cannot be completed in this case, given that it was not completed in case I. First, we can restrict the range of ˆri that we need to consider as follows. Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes. Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release. Thus, we can restrict consideration to ˆri ∈ (ts , ta ]. In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y . Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs. We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ). First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc . Now consider an arbitrary y ∈ Y such that y = yc . In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Thus, moving to case II, job y must replace some other job before tc . Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Since w ∈ Y would contradict the definition of tc , we know that w = i. That is, the job that y replaces must be i. By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I. On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X. We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ]. Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Thus, even at this upper bound, job yc would execute instead of job x at time tc . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz. Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof. Lemma 3. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof. Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di. Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail. Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter. Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction. We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof. Assume by contradiction that this condition does not hold. This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not. Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction. Finally, the following lemma tells us that the completion of a job is monotonic in its declared value. Lemma 5. In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri. In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed. The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ]. We can now combine the lemmas to show that no profitable deviation is possible. Theorem 6. Mechanism Γ1 satisfies incentive compatibility. Proof. For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption. We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline. Then, because the payment function is non-negative, agent is utility could not exceed zero. By IR, this is the minimum utility it would achieve if it truthfully declared θi. Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di. Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero. If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i. On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas. Having shown IC, we can assume truthful declaration (ˆθ = θ). Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline. Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1. Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence. Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1. Also, let tbegin f be the first time that the processor is not idle in interval If . Lemma 7. For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof. Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job. Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs). Let ts i be the time that job i begins execution. Note that ts 1 = tbegin f . Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs. Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active. We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence. Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements. Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds. At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1. These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step. We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length. We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf . We now consider the possible execution of uncompleted jobs by Γoffline. Associate each job i that is not completed by Γ1 with the interval during which it was abandoned. All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F . Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism. Lemma 8. For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf . Proof. Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf . At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf . Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ]. Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf . As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job. Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines. The following lemma is Lemma 5.10 in [15], and its proof now applies directly. Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf . The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f . By Lemma 8, the value of this job is bounded by (1 + √ k) · vf . We can now combine the results of these lemmas to prove the competitive ratio. Theorem 10. Mechanism Γ1 is (1+ √ k)2+1 -competitive. Proof. Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F). Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9. Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf . Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings. For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem. Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4]. If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments. The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility. Theorem 12. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive. Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems. Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5. COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms. To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0). Unlike IC and IR, this requirement is not standard in mechanism design. We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i. The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments. We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints. Lemma 13. For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14. There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1. Proof. Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well). Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1. First, we will construct a profile of agent types θ using an adversary argument. After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction. We now construct the original profile θ. Pick an α such that 0 < α < , and define δ = α ck+3k . The adversary uses two sequences of jobs: minor and major. Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity. The first minor job is released at time 0, and ri = di−1 for all i > 1. The sequence stops whenever Γ completes any job. Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li). The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13. Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α. The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job. The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1]. No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ). Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned. If f < m, then major job f + 1 will be released and it will be the final major job. Γ cannot complete job f +1, because rf +lf = df > rf+1. Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df . We now possibly perturb θ slightly. By IR, we know that vf ≥ pf (θ). Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf . By IC, job f must still be completed by Γ for the profile (θf , θ−f ). If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0. However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC. Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument. Thus, for the remainder of the proof, assume that vf > pf (θ). We now use a more substantial perturbation of θ to complete the proof. If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed. If f = m, then instead set df = df +lf . IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed. Assume by contradiction that this were not true. Then, at the original deadline of df , job f is not completed. Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)). Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df . Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0. Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ). Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC. While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change. If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned). Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based. Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]). Mechanism design was also applied to a scheduling problem in [18]. In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them. The private information of an agent is the time it will require to execute each job. Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem. This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements. A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay. For a survey of this and other topics in distributed algorithmic mechanism design, see [9]. Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings. For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time. In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values. Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions. The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply. It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival. The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time. A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7. CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents. We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one. We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job. We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents. Several open problems remain in this setting. One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments. Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption. Finally, randomized mechanisms provide an unexplored area for future work. 8. REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J. Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70",
    "original_translation": "Diseño del mecanismo para la programación en tiempo real en línea Ryan Porter ∗ Departamento de informática de la Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu Resumen Para el problema de la programación de trabajos en línea en tiempo real en un solo procesador, el trabajo anterior presenta límites superiores e inferiores.en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados solo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivado por áreas emergentes como la computación de la red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado y interestado. El agente puede retrasar la liberación del trabajo al algoritmo, inflar su longitud y declarar un valor arbitrario y una fecha límite para el trabajo, mientras que el centro determina no solo el cronograma, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, mientras que solo aumenta la relación competitiva en uno. Luego mostramos un límite inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Sistemas distribuidos de inteligencia artificial-matiagente;J.4 [Ciencias sociales y conductuales]: Economía;F.1.2 [Computación por dispositivos abstractos]: Modos de cálculo de cálculo en la línea de cálculo Algoritmos de términos generales, economía, diseño, teoría 1. Introducción Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de lanzamiento, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa en su fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados por sus respectivos plazos. El desafío clave en este entorno en línea es que el horario debe construirse en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar los algoritmos en línea comparándolos con el algoritmo optim ﬄ ﬄ ﬄ ine, que tiene pleno conocimiento de la entrada al comienzo de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo optim ﬄ ine óptimo al valor de los completados por el algoritmo en línea. Dos documentos pintan una imagen completa en términos de análisis competitivo para este entorno, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por el tiempo de procesamiento) de dos trabajos. Para K = 1, [4] presenta un algoritmo de 4 competitivo y demuestra que este es un límite más bajo en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el límite inferior a (1 + √ k) 2 para cualquier k ≥ 1, y [15] luego presenta un algoritmo competitivo de coincidencia (1 + √ k) 2. La configuración abordada por estos documentos es completamente no constrechosa, y se supone que el algoritmo siempre conoce las características verdaderas de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación de la cuadrícula (ver, por ejemplo, [7, 8]) esta suposición no es válida, porque los compradores del tiempo del procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un problema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión de la configuración en la que cada trabajo es propiedad de un agente separado e interestimonado. En lugar de ser liberado al algoritmo, cada trabajo ahora se libera solo a su agente de propiedad. Cada agente ahora tiene cuatro formas diferentes en que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo de liberación real, puede inflar artificialmente la duración del trabajo y puede declarar un valor arbitrario y una fecha límitepara el trabajo. Debido a que los agentes son interesados en sí mismos, elegirán manipular el algoritmo si lo hace hará que se complete su trabajo;y, de hecho, uno puede encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados en sí mismo mueve el problema del área del diseño de algoritmo al diseño del mecanismo [17], la ciencia de los protocolos de elaboración de los agentes egoístas. Los últimos años han visto mucha actividad en la interfaz de la informática y el diseño del mecanismo (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente y devolverá un cronograma para los trabajos, y cada agente realiza un pago al centro. Un concepto básico de solución del diseño del mecanismo es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre sea de cada agente el mejor interés enviar inmediatamente su trabajo al liberar y declarar sinceramente su valor, longitud y fecha límite. Para evaluar un mecanismo utilizando un análisis competitivo, el modelo adversario debe actualizarse. En el nuevo modelo, el adversario aún determina la secuencia de trabajos, pero son los agentes egoístas quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de C, un mecanismo en línea debe ser compatible con incentivos, y siempre lograr al menos 1 c del valor que el mecanismo óptimo o ﬄ ine logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos y revisamos formalmente los resultados de la configuración original no estratégica. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos la configuración de diseño del mecanismo en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + √ k) 2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que K = 1 y cada agente no pueden alterar la longitud de su trabajo. Al devolver el entorno general, mostramos en la Sección 5 que esta relación competitiva es un límite más bajo para los mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos el trabajo relacionado que no sea el directamente relevante [4] y [15], antes de concluir con la Sección 7. 2. Configuración no estratégica En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores.2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutar, y n trabajos, aunque este número no se conoce de antemano. Cada trabajo I se caracteriza por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio θi de posibles tuplas es el mismo para cada trabajo y consiste en todos los θi de modo que Ri, Di, Li, Vi ∈ + (por lo tanto, el modelo del tiempo es continuo). Cada trabajo se libera en el momento RI, momento en el cual se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme (o, difícil), lo que significa que no se obtiene ningún valor para un trabajo que se completa después de su fecha límite. Se permite la prevención de trabajos, y no lleva tiempo cambiar entre trabajos. Por lo tanto, el trabajo I se completa si y solo si el tiempo total se ejecuta en el procesador antes de DI es al menos Li. Sea θ = (θ1, ..., θn) denota el vector de tuplas para todos los trabajos, y vamos θ - i = (θ1, ..., θi - 1, θi+1, ..., Θn) denota elEl mismo vector sin la tupla para el trabajo i. Por lo tanto, (θi, θ - i) denota un vector completo de tuplas. Defina la densidad de valor ρi = vi li del trabajo I para ser la relación de su valor hasta su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La relación de importancia se define como ρmax ρmin, la relación máxima de densidades de valor entre dos trabajos. Se supone que el algoritmo siempre conoce una K superior en la relación de importancia. Para simplificar, normalizamos el rango de posibles densidades de valor para que ρmin = 1. Un algoritmo en línea es una función F: θ1 ×...× θn → O que mapea el vector de tuplas (para cualquier número n) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S: + → {0, 1 ,..., N}, que mapea cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo transcurrido total que ha gastado un trabajo en el procesador en el momento t, usaremos la función ei (t) = t 0 µ (s (s (x) = i) dx, donde µ (·) es una función indicadoraEso devuelve 1 si el argumento es verdadero, y cero de lo contrario. Se define una laxitud de empleos en el momento t para ser di - t - li + ei (t), la cantidad de tiempo que puede permanecer inactiva y aún completar su fecha límite. Un trabajo se abandona si no se puede completar en su fecha límite (formalmente, si di −t+ei (t) <li). Además, sobrecarga S (·) y Ei (·) para que también puedan tomar un vector θ como argumento. Por ejemplo, S (θ, t) es la taquigrafía para el s (t) del resultado F (θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no se puede ejecutar antes de su tiempo de liberación, el espacio de posibles resultados está restringido en el que s (θ, t) = I implica ri ≤ t.Además, debido a que el algoritmo en línea debe producir el cronograma a lo largo del tiempo, sin el conocimiento de las entradas futuras, debe tomar la misma decisión en el tiempo t para las entradas que son indistinguibles en este momento. Formalmente, deje θ (t) denota el subconjunto de las tuplas en θ que satisfacen ri ≤ t.La restricción es entonces que θ (t) = θ (t) implica s (θ, t) = s (θ, t). La función objetivo es la suma de los valores de los trabajos que se completan por sus respectivos plazos: W (O, θ) = I vi · µ (Ei (θ, DI) ≥ Li). Deje w ∗ (θ) = maxo∈O w (o, θ) denota el valor total máximo posible para el perfil θ. En el análisis competitivo, se evalúa un algoritmo en línea comparándolo con un algoritmo ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ. Debido a que el algoritmo O ﬄ ine conoce la entrada completa θ en el momento 0 (pero aún no puede iniciar cada trabajo I hasta el tiempo RI), siempre logra w ∗ (θ). Un algoritmo en línea f (·) es (estrictamente) C competitivo si no existe una entrada θ tal que c · w (f (θ), θ) <w ∗ (θ). También se dice que un algoritmo que es competitivo en C alcanza una relación competitiva de c.Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [TS, TF] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y fecha límite caen dentro del período de tiempo excede la duración del intervalo (formalmente, si TF −ts ≤ i | (TS≤ri, di≤tf) li). Sin tal suposición, no es posible lograr una relación competitiva finita [15].2.2 Resultados anteriores en la configuración no estratégica, [4] presenta un algoritmo de 4 competitivo llamado TD1 (Versión 2) para el caso de K = 1, mientras que [15] presenta un algoritmo competitivo de 2 (1+ √ k) llamadoDover para el caso general de K ≥ 1. Los límites inferiores coincidentes para los algoritmos deterministas para ambos casos se mostraron 62 en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (Versión 2) divide el cronograma en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a esta TB de tiempo) y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud;Sin embargo, para el resto del intervalo, la preferencia del trabajo activo solo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos enumerados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prevención durante este intervalo, porque el Job 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en TB = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda finalizar, la preferencia se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si evitar el trabajo activo, TD1 (versión 2) usa dos variables más: pérdida de TE y P. El primero registra la última fecha límite de un trabajo que se abandonará si el trabajo activo se ejecuta para su finalización (o, si no existe dicho trabajo, el momento en que el trabajo activo terminará si no está previsto). En este caso, TE = 17.0. El valor TE −TB representa el límite superior en la cantidad de tiempo de ejecución posible perdido al algoritmo ﬄ ﬄ ﬄ ﬄ ine debido a la finalización del trabajo activo. La otra variable, P pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo O ﬄ ine puede completarlo fuera del rango [TB, TE] .1 Si el algoritmo completa el trabajo activo y esta duración de los trabajos es al menos TE -TB +P Pérdida 4 4Luego, se garantiza que el algoritmo es 4 competitivo para este intervalo (tenga en cuenta que K = 1 implica que todos los trabajos tienen la misma densidad de valor y, por lo tanto, esas longitudes pueden usarse para calcular la relación competitiva). Debido a que este no es el caso en el momento 4.8 (ya que TE −tb +P pérdida 4 = 17.0−0.9 +4.0 4> 4.0 = L2), el algoritmo se adelanta al trabajo 2 para el trabajo 3, que luego se ejecuta para su finalización. Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6?6?6? Tabla 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan RI y DI, respectivamente, mientras que la longitud de la caja es igual a Li.3. Configuración de diseño del mecanismo Sin embargo, la información falsa sobre el trabajo 2 causaría que TD1 (versión 2) complete este trabajo. Por ejemplo, si el plazo del trabajo 2S se declarara como ˆd2 = 4.7, entonces tendría cero laxitud en el momento 0.7. En este momento, el algoritmo evitaría el trabajo 1 para el trabajo 2, porque la pérdida de TE -TB +P 4 = 4.7−0.0 +1.0 4> 0.9 = L1. El trabajo 2 se completaría antes de la llegada del trabajo 3.2 1, mientras que sería fácil alterar el algoritmo reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida de P.2 Si bien no describiremos lo significativamente más complejo para abordar problemas de incentivos como este, necesitamos formalizar la configuración como un problema de diseño de mecanismo. En esta sección primero presentamos la formulación de diseño del mecanismo y luego definimos nuestros objetivos para el mecanismo.3.1 Formulación Existe un centro, que controla el procesador y los agentes de N, donde el centro es desconocido por el centro de antemano. Cada trabajo I es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes θi ∈ θi. En el momento RI, el agente I observa en privado su tipo θi y no tiene información sobre el trabajo I antes de RI. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela solo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo γ = (θ1, ..., θn, g (·)), en el que cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g: Θ1 ×... × θn → o mapas los tipos declarados a un resultado o ∈ O. Un resultado O = (S (·), P1, ..., PN) consiste en un horario y un pago de cada agente al mecanismo. En una configuración de diseño de mecanismo estándar, el resultado se aplica al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, elegimos modelar devolver el trabajo si se completa y recolectar un pago de cada agente que ocurre en ˆDi, que, según la declaración de los agentes, es el últimopunto de tiempo relevante para ese agente. Es decir, incluso si el trabajo I se completa antes de ˆDI, el centro no devuelve el trabajo al agente I hasta ese momento. En cambio, esta decisión de modelado podría verse como una decisión por el diseñador de mecanismos de un espacio más grande de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completo es crucial para nuestro mecanismo. Cada utilidad de agentes, ui (g (ˆθ), θi) = vi · µ (ei (ˆθ, di) ≥ li) · µ (ˆdi ≤ di)-pi (ˆθ), es una función cuasi-lineal de su valor paraSu trabajo (si está completado y devuelto por su verdadero plazo) y el pago que realiza al centro. Suponemos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en que un agente no puede declarar una longitud más corta que la longitud verdadera, ya que el centro podría detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general permitiremos que los agentes declaren longitudes más largas, ya que en algunos entornos puede ser posible agregar trabajo innecesario a un trabajo. Sin embargo, también consideraremos una formulación restringida en la que no es posible este tipo de mentira. El tiempo de liberación declarado ˆri es el momento en que el agente elige enviar el trabajo I al centro, y no puede preceder al tiempo RI en el que el trabajo se revela al agente. El agente puede declarar una fecha límite o valor arbitraria. Para resumir, el agente I puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico, fue suficiente que el algoritmo conocer la K de límite superior en la relación ρmax ρmin, en la configuración de diseño del mecanismo fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de posibles densidades de valor) .3 Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior mostraremos en la Sección 5 implica que la información falsa también puede beneficiar un trabajo en Dover.3 Tenga en cuenta que luego podríamos forzar las declaraciones de agentes para satisfacer ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63, mientras que creemos que es poco probable que un centro conozca a K sin conocer este rango, luego presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que s (ˆθ, t) = I implica ˆri ≤ t, para capturar el hecho de que un trabajo no puede programarse en el procesador antes de que se declare al mecanismo. Como antes, se permite la prevención de trabajos, y el cambio de trabajo no lleva tiempo. Las restricciones debidas a los mecanismos en línea falta de conocimiento del futuro son que ˆθ (t) = ˆθ (t) implica s (ˆθ, t) = s (ˆθ, t), y ˆθ (ˆdi) = ˆθ (ˆdi) implicaPi (ˆθ) = Pi (ˆθ) para cada agente i. La configuración se puede resumir de la siguiente manera.1 Overview de la configuración: para todo T, el centro instancia s (ˆθ, t) ← i, para algunos i s.t.ˆRi ≤ t if ∃i, (ri = t) entonces θi se revela al agente I si ∃i, (t ≥ ri) y el agente I no ha declarado un trabajo, entonces el agente puedo declarar cualquier trabajo ˆθi, s.t.ˆRi = t y ˆli ≥ li if ∃i, (ˆdi = t) ∧ (ei (ˆθ, t) ≥ li) luego el trabajo completado I se devuelve al agente I si ∃i, (ˆdi = t) luego se establece el centro y recogePago PI (ˆθ) del Agente I 3.2 Objetivos del mecanismo Nuestro objetivo como diseñador de mecanismo es maximizar el valor de los trabajos completos, sujeto a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente I, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puedo aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo γ satisface la compatibilidad de incentivos (ic) si ∀i, θi, θi, ˆθ - i: ui (g (θi, ˆθ - i), θi) ≥ ui (g (θi, ˆθ−i), θi) deUna perspectiva del agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la cual se extraen otros tipos de agentes. Desde una perspectiva del diseñador de mecanismo, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará según él. Por estas razones, en este documento requerimos estrategias dominantes, en oposición a un concepto de equilibrio más débil, como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 Disminución del límite inferior en la relación competitiva.4 Un posible argumento contra la necesidad de compatibilidad con incentivos es que una mentira de los agentes en realidad puede mejorar el horario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa ˆd2 = 4.7. Sin embargo, si un agente se encuentra debido a creencias incorrectas sobre los aportes futuros, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se liberara, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes y, por lo tanto, no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Si bien restringirnos a los mecanismos directos compatibles con incentivos puede parecer limitante al principio, el principio de revelación para las estrategias dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad de generalidad. El segundo objetivo para nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo γ satisface la racionalidad individual (ir) si ∀i, θi, ˆθ - i, ui (g (θi, ˆθ - i), θi) ≥ 0. Finalmente, la función de bienestar social que nuestro objetivo es maximizar es la misma que la función objetivo de la configuración no estratégica: W (O, θ) = I VI · µ (EI (θ, DI) ≥ Li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando un análisis competitivo para compararlo con un mecanismo óptimo ﬄ ﬄ ine (que denotaremos con γoffline). Un mecanismo o ﬄ ine conoce todos los tipos en el tiempo 0 y, por lo tanto, siempre puede lograr w ∗ (θ) .5 Definición 3. Un mecanismo en línea γ es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de tipos de agentes θ tal que c · w (g (θ), θ) <w ∗ (θ).4. Resultados En esta sección, primero presentamos nuestro resultado positivo principal: A (1+ √ K) 2 +1 -Competitivo Mecanismo (γ1). Después de proporcionar cierta intuición de por qué γ1 satisface la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la relación competitiva. Luego consideramos un caso especial en el que K = 1 y los agentes no pueden mentir sobre la longitud de su trabajo, lo que nos permite alterar este mecanismo para que ya no requiere conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la más alta prioridad: (ˆvi + √ k · ei (ˆθ, t) · ρmin). A cada agente cuyo trabajo se completa se le cobra el valor más bajo que podría haber declarado de tal manera que su trabajo aún se habría completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, γ1 satisface tanto el IC con respecto a los valores como al IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación anterior, una longitud más corta o una fecha límite posterior) podría disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que el tercero causaría que el trabajo, si se completa, se devuelve al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completo en su fecha límite declarada, en lugar de en el punto en el que se completa.5 Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el momento 0, y obligar a γoffline a ser compatible con incentivos para que los agentes declaren sinceramente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que la ejecución de un mecanismo VCG (ver, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social.64 Mecanismo 1 γ1 Ejecutar s (ˆθ, ·) según el algoritmo 1 para todo lo que hago si ei (ˆθ, ˆdi) ≥ ˆli {agente es el trabajo que se completa} entonces pi (ˆθ) ← arg minvi≥0 (ei (((((((((((((((((((ei (ei ((ei ((ei ((ei (((ei ((ei ((ei ((ei (((eiˆRi, ˆdi, ˆli, vi), ˆθ -i), ˆdi) ≥ ˆli) else Pi (ˆθ) ← 0 Algoritmo 1 Para todos los to HACE ← {i | (t ≥ ˆri) ∧ (ei (ˆθ, t)<ˆLi) ∧ (ei (ˆθ, t)+ ˆdi-t ≥ ˆli)} {conjunto de todos los trabajos liberados, no completados, no abandonados} si disponibles = ∅ entonces s (ˆθ, t) ← arg maxi∈Atail(ˆVi + √ k · ei (ˆθ, t) · ρmin) {rompa lazos a favor de ˆri} más s (ˆθ, t) ← 0 Sigue a argumentar por qué un agente no tiene incentivos para empeorar su trabajo. Los únicos efectos posibles de una longitud inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente están causando que se abandonen y que se devuelva antes (lo que no tiene efecto sobrela utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considere un mecanismo γ1 que difiere de γ1 en el sentido de que no se adelanta al trabajo activo I a menos que exista otro trabajo j tal que (ˆVi + √ k · li (ˆθ, t) · ρmin) <ˆvj. Tenga en cuenta que a medida que un trabajo activo se acerca a la finalización en γ1, su condición para la preferencia se acerca a la de γ1. Sin embargo, los tipos en la Tabla 2 para el caso de K = 1 muestran por qué un agente puede tener un incentivo para retrasar la llegada de su trabajo bajo γ1. El trabajo 1 se activa en el momento 0, y el trabajo 2 se abandona en su liberación en el momento 6, porque 10 + 10 = V1 + L1> V2 = 13. Luego, en el momento 8, el trabajo 1 se prevenga por el trabajo 3, porque 10 + 10 = v1 + l1 <v3 = 22. El trabajo 3 luego se ejecuta hasta la finalización, lo que obliga a Job 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el tiempo 8, desde 13 + 13 = v2 + l2> v3 = 22. Por lo tanto, si el Agente 1 hubiera declarado falsamente ˆR1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 se habría completado durante el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6?6?6? Tabla 2: Los trabajos utilizados para mostrar por qué una versión ligeramente alterada de γ1 no sería compatible con incentivos con respecto a los tiempos de lanzamiento. Intuitivamente, γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se activa, debe tener una prioridad mayor que todos los demás trabajos disponibles. En segundo lugar, debido a que una prioridad de empleos solo puede aumentar a través del aumento de su tiempo transcurrido, EI (ˆθ, t), la tasa de aumento de una prioridad de empleos es independiente de sus características. Estas dos propiedades juntas implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador.4.1 Prueba de racionalidad individual y compatibilidad de incentivos Después de presentar la prueba (trivial) de IR, dividimos la prueba de IC en Lemmas. Teorema 1. El mecanismo γ1 satisface la racionalidad individual. Prueba. Para arbitrary i, θi, ˆθ - i, si el trabajo I no se completa, entonces el agente i no paga nada y, por lo tanto, tiene una utilidad de cero;es decir, pi (θi, ˆθ - i) = 0 y ui (g (θi, ˆθ - i), θi) = 0. Por otro lado, si se completa el trabajo I, entonces su valor debe exceder el agente es el pago. Formalmente, ui (g (θi, ˆθ - i), θi) = vi - arg minvi≥0 (ei (((ri, di, li, vi), ˆθ -i), di) ≥ li) ≥ 0 debe sostener, ya que vi = vi satisface la condición. Para demostrar, debemos mostrar que para un agente arbitrario I, y un perfil arbitrario ˆθ - i de declaraciones de los otros agentes, agente que nunca puedo obtener haciendo una declaración falsa ˆθi = θi, sujeto a las restricciones que ˆri ≥Ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆVI, si las declaraciones veraces de RI, DI y LI no hacen que se complete el trabajo I, entonces peores declaraciones de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ y li yˆDi ≤ Di) nunca puede hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆVi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ - i),ˆDi ≥ ˆli = ⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ - i), ˆdi ≥ ˆli prueba. Suponga por contradicción que esta condición no se mantiene, es decir, el trabajo I no se completa cuando RI se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ RI. Primero analizamos el caso en el que el tiempo de lanzamiento se declara sinceramente, y luego mostramos ese trabajo que no puedo completar cuando el agente me retraso que lo envía al centro. Caso I: el agente I declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, defina los siguientes tres puntos en la ejecución del trabajo i.• Sea ts = arg mint s ((ˆθi, ˆθ - i), t) = ser el tiempo en que el trabajo i inicia la ejecución.• Sea tp = arg mint> ts s ((ˆθi, ˆθ - i), t) = ser el tiempo en que el trabajo I se preempete primero.• Sea ta = arg mint ei ((ˆθi, ˆθ - i), t) + ˆdi - t <ˆli sea el momento en que el trabajo I está abandonado.65 Si TS y TP están indefinidos porque el trabajo I nunca se activa, entonces Ts = tp = Ta. Además, divide los trabajos declarados por otros agentes antes de TA en los siguientes tres sets.• x = {j | (ˆrj <tp) ∧ (j = i)} consiste en los trabajos (que no sean) que llegan antes del trabajo I primero se adelantan.• y = {j | (tp ≤ ˆrj ≤ ta) ∧ (ˆVJ> ˆVi + √ k · ei ((ˆθi, ˆθ -i), ˆrj)} consiste en los trabajos que llegan a la gama [TP, TA] yque cuando llegan tienen una prioridad más alta que el trabajo I (tenga en cuenta que estamos utilizando la normalización). • Z = {J | (tp ≤ ˆrj ≤ ta) ∧ (ˆVJ ≤ ˆVi + √ k · ei ((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan al rango [TP, TA] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (TP, TA] deben ser I o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se mantenga trivialmente), debe ser el caso de que el trabajo I tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el momento TP, ya que en ese momento solo el trabajo de TP era disponible y el trabajo estaba disponible y el trabajoEstaba activo. Formalmente, ˆvx + √ k · ex ((ˆθi, ˆθθ - i), tp) <ˆVi + √ k · ei ((ˆθi, ˆθ -i), tp) debe sostener.6 podemos mostrar que, sobre el rango[TP, TA], no hay trabajo x ∈ X se ejecuta en el procesador. Suponga por contradicción que esto no es cierto. Sea tf ∈ [tp, ta] el primer momento en este rango de que algún trabajo x ∈ X está activo, lo que implica que ex ((ˆθi, ˆθ - i), tf) = ex ((ˆθi, ˆθ - i),tp). Luego podemos mostrar que el trabajo I tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k · ex ((ˆθi, ˆθ - i), tf) = ˆvx+ √ k · ex ((ˆθi, ˆθ−i), tp)<ˆVi + √ k · ei ((ˆθi, ˆθ - i), tp) ≤ ˆVi + √ k · ei ((ˆθi, ˆθ - i), tf), contradiciendo el hecho de que el trabajo X está activo en el tiempo TF. Un argumento similar se aplica a un trabajo arbitrario Z ∈ Z, comenzando en el tiempo de liberación de TI ˆrz> TP, ya que por definición del trabajo I tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (TP, TA] son yo y los del conjunto Y. Caso II: el agente I declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri> ri. Ahora mostramos ese trabajo que no puedo completar en este caso, dado que no se completó en el caso de I. Primero, podemos restringir el rango de ˆri que debemos considerar de la siguiente manera. Declarar ˆri ∈ (RI, TS] no afectaría el horario, ya que TS seguiría siendo la primera vez que ejecuta el trabajo I. Además, declarar ˆri> ta no podría hacer que el trabajo se complete, ya que di - ta <ˆli se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts, ta]. Para que declare ˆθi para que se complete el trabajo I, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (TP, TA], ya que los únicos trabajos distintos de yo que están activos durante ese rangoestán en y. Sea tc = arg mint∈ (tp, ta] [∃yc ∈ Y, (s ((ˆθi, ˆθ - i), t) = yc) ∧ (s ((ˆθi, ˆθ - i), t) = yc)] ser la primera vez que ocurre tal cambio. Ahora mostraremos que para cualquier ˆri ∈ (ts, ta], no puede existir un trabajo con mayor prioridad que yc en el tiempo tc, contradiciendo (s ((ˆθi, ˆθ - i), t) = yc). Primero tenga en cuenta que el trabajo no puedo tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) de modo que ∃y ∈ 6 por simplicidad, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otraJob Y, asumiremos que la prioridad del trabajo XS es estrictamente mayor que el trabajo, porque, en el caso de un empate que favorece X, los lazos futuros también se romperían a favor del Job X.Y, (s ((ˆθi, ˆθ - i), t) = y) ∧ (s ((ˆθi, ˆθ - i), t) = i), contradiciendo la definición de TC. Ahora considere un arbitrario y ∈ Y tal que y = yc. En el caso de que yo, sabemos que Job Y tiene menor prioridad que YC en el momento TC;es decir, ˆvy + √ k · ey ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Por lo tanto, pasar al Caso II, el trabajo Y debe reemplazar algún otro trabajo antes de TC. Dado que ˆry ≥ tp, la condición es que debe existir algunos t ∈ (tp, tc) tal que ∃w ∈ Y ∪ {i}, (s ((ˆθi, ˆθ - i), t) = w) ∧ (s((ˆΘi, ˆθ - i), t) = y). Dado que w ∈ Y contradeciría la definición de TC, sabemos que w = i. Es decir, el trabajo que reemplaza Y debe ser i. Por definición del conjunto y, sabemos que ˆvy> ˆvi + √ k · ei ((ˆθi, ˆθ - i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo no podría haber ejecutado en lugar de y en el caso I. Por otro lado, si ˆry> t, entonces el trabajo y obviamente no podía ejecutar en el momento t, contradiciendo la existencia de tal tiempo t.Ahora considere un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo I tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex ((ˆθi, ˆθ - i), ts) <ˆvi + √ k · ei (((ˆΘi, ˆθ - i), ts). También sabemos que ˆVi + √ k · ei ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Dado que la demora en la llegada no afectará la ejecución hasta el tiempo, y dado que el trabajo X no puede ejecutar en lugar de un trabajo y en cualquier momento t ∈ (tp, tc] por definición de tc, la única forma de prioridad de trabajo xsAumente antes de TC a medida que avanzamos del caso I al II es reemplazar el trabajo I por el rango (TS, TC]. Por lo tanto, un límite superior en el trabajo XS prioridad cuando el agente I declara ˆθi es: ˆvx+ √ k · ex ((ˆθi, ˆθ -i), ts)+ ei ((ˆθi, ˆθ - i), tc) −ei ((ˆθi,, ˆΘ - i), ts) <ˆVi + √ k · ei ((ˆθi, ˆθ - i), ts) + ei ((ˆθi, ˆθ - i), tc) −Ei ((ˆθi, ˆθ - i),ts) = ˆVi + √ k · ei ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Por lo tanto, incluso en este límite superior, Job YC ejecutaría en lugar del trabajo X en el momento TC. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en el tiempo de liberación ˆrz. Dado que los conjuntos {I}, X, Y, Z dividen el conjunto de trabajos publicados antes de TA, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de TC y completando la prueba. Lema 3. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆVi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆVi), ˆθ - i), ˆdi ≥ ˆli = =⇒ ei ((ri, di, li, ˆvi), ˆθ - i), ˆdi ≥ li prueba. Suponga que por contradicción existe cierta instanciación de las variables anteriores, de modo que el trabajo I no se completa cuando Li y Di se declaran sinceramente, pero se completa para algunos par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Tenga en cuenta que el único efecto que ˆDi y ˆli tienen en la ejecución del algoritmo está en si está disponible o no. Específicamente, afectan las dos condiciones: (ei (ˆθ, t) <ˆli) y (ei (ˆθ, t) + ˆdi - t ≥ ˆli). Debido a que el trabajo I se completa cuando se declaran ˆli y ˆDi, la condición anterior (para completar) debe volverse falsa antes de la segunda. Dado que declarar con sinceramente Li ≤ ˆli y Di ≥ ˆdi solo hará que la condición anterior se vuelva falsa antes y la última condición se vuelva falsa más adelante, la ejecución del algoritmo no se verá afectada cuando se mude a declaraciones veraces, y el trabajo I será completado, uncontradicción. Ahora usamos estos dos lemas para demostrar que el pago de un trabajo completado solo puede aumentar al declarar falsamente peor ˆli, ˆdi y ˆri.66 Lema 4. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ-i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ - i), di ≥ li prueba. Suponga por contradicción que esta condición no se mantiene. Esto implica que existe algún valor vi de tal manera que la condición (ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli) se mantenga, pero (ei ((((ri, di, li,vi), ˆθ - i), di) ≥ li) no lo hace. Aplicando lemas 2 y 3: (ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli) = ⇒ (ei (((ri, ˆdi, ˆli, vi), ˆθ - i), ˆDi) ≥ ˆli) = ⇒ (ei (((ri, di, li, vi), ˆθ - i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótono en su valor declarado. Lema 5. En el mecanismo γ1, la siguiente condición es válida para todos los i, ˆθi, ˆθ - i: ∀ ˆVi ≥ ˆVi, ei ((ˆri, ˆdi, ˆli, ˆVi), ˆθ - i), ˆdi ≥ ˆli = ⇒ ei ((ˆri,,ˆDi, ˆli, ˆvi), ˆθ - i), ˆdi ≥ ˆli la prueba, por contradicción, de esta lema se omite porque es esencialmente idéntica a la de Lemma 2 para ˆri. En el caso I, el agente I declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos luego procede como antes: la ejecución no cambiará hasta el tiempo TS porque la prioridad inicial del trabajo I disminuye a medida que avanzamos del caso I al II;y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea yo en el rango (TP, TA]. Ahora podemos combinar los lemas para mostrar que no es posible una desviación rentable. Teorema 6. El mecanismo γ1 satisface la compatibilidad de incentivos. Prueba. Para un agente arbitrario I, sabemos que ˆri ≥ ri y ˆli ≥ li se mantienen por suposición. También sabemos que el agente I no tiene ningún incentivo para declarar ˆDi> di, porque Job I nunca sería devuelto antes de su verdadera fecha límite. Luego, debido a que la función de pago no es negativa, el agente es la utilidad no podría exceder el cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisface ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente usando IR, podemos restringir aún más la consideración a ˆθi que hace que el trabajo I se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo I se complete, entonces por Lemma 4, dicha declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que se complete el trabajo I, entonces declarar que tal ˆθi hará que el agente I tenga una utilidad negativa, ya que vi <arg minvi≥0 ei (((ri, di, li, vi), ˆΘ - i), ˆdi) ≥ li ≤ arg minvi≥0 ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli se mantiene por Lemmas 5 y 4, respectivamente.4.2 Prueba de relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo mostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos mostrado IR, para demostrar la relación competitiva, sigue siendo limitar la pérdida de bienestar social contra γoffline. Denota por (1, 2, ..., f) la secuencia de trabajos completados por γ1. Divida el tiempo en intervalos de = (abierto F, cierre F], uno para cada trabajo F en esta secuencia. Establezca TClose F como el tiempo en el que se completa el trabajo F, y configure Topen F = TClose F - 1 para F ≥ 2, y Topen 1 = 0 para F = 1. Además, deje que Tbegin F sea la primera vez que el procesador no está inactivo en el intervalo si. Lema 7. Para cualquier intervalo si, la siguiente desigualdad se mantiene: tclose f - tbegin f ≤ (1 + 1√ k) · Vf prueba. Intervalo si comienza con un período de tiempo (posiblemente cero) en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2, ..., c), donde cada trabajo I en esta secuencia es previsto por el trabajo I + 1, excepto el trabajo C, que se completa (por lo tanto, el trabajo C enEsta secuencia es la misma que el trabajo F es la secuencia global de trabajos completos). Deja que sea el momento en que el trabajo comience a la ejecución. Tenga en cuenta que TS 1 = tbegin f. En el rango [tbegin f, tclose f], la prioridad (vi+ √ k · ei (θ, t)) del trabajo activo aumenta monotónicamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo y solo puede aumentarEn un momento en que ocurre la preferencia. Por lo tanto, cada trabajo i> 1 en esta secuencia comienza la ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activa. Ahora mostramos que el valor del trabajo C completado excede el producto de √ k y el tiempo que pasa en el intervalo en los trabajos 1 a C - 1, o, más formalmente, que la siguiente condición se mantiene: VC ≥ √ K C - 1 H= 1 (eh (θ, ts h+1) - eh (θ, ts h)). Para mostrar esto, demostraremos por inducción que la condición más fuerte VI ≥ √ k i - 1 h = 1 eh (θ, ts h+1) se mantiene para todos los trabajos i en la secuencia. Caso base: para i = 1, v1 ≥ √ k 0 h = 1 eh (θ, ts h+1) = 0, ya que la suma supera cero elementos. Paso inductivo: para un arbitrario 1 ≤ i <c, suponemos que vi ≥ √ k i - 1 h = 1 eh (θ, ts h+1) se mantiene. En el tiempo TS i+1, sabemos que vi+1 ≥ Vi+√ k · ei (θ, ts i+1) se mantiene, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h = 1 eh (θ, ts h+1), completando el paso inductivo. También sabemos que TClose f - ts c ≤ lc ≤ vc debe mantener, al simplificar la normalización de ρmin = 1 y el hecho de que el tiempo de ejecución de CS de trabajo no puede exceder su longitud. Podemos unir el tiempo de ejecución total de IF por: tclose f - tbegin f = (tclose f −ts c)+ c - 1 h = 1 (eh (θ, ts h+ 1) −eh (θ, ts h)) ≤ (1+ 1√ k) Vf. Ahora consideramos la posible ejecución de trabajos incompletos por γoffline. Asociar cada trabajo I que no se completa con γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos ahora están asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo puedo ser abandonado después del cierre del último intervalo en TClose f. Debido a que el procesador está inactivo después de TClose F, cualquier trabajo de este tipo que yo volviera activo en algún momento T ≥ tclose F, lo que conduciría a la finalización de algún trabajo, crea un nuevo intervalo y contradice el hecho de que si es el último.67 El siguiente lema es equivalente al lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo si y cualquier trabajo que abandonara en IF, la siguiente desigualdad es válida: vi ≤ (1 + √ k) vf. Prueba. Suponga por contradicción que existe un trabajo en el que abandoné si tal que vi> (1 + √ k) vf. En TClose F, la prioridad del trabajo F es vf + √ k · lf <(1 + √ k) vf. Debido a que la prioridad del trabajo activo aumenta monotónicamente en el rango [tbegin f, tclose f], el trabajo I tendría una prioridad más alta que el trabajo activo (y, por lo tanto, comenzaría la ejecución) en algún momento t ∈ [tbegin f, tclose f]. Una vez más, aplicando monotonicidad, esto implicaría que la prioridad del trabajo activo en TClose F excede (1 + √ k) VF, contradiciendo el hecho de que es (1 + √ k) VF. Como en [15], para cada intervalo IF, le damos a γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al VF adversario, ya que el adversario puede completar este trabajo en algún momento futuro, debido al hecho de que γ1 ignora los plazos. El siguiente lema es Lema 5.10 en [15], y su prueba ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante si no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el regalo de K · (tclose f −tbegin f) (intuitivamente, esto es equivalente a ejecutar trabajos con la densidad de valor máxima posible a lo largo del tiempoque γ1 está activo), y luego comience la ejecución de un trabajo abandonado por γ1 justo antes de TClose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo γ1 es (1+ √ k) 2+ 1 -competitivo. Prueba. Utilizando el hecho de que la forma en que los trabajos están asociados con los intervalos particionan todo el conjunto de trabajos, podemos mostrar la relación competitiva al mostrar que γ1 es (1+ √ k) 2 +1 -competitivo para cada intervalo en la secuencia (1, ..., f). En un intervalo arbitrario si, el algoritmo O ﬄ ine puede lograr como máximo (tclos f −tbegin f) · k+vf+(1+ √ k) vf, de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando el lema 7, esta cantidad se limita desde arriba por (1+ 1√ k) · vf · k+ vf+ (1+ √ k) vf = ((1+ √ k) 2 +1) · vf. Dado que γ1 logra VF, la relación competitiva es válida.4.3 Caso especial: longitud inalterable y k = 1, mientras que hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, no es posible mentir sobre la longitud del trabajo en algunos entornos. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alargue el trabajo y permita que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos son las densidades de valor uniformes (k = 1), que fue el caso considerado por [4]. Si la configuración satisface estas dos condiciones, entonces, al usar el mecanismo γ2, podemos lograr una relación competitiva de 5 (que es la misma relación competitiva que γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos que sean más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en el que los usuarios aún se interestan en sí mismas.7 Mecanismo 2 γ2 Ejecutar S (ˆθ, ·) según el algoritmo 2 para todosyo hago pi (ˆθ) ← 0 algoritmo 2 para todos t hove ← {i | (t ≥ ˆri) ∧ (ei (ˆθ, t) <li) ∧ (ei (ˆθ, t)+ ˆdi - t ≥ li)} si disponible = ∅ entonces s (ˆθ, t) ← arg maxi∈Avil (li + ei (ˆθ, t)) {rompa lazos a favor de ˆri} más s (ˆθ, t) ← 0 teorema 11. Cuando K = 1, y cada agente no puedo declarar falsamente Li, el mecanismo γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente no puedo declarar falsamente Li, el mecanismo γ2 es 5 competitivo. Dado que este mecanismo es esencialmente una simplificación de γ1, omitimos pruebas de estos teoremas. Básicamente, el hecho de que K = 1 y ˆli = Li sostienen permiten que γ2 sustituya la prioridad (li +ei (ˆθ, t)) para la prioridad utilizada en γ1;Y, dado que se ignora ˆVi, los pagos ya no son necesarios para garantizar la compatibilidad de incentivos.5. Un límite inferior competitivo ahora mostramos que la relación competitiva de (1 + √ k) 2 + 1 lograda por γ1 es un límite más bajo para los mecanismos en línea deterministas. Para hacerlo, atraeremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), lo que requiere que el centro nunca paga a un agente (formalmente, ∀i, ˆθ, pi (ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño del mecanismo. Sin embargo, observamos que tanto γ1 como γ2 lo satisfacen trivialmente, y que, en la siguiente prueba, cero solo sirve como una utilidad de referencia para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ-I. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k) 2 en el entorno no estratégico, con la novedad principal en la perturbación de la secuencia de trabajoy los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li + 1 = λ · li - k · i h = 1 lh y l1 = 1, donde (1 + √ k) 2 - 1 <λ <(1 + √ k) 2, existe un número entero m ≥ 1 tal que lm+k · m - 1 h = 1 lh lm> λ.7 Si bien no se requieren pagos en este entorno, γ2 se puede cambiar para cobrar un pago sin afectar la compatibilidad de incentivos cargando una fracción fija de Li por cada trabajo I que se complete.68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga NNP y que logra una relación competitiva menor que (1 + √ k) 2 + 1. Prueba. Suponga por contradicción que existe un mecanismo en línea determinista γ que satisface NNP y que logra una relación competitiva de c = (1 + √ k) 2 + 1 - para algunos> 0 (y, por implicación, satisface IC e IR también). Dado que una relación competitiva de C implica una relación competitiva de C + X, para cualquier x> 0, suponemos sin pérdida de generalidad que <1. Primero, construiremos un perfil de los tipos de agentes θ usando un argumento adversario. Después de posiblemente perturbando ligeramente θ para asegurar que se cumpla una propiedad de estricto, usaremos una perturbación más significativa de θ para alcanzar una contradicción. Ahora construimos el perfil original θ. Elija un α tal que 0 <α <, y defina δ = α CK+3K. El adversario utiliza dos secuencias de empleos: menor y mayor. Los trabajos menores I se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se lanza en el momento 0, y ri = di - 1 para todos i> 1. La secuencia se detiene cada vez que γ completa cualquier trabajo. Los trabajos principales también tienen la laxitud cero, pero tienen la relación de valor más pequeña posible (es decir, vi = li). Las longitudes de los principales trabajos que se pueden liberar, comenzando con i = 1, se determinan por la siguiente relación de recurrencia.li + 1 = (c - 1 + α) · li - k · i h = 1 lh l1 = 1 Los límites en α implican que (1 + √ k) 2 - 1 <c - 1 + α <(1+ √ k) 2, que nos permite aplicar el lema 13. Sea M el número positivo más pequeño de tal manera que LM+K · M - 1 H = 1 LH LM> C - 1+α. El primer trabajo importante tiene un tiempo de liberación de 0, y cada trabajo principal I> 1 tiene un tiempo de liberación de RI = Di - 1 - δ, justo antes de la fecha límite del trabajo anterior. El adversario libera el principal trabajo I ≤ m si y solo si cada trabajo principal J <I fue ejecutado continuamente sobre el rango [RI, RI+1]. No se publica un trabajo importante después del trabajo m.Para lograr la relación competitiva deseada, γ debe completar algún trabajo F importante, porque γoffline siempre puede al menos completar el trabajo principal 1 (por un valor de 1), y γ puede completar como máximo un trabajo menor (para un valor de αC+3 <1 c). Además, para que este trabajo F se publique, el tiempo del procesador anterior a RF solo se puede dedicar a ejecutar trabajos importantes que luego se abandonan. Si f <m, entonces se lanzará el trabajo principal F + 1 y será el trabajo final final. Γ no puede completar el trabajo F +1, porque rf +lf = df> rf +1. Por lo tanto, θ consiste en trabajos principales 1 a F + 1 (o, F, si F = M), más trabajos menores desde el tiempo 0 hasta el tiempo DF. Ahora posiblemente perturbamos θ ligeramente. Por IR, sabemos que VF ≥ PF (θ). Dado que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df están incrementados por δ sobre sus valores respectivos en θf. Por IC, el trabajo F aún debe completarse mediante γ para el perfil (θf, θ - F). Si no, entonces por IR y NNP sabemos que PF (θf, θ - f) = 0, y por lo tanto que UF (g (θf, θ - f), θf) = 0. Sin embargo, el agente F podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: Uf (g (θf, θ - f), θf) = vf - pf (θ) = Δ> 0, violando ic ic. Además, el agente F debe cargarse la misma cantidad (es decir, pf (θf, θ - f) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la prueba, suponga que vf> pf (θ). Ahora usamos una perturbación más sustancial de θ para completar la prueba. Si f <m, entonces define θf para que sea idéntico a θf, excepto que df = df + 1 + lf, lo que permite que el trabajo F se ejecute completamente después de que se complete el trabajo F + 1. Si f = m, entonces, establece df = df +lf. IC requiere que para el perfil (θf, θ - f), γ todavía ejecuta el trabajo f continuamente sobre el rango [RF, RF +LF], evitando que el trabajo F +1 se complete. Suponga por contradicción que esto no era cierto. Luego, en la fecha límite original de DF, el trabajo F no se completa. Considere el perfil posible (θf, θ - f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene cero laxitud, rx = df y vx = lx = max (df - df, (c (c+ 1) · (LF + LF + 1)). Debido a que este nuevo perfil es indistinguible de (θf, θ - f) a γ antes del tiempo DF, debe programar trabajos de la misma manera hasta DF. Luego, para lograr la relación competitiva deseada, debe ejecutar Job X continuamente hasta su fecha límite, que es mediante construcción al menos tan tarde como la nueva fecha límite DF del trabajo f.Por lo tanto, el trabajo F no se completará y, por IR y NNP, debe ser el caso de que pf (θf, θ - f, θx) = 0 y UF (g (θf, θ - f, θx), θf)= 0. Usando el hecho de que θ es indistinguible de (θf, θ - f, θx) hasta el tiempo df, si el agente f declaró falsamente su tipo como el original θf, entonces su trabajo sería completado por DF y se le cobraría PF (θ). Su utilidad aumentaría a UF (g (θf, θ - f, θx), θf) = vf - pf (θ)> 0, contradiciendo IC. Mientras que la ejecución de γS debe ser idéntica para ambos (θf, θ - F) y (θf, θ - F), γoffline puede aprovechar el cambio. Si f <m, entonces γ logra un valor de a lo la mayoría de LF+δ (el valor del trabajo F si se perturbó), mientras que γOffline logra un valor de al menos k · (f h = 1 lh −2Δ)+lf+1+LF ejecutando trabajos menores hasta RF+1, seguido del trabajo F +1 y luego el trabajo F (restamos dos ΔS en lugar de uno porque el último trabajo menor antes de RF+1 puede tener que ser abandonado). Sustituyendo en LF+1, la relación competitiva es al menos al menos: k · (f h = 1 lh - 2Δ)+lf+1+lf lf+δ = k · (f h = 1 lh) −2k · Δ+(c−1 +α) · · lf −k −k · (f h = 1 lh) +lf lf +Δ = c · lf +(α · lf −2k · Δ) lf +δ ≥ c · lf +((ck +3k) δ−2k · δ) lf +δ> c.Si, en cambio, F = M, entonces γ logra un valor de como máximo LM + δ, mientras que γoffline logra un valor de al menos k · (m h = 1 lh - 2δ) + lm completando trabajos menores hasta dm = rm + lm, yluego completando el trabajo m.La relación competitiva es al menos: k · (m h = 1 lh - 2Δ)+lm lm+δ = k · (m - 1 h = 1 lh) −2k · Δ+klm+lm lm+δ> (c− (c−1+α) · LM - 2K · δ+KLM LM+δ = (C+K - 1) · LM+(αLM - 2K · δ) LM+δ> C.6. Trabajo relacionado en esta sección Describimos trabajos relacionados que no sean los dos documentos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo O ﬄ ine (ver, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el Centro posee los trabajos en un entorno de ine, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este documento también lanzó el área del diseño del mecanismo algorítmico, en el que el mecanismo debe SAT69 requisitos computacionales ISFY además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño del mecanismo de intercambio de costos de multidifusión (ver, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multidifusión, si el agente recibe la transmisión y el preciodebe pagar. Para una encuesta de este y otros temas en el diseño de mecanismo algorítmico distribuido, ver [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de compensación del mercado en línea, en el que el subastador coincide con las compras y vende ofertas (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que sea compatible con incentivos con respecto a los valores. La declaración de valores también se considera en [3] y [16], que consideran subastas en línea de múltiples unidades. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que tiene un suministro ilimitado. Se señala en [16] que sus resultados continúan sujetando cuando la configuración se extiende para que los postores puedan retrasar su llegada. El único otro artículo que somos conscientes de que aborda el problema de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna el ancho de banda a los agentes que declaran tanto su valor como su tiempo de llegada. Se presenta una estrategia dominante mecanismo IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras.7. Conclusión En este documento, consideramos un dominio de programación en línea para el cual se encontraron algoritmos con la mejor relación competitiva posible, pero para las cuales se requerían nuevas soluciones cuando la configuración se extiende para incluir agentes interestonados. Presentamos un mecanismo que es un incentivo compatible con respecto al tiempo de liberación, fecha límite, longitud y valor, y que solo aumenta la relación competitiva por uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la longitud de su trabajo. Luego mostramos un límite inferior coincidente en la relación competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en esta configuración. Una es determinar si el límite inferior puede fortalecerse eliminando la restricción de pagos no negativos. Además, aunque creemos que es razonable fortalecer la suposición de conocer la relación máxima posible de las densidades de valor (k) para conocer el rango real de posibles densidades de valor, sería interesante determinar si existe un ((1 + √k) 2 + 1) -Cepetitivo Mecanismo bajo la suposición original. Finalmente, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro.8. Referencias [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en costos compartidos de multidifusión, juegos y comportamiento económico (para aparecer).[2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de los mecanismos en línea que contienen verdad a la optimización en línea, Actas sobre el 35º Simposio sobre la teoría de la computación, 2003. [3] Z. Bar-Yossef, K.Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio ACM-SIAM anual sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra,A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en línea en línea, Journal of Real Time Systems 4 (1992), no.2, 125-144.[5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13º Simposio ACM-SIAM anual sobre algoritmos discretos, 2002. [6] A. Borodin y R. El-Yaniv,Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para la gestión y programación de recursos en computación en la red, The Journal of Concurrence and Computation:Práctica y experiencia 14 (2002), 1507-1542.)Shenker, Diseño de mecanismo algorítmico distribuido: resultados recientes y direcciones futuras, Actas del sexto taller internacional sobre algoritmos y métodos discretos para la computación y comunicaciones móviles, 2002, pp. 1-13.[10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: The State of the Art, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios de WiFi en Starbucksissues en el diseño del mecanismo en línea, EC03,2003. [12] R. L. Graham, límites para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581.[13] B. Kalyanasundaram y K. Pruhs, la velocidad es tan poderosa como Clairvoyance, Journal of the ACM 47 (2000), 617-643.[14] C. Koo, T. Lam, T. Ngan y K. a la programación en línea con plazos ajustados, Teórica Computer Science 295 (2003), 251-261.[15] G. Koren y D. Shasha, D-Over: un algoritmo de programación en línea óptimo para sistemas sobrecargados en tiempo real, Siam Journal of Computing 24 (1995), no.2, 318-339.[16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Green, Microeconomic Theory, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismo algorítmico, Juegos y Comportamiento Económico 35 (2001), 166-196.[19] C. Papadimitriou, Algoritmos, Juegos e Internet, Stoc, 2001, pp. 749-753.70",
    "original_sentences": [
        "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
        "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
        "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
        "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
        "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
        "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
        "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
        "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
        "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
        "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
        "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
        "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
        "First, the designer selects the online algorithm.",
        "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
        "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
        "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
        "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
        "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
        "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
        "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
        "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
        "Instead of being released to the algorithm, each job is now released only to its owning agent.",
        "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
        "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
        "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
        "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
        "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
        "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
        "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
        "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
        "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
        "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
        "The rest of the paper is structured as follows.",
        "In Section 2, we formally define and review results from the original, non-strategic setting.",
        "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
        "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
        "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
        "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
        "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
        "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
        "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
        "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
        "Each job is released at time ri, at which point its three other characteristics are known.",
        "Nothing is known about the job before its arrival.",
        "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
        "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
        "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
        "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
        "Thus, (θi, θ−i) denotes a complete vector of tuples.",
        "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
        "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
        "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
        "The algorithm is assumed to always know an upper bound k on the importance ratio.",
        "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
        "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
        "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
        "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
        "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
        "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
        "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
        "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
        "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
        "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
        "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
        "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
        "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
        "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
        "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
        "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
        "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
        "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
        "In this section we provide a high-level description of TD1 (version 2) using an example.",
        "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
        "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
        "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
        "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
        "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
        "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
        "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
        "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
        "In this case, te = 17.0.",
        "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
        "The other variable, p loss, is equal to the length of the first active job of the current interval.",
        "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
        "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
        "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
        "Table 1: Input used to recap TD1 (version 2) [4].",
        "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
        "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
        "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
        "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
        "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
        "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
        "Each job i is owned by a separate agent i.",
        "The characteristics of the job define the agents type θi ∈ Θi.",
        "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
        "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
        "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
        "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
        "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
        "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
        "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
        "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
        "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
        "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
        "We assume that each agent is a rational, expected utility maximizer.",
        "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
        "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
        "However, we will also consider a restricted formulation in which this type of lie is not possible.",
        "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
        "The agent can declare an arbitrary deadline or value.",
        "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
        "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
        "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
        "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
        "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
        "As before, preemption of jobs is allowed, and job switching takes no time.",
        "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
        "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
        "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
        "Definition 1.",
        "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
        "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
        "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
        "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
        "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
        "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
        "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
        "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
        "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
        "Definition 2.",
        "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
        "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
        "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
        "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
        "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
        "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
        "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
        "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
        "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
        "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
        "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
        "We now argue why it satisfies IC with respect to the other three characteristics.",
        "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
        "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
        "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
        "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
        "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
        "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
        "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
        "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
        "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
        "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
        "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
        "Job 3 then executes to completion, forcing job 1 to be abandoned.",
        "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
        "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
        "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
        "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
        "Intuitively, Γ1 avoids this problem because of two properties.",
        "First, when a job becomes active, it must have a greater priority than all other available jobs.",
        "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
        "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
        "Theorem 1.",
        "Mechanism Γ1 satisfies individual rationality.",
        "Proof.",
        "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
        "On the other hand, if job i is completed, then its value must exceed agent is payment.",
        "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
        "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
        "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
        "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
        "Lemma 2.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
        "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
        "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
        "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
        "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
        "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
        "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
        "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
        "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
        "Assume by contradiction that this is not true.",
        "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
        "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
        "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
        "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
        "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
        "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
        "First, we can restrict the range of ˆri that we need to consider as follows.",
        "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
        "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
        "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
        "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
        "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
        "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
        "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
        "Now consider an arbitrary y ∈ Y such that y = yc .",
        "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
        "Thus, moving to case II, job y must replace some other job before tc .",
        "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
        "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
        "That is, the job that y replaces must be i.",
        "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
        "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
        "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
        "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
        "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
        "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
        "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
        "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
        "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
        "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
        "Lemma 3.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
        "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
        "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
        "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
        "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
        "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
        "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
        "Assume by contradiction that this condition does not hold.",
        "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
        "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
        "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
        "Lemma 5.",
        "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
        "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
        "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
        "We can now combine the lemmas to show that no profitable deviation is possible.",
        "Theorem 6.",
        "Mechanism Γ1 satisfies incentive compatibility.",
        "Proof.",
        "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
        "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
        "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
        "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
        "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
        "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
        "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
        "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
        "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
        "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
        "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
        "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
        "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
        "Also, let tbegin f be the first time that the processor is not idle in interval If .",
        "Lemma 7.",
        "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
        "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
        "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
        "Let ts i be the time that job i begins execution.",
        "Note that ts 1 = tbegin f .",
        "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
        "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
        "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
        "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
        "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
        "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
        "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
        "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
        "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
        "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
        "We now consider the possible execution of uncompleted jobs by Γoffline.",
        "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
        "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
        "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
        "Lemma 8.",
        "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
        "Proof.",
        "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
        "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
        "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
        "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
        "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
        "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
        "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
        "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
        "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
        "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
        "We can now combine the results of these lemmas to prove the competitive ratio.",
        "Theorem 10.",
        "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
        "Proof.",
        "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
        "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
        "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
        "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
        "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
        "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
        "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
        "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
        "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
        "Theorem 12.",
        "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
        "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
        "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
        "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
        "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
        "Unlike IC and IR, this requirement is not standard in mechanism design.",
        "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
        "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
        "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
        "Lemma 13.",
        "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
        "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
        "Proof.",
        "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
        "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
        "First, we will construct a profile of agent types θ using an adversary argument.",
        "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
        "We now construct the original profile θ.",
        "Pick an α such that 0 < α < , and define δ = α ck+3k .",
        "The adversary uses two sequences of jobs: minor and major.",
        "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
        "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
        "The sequence stops whenever Γ completes any job.",
        "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
        "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
        "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
        "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
        "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
        "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
        "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
        "If f < m, then major job f + 1 will be released and it will be the final major job.",
        "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
        "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
        "We now possibly perturb θ slightly.",
        "By IR, we know that vf ≥ pf (θ).",
        "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
        "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
        "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
        "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
        "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
        "Thus, for the remainder of the proof, assume that vf > pf (θ).",
        "We now use a more substantial perturbation of θ to complete the proof.",
        "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
        "If f = m, then instead set df = df +lf .",
        "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
        "Assume by contradiction that this were not true.",
        "Then, at the original deadline of df , job f is not completed.",
        "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
        "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
        "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
        "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
        "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
        "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
        "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
        "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
        "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
        "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
        "Mechanism design was also applied to a scheduling problem in [18].",
        "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
        "The private information of an agent is the time it will require to execute each job.",
        "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
        "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
        "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
        "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
        "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
        "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
        "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
        "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
        "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
        "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
        "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
        "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
        "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
        "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
        "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
        "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
        "Several open problems remain in this setting.",
        "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
        "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
        "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
        "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
        "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
    ],
    "error_count": 0,
    "keys": {
        "online scheduling of job": {
            "translated_key": "programación en línea del trabajo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of <br>online scheduling of job</br>s on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Introducción Consideramos el problema de la \"programación en línea del trabajo\" en un solo procesador."
            ],
            "translated_text": "",
            "candidates": [
                "Programación en línea de trabajo",
                "programación en línea del trabajo"
            ],
            "error": []
        },
        "job online scheduling": {
            "translated_key": "Programación de trabajo en línea",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "competitive ratio": {
            "translated_key": "relación competitiva",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the <br>competitive ratio</br> that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the <br>competitive ratio</br> by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the <br>competitive ratio</br>: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the <br>competitive ratio</br> for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a <br>competitive ratio</br> of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the <br>competitive ratio</br>.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this <br>competitive ratio</br> is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a <br>competitive ratio</br> of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite <br>competitive ratio</br> [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the <br>competitive ratio</br>).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the <br>competitive ratio</br>. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the <br>competitive ratio</br>.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of <br>competitive ratio</br> The proof of the <br>competitive ratio</br>, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the <br>competitive ratio</br> it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the <br>competitive ratio</br>.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the <br>competitive ratio</br> by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the <br>competitive ratio</br> holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a <br>competitive ratio</br> of 5 (which is the same <br>competitive ratio</br> as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the <br>competitive ratio</br> of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a <br>competitive ratio</br> less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a <br>competitive ratio</br> of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a <br>competitive ratio</br> of c implies a <br>competitive ratio</br> of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired <br>competitive ratio</br>, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired <br>competitive ratio</br>, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the <br>competitive ratio</br> is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The <br>competitive ratio</br> is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible <br>competitive ratio</br> had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the <br>competitive ratio</br> by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the <br>competitive ratio</br> that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Diseño del mecanismo para la programación en tiempo real en línea Ryan Porter ∗ Departamento de informática de la Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu Resumen Para el problema de la programación de trabajos en línea en tiempo real en un solo procesador, el trabajo anterior presenta límites superiores e inferiores.en la \"relación competitiva\" que se puede lograr mediante un algoritmo determinista.",
                "Para el problema de diseño del mecanismo resultante (en el que también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, al tiempo que aumenta la \"relación competitiva\" por uno.",
                "Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la \"relación competitiva\": la relación del valor de los trabajos completados por un algoritmo óptimo de O ﬄ ine al valor de los completados por el algoritmo en línea.",
                "Para K = 1, [4] presenta un algoritmo de 4 competitivo, y demuestra que este es un límite más bajo en la \"relación competitiva\" para los algoritmos deterministas.",
                "Por lo tanto, para lograr una \"relación competitiva\" de C, un mecanismo en línea debe ser compatible con incentivos, y siempre lograr al menos 1 c del valor que el mecanismo óptimo o ﬄ ine logra en la misma secuencia de trabajos.",
                "En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + √ k) 2 + 1), y demostramos formalmente la compatibilidad de incentivos y la \"relación competitiva\".",
                "Al devolver el entorno general, mostramos en la Sección 5 que esta \"relación competitiva\" es un límite más bajo para los mecanismos deterministas que no pagan a los agentes.",
                "También se dice que un algoritmo que es competitivo en C alcanza una \"relación competitiva\" de c.Suponemos que no existe un período de sobrecarga de duración infinita.",
                "Sin tal suposición, no es posible lograr una \"relación competitiva\" finita [15].2.2 Resultados anteriores en la configuración no estratégica, [4] presenta un algoritmo competitivo de 4 llamado TD1 (Versión 2) para el caso de K = 1, mientras que [15] presenta un algoritmo competitivo de 2 (1+ √ k) llamadoDover para el caso general de K ≥ 1.",
                "Debido a que en general este trabajo podría tener laxitud, el algoritmo O ﬄ ine puede completarlo fuera del rango [TB, TE] .1 Si el algoritmo completa el trabajo activo y esta duración de los trabajos es al menos TE -TB +P Pérdida 4 4Luego, se garantiza que el algoritmo es 4 competitivo para este intervalo (tenga en cuenta que K = 1 implica que todos los trabajos tienen la misma densidad de valor y, por lo tanto, esas longitudes pueden usarse para calcular la \"relación competitiva\")."
            ],
            "translated_text": "",
            "candidates": [
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "Relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva"
            ],
            "error": []
        },
        "deterministic algorithm": {
            "translated_key": "algoritmo determinista",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a <br>deterministic algorithm</br>.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Diseño del mecanismo para la programación en tiempo real en línea Ryan Porter ∗ Departamento de informática de la Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu Resumen Para el problema de la programación de trabajos en línea en tiempo real en un solo procesador, el trabajo anterior presenta límites superiores e inferiores.en la relación competitiva que se puede lograr mediante un \"algoritmo determinista\"."
            ],
            "translated_text": "",
            "candidates": [
                "algoritmo determinista",
                "algoritmo determinista"
            ],
            "error": []
        },
        "non-strategic setting": {
            "translated_key": "configuración no estratégica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the <br>non-strategic setting</br> in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the <br>non-strategic setting</br>), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the <br>non-strategic setting</br>.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, <br>non-strategic setting</br>.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "<br>non-strategic setting</br> In this section, we formally define the original, <br>non-strategic setting</br>, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the <br>non-strategic setting</br>, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the <br>non-strategic setting</br> it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the <br>non-strategic setting</br>: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the <br>non-strategic setting</br>, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Sin embargo, estos resultados solo se aplican a la \"configuración no estratégica\" en la que los trabajos se liberan directamente al algoritmo.",
                "Para el problema de diseño del mecanismo resultante (en el que también fortalecemos ligeramente una suposición del \"entorno no estratégico\"), presentamos un mecanismo que aborda cada problema de incentivos, mientras que solo aumenta la relación competitiva por uno.",
                "Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un problema que no se aborda en el \"entorno no estratégico\".",
                "En la Sección 2, definimos y revisamos formalmente los resultados de la \"configuración no estratégica original\".",
                "\"Configuración no estratégica\" En esta sección, definimos formalmente la \"configuración no estratégica\" original y recapitulamos los resultados anteriores.2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutar, y n trabajos, aunque este número no se conoce de antemano.",
                "Sin tal suposición, no es posible lograr una relación competitiva finita [15].2.2 Resultados anteriores en la \"configuración no estratégica\", [4] presenta un algoritmo de 4 competitivo llamado TD1 (Versión 2) para el caso de K = 1, mientras que [15] presenta un (1+ √ K) 2-competitivoAlgoritmo llamado Dover para el caso general de K ≥ 1.",
                "Mientras que en la \"configuración no estratégica\" fue suficiente para el algoritmo conocer la K de límite superior en la relación ρmax ρmin, en la configuración del diseño del mecanismo fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, equivalente, elrango [ρmin, ρmax] de posibles densidades de valor) .3 Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo.",
                "Finalmente, la función de bienestar social que nuestro objetivo es maximizar es la misma que la función objetivo de la \"configuración no estratégica\": W (O, θ) = I vi · µ (Ei (θ, Di) ≥ Li).",
                "La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k) 2 en el \"entorno no estratégico\", con la novedad principal en la perturbación de la perturbación deSecuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados."
            ],
            "translated_text": "",
            "candidates": [
                "configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "entorno no estratégico",
                "configuración no estratégica",
                "entorno no estratégico",
                "configuración no estratégica",
                "configuración no estratégica original",
                "configuración no estratégica",
                "Configuración no estratégica",
                "configuración no estratégica",
                "Configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "configuración no estratégica",
                "entorno no estratégico"
            ],
            "error": []
        },
        "deadline": {
            "translated_key": "fecha límite",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and <br>deadline</br> for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a <br>deadline</br>, a processing time, and a value for successful completion by its <br>deadline</br>.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and <br>deadline</br> for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and <br>deadline</br>.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, <br>deadline</br>, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each <br>deadline</br> is firm (or, hard), which means that no value is obtained for a job that is completed after its <br>deadline</br>.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its <br>deadline</br>.",
                "A job is abandoned if it cannot be completed by its <br>deadline</br> (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and <br>deadline</br> both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest <br>deadline</br> of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s <br>deadline</br> were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true <br>deadline</br>) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary <br>deadline</br> or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later <br>deadline</br>) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true <br>deadline</br>.",
                "This is the reason why it is important to always return a completed job at its declared <br>deadline</br>, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared <br>deadline</br> are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and <br>deadline</br>.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true <br>deadline</br>.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the <br>deadline</br> of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original <br>deadline</br> of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its <br>deadline</br>, which is by construction at least as late as the new <br>deadline</br> df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, <br>deadline</br>, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El agente puede retrasar la liberación del trabajo al algoritmo, inflar su longitud y declarar un valor arbitrario y \"fecha límite\" para el trabajo, mientras que el centro determina no solo el cronograma, sino el pago de cada agente.",
                "Cada trabajo se caracteriza por un tiempo de lanzamiento, una \"fecha límite\", un tiempo de procesamiento y un valor para la finalización exitosa por su \"fecha límite\".",
                "Cada agente ahora tiene cuatro formas diferentes en que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo de liberación real, puede inflar artificialmente la duración del trabajo y puede declarar un valor arbitrario y \"Fecha límite \"para el trabajo.",
                "Un concepto básico de solución del diseño del mecanismo es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre sea de cada agente el mejor interés enviar inmediatamente su trabajo al liberar y declarar sinceramente su valor, longitud y \"fecha límite\".",
                "Cada trabajo I se caracteriza por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la \"fecha límite\", la duración del tiempo de procesamiento requerida y el valor, respectivamente.",
                "Cada \"fecha límite\" es firme (o, difícil), lo que significa que no se obtiene ningún valor para un trabajo que se completa después de su \"fecha límite\".",
                "Se define una laxitud de empleos en el momento t para ser di - t - li + ei (t), la cantidad de tiempo que puede permanecer inactiva y aún completar su \"fecha límite\".",
                "Un trabajo se abandona si no puede completarse por su \"fecha límite\" (formalmente, si di −t+ei (t) <li).",
                "Un período de tiempo [TS, TF] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y \"fecha límite\" cae dentro del período de tiempo excede la duración del intervalo (formalmente, si Tf −ts ≤ i | ((ts≤ri, di≤tf) li).",
                "El primero registra la última \"fecha límite\" de un trabajo que sería abandonado si el trabajo activo se ejecuta para su finalización (o, si no existe dicho trabajo, el momento en que el trabajo activo terminará si no está previsto)."
            ],
            "translated_text": "",
            "candidates": [
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "Fecha límite ",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite",
                "fecha límite"
            ],
            "error": []
        },
        "importance ratio": {
            "translated_key": "relación de importancia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The <br>importance ratio</br> is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the <br>importance ratio</br>.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La \"relación de importancia\" se define como ρmax ρmin, la relación máxima de densidades de valor entre dos trabajos.",
                "Se supone que el algoritmo siempre conoce una K superior en la \"relación de importancia\"."
            ],
            "translated_text": "",
            "candidates": [
                "relación de importancia",
                "relación de importancia",
                "relación de importancia",
                "relación de importancia"
            ],
            "error": []
        },
        "zero laxity": {
            "translated_key": "laxitud cero",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has <br>zero laxity</br>.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with <br>zero laxity</br>.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have <br>zero laxity</br> at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and <br>zero laxity</br>.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have <br>zero laxity</br>, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has <br>zero laxity</br>, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El primer trabajo activo de un intervalo puede tener laxitud;Sin embargo, para el resto del intervalo, la preferencia del trabajo activo solo se considera cuando algún otro trabajo tiene \"laxitud cero\".",
                "Antes de que el trabajo 2 pueda finalizar, la prevención se considera en el momento 4.8, cuando el trabajo 3 se libera con \"cero laxitud\".",
                "Por ejemplo, si la fecha límite de trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría \"laxitud cero\" en el momento 0.7.",
                "Los trabajos menores I se caracterizan por li = δ, vi = k · δ y \"laxitud cero\".",
                "Los trabajos principales también tienen \"laxitud cero\", pero tienen la relación de valor más pequeña posible (es decir, vi = li).",
                "Considere el perfil posible (θf, θ - f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene \"cero laxitud\", rx = df y vx = lx = max (df - df,(C + 1) · (LF + LF + 1))."
            ],
            "translated_text": "",
            "candidates": [
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "cero laxitud",
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "laxitud cero",
                "cero laxitud"
            ],
            "error": []
        },
        "online algorithm": {
            "translated_key": "algoritmo en línea",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the <br>online algorithm</br> and an adversary.",
                "First, the designer selects the <br>online algorithm</br>.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the <br>online algorithm</br>.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An <br>online algorithm</br> is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the <br>online algorithm</br> must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an <br>online algorithm</br> is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An <br>online algorithm</br> f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the <br>online algorithm</br> uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an <br>online algorithm</br> into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Una interpretación de este enfoque es como un juego entre el diseñador del \"algoritmo en línea\" y un adversario.",
                "Primero, el diseñador selecciona el \"Algoritmo en línea\".",
                "Luego,",
                "Un \"algoritmo en línea\" es una función F: θ1 ×...× θn → O que mapea el vector de tuplas (para cualquier número n) a un resultado o.",
                "Dado que un trabajo no se puede ejecutar antes de su tiempo de liberación, el espacio de posibles resultados está restringido en el que s (θ, t) = I implica ri ≤ t.Además, debido a que el \"algoritmo en línea\" debe producir el cronograma a lo largo del tiempo, sin conocimiento de insumos futuros, debe tomar la misma decisión en el tiempo t para las entradas que son indistinguibles en este momento.",
                "En el análisis competitivo, se evalúa un \"algoritmo en línea\" comparándolo con un algoritmo ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ.",
                "Un \"algoritmo en línea\" f (·) es (estrictamente) C competitivo si no existe una entrada θ tal que c · w (f (θ), θ) <w ∗ (θ).",
                "El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el \"algoritmo en línea\" utiliza un procesador más rápido que el algoritmo O ﬄ ine (ver, por ejemplo, [13, 14]).",
                "En [2], se presenta un método general para convertir un \"algoritmo en línea\" en un mecanismo en línea que sea compatible con el incentivo con respecto a los valores."
            ],
            "translated_text": "",
            "candidates": [
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "Algoritmo en línea",
                "el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo optim ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄalgoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea"
            ],
            "error": []
        },
        "quasi-linear function": {
            "translated_key": "función cuasi-lineal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a <br>quasi-linear function</br> of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Cada utilidad de agentes, ui (g (ˆθ), θi) = vi · µ (ei (ˆθ, di) ≥ li) · µ (ˆdi ≤ di)-pi (ˆθ), es una \"función cuasi-lineal\" de suValor para su trabajo (si está completado y devuelto por su verdadero plazo) y el pago que realiza al Centro."
            ],
            "translated_text": "",
            "candidates": [
                "función cuasi-lineal",
                "función cuasi-lineal"
            ],
            "error": []
        },
        "deterministic mechanism": {
            "translated_key": "mecanismo determinista",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a <br>deterministic mechanism</br> that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Luego mostramos un límite inferior coincidente en la relación competitiva que puede lograrse mediante un \"mecanismo determinista\" que nunca paga a los agentes."
            ],
            "translated_text": "",
            "candidates": [
                "mecanismo determinista",
                "mecanismo determinista"
            ],
            "error": []
        },
        "incentive compatibility": {
            "translated_key": "compatibilidad con incentivos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is <br>incentive compatibility</br>, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove <br>incentive compatibility</br> and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of <br>incentive compatibility</br> and individual rationality.",
                "The condition for (dominant strategy) <br>incentive compatibility</br> is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies <br>incentive compatibility</br> (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for <br>incentive compatibility</br> is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and <br>incentive compatibility</br>, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies <br>incentive compatibility</br> and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and <br>incentive compatibility</br> After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies <br>incentive compatibility</br>.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and <br>incentive compatibility</br>.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure <br>incentive compatibility</br>. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related <br>incentive compatibility</br> arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting <br>incentive compatibility</br> by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar <br>incentive compatibility</br> argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of <br>incentive compatibility</br> in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un concepto básico de solución del diseño del mecanismo es la \"compatibilidad de incentivos\", que, en nuestro entorno, requiere que siempre esté en el mejor interés de cada agente presentar inmediatamente su trabajo al liberar y declarar sinceramente su valor, longitud y fecha límite.",
                "En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + √ k) 2 + 1), y demostramos formalmente \"compatibilidad de incentivos\" y la relación competitiva.",
                "La configuración se puede resumir de la siguiente manera.1 Overview de la configuración: para todo T, el centro instancia s (ˆθ, t) ← i, para algunos i s.t.ˆRi ≤ t if ∃i, (ri = t) entonces θi se revela al agente I si ∃i, (t ≥ ri) y el agente I no ha declarado un trabajo, entonces el agente puedo declarar cualquier trabajo ˆθi, s.t.ˆRi = t y ˆli ≥ li if ∃i, (ˆdi = t) ∧ (ei (ˆθ, t) ≥ li) luego el trabajo completado I se devuelve al agente I si ∃i, (ˆdi = t) luego se establece el centro y recogePAGO PI (ˆθ) Del Agente I 3.2 Objetivos del mecanismo Nuestro objetivo como diseñador de mecanismo es maximizar el valor de los trabajos completos, sujeto a las limitaciones de \"compatibilidad de incentivos\" y racionalidad individual.",
                "La condición para la \"estrategia dominante)\" compatibilidad de incentivos \"es que para cada agente I, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puedo aumentar su utilidad cambiando unilateralmente su declaración.",
                "Un mecanismo directo γ satisface la \"compatibilidad de incentivos\" (ic) si ∀i, θi, θi, ˆθ - i: ui (g (θi, ˆθ -i), θi) ≥ ui (g (θi, ˆθ - i), θi)) Desde una perspectiva del agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de los tipos de otros agentes se extraen.",
                "Por estas razones, en este documento requerimos estrategias dominantes, en oposición a un concepto de equilibrio más débil, como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 Disminución del límite inferior en la relación competitiva.4 Un posible argumento contra la necesidad de \"compatibilidad con incentivos\" es que una mentira de agentes en realidad puede mejorar el horario.",
                "Después de proporcionar cierta intuición de por qué γ1 satisface la racionalidad individual y la \"compatibilidad de incentivos\", demostramos formalmente primero estas dos propiedades y luego la relación competitiva.",
                "Sin embargo, esto no afectaría nuestros resultados, ya que la ejecución de un mecanismo VCG (ver, por ejemplo, [17]) en el momento 0 satisface la \"compatibilidad de incentivos\" y siempre maximiza el bienestar social.64 Mecanismo 1 γ1 Ejecutar s (ˆθ, ·) según el algoritmo 1 para todo lo que hago si ei (ˆθ, ˆdi) ≥ ˆli {agente es el trabajo que se completa} entonces pi (ˆθ) ← arg minvi≥0 (ei (((((((((((((((((((ei (ei ((ei ((ei ((ei (((ei ((ei ((ei ((ei (((eiˆRi, ˆdi, ˆli, vi), ˆθ -i), ˆdi) ≥ ˆli) else Pi (ˆθ) ← 0 Algoritmo 1 Para todos los to HACE ← {i | (t ≥ ˆri) ∧ (ei (ˆθ, t)<ˆLi) ∧ (ei (ˆθ, t)+ ˆdi-t ≥ ˆli)} {conjunto de todos los trabajos liberados, no completados, no abandonados} si disponibles = ∅ entonces s (ˆθ, t) ← arg maxi∈Atail(ˆVi + √ k · ei (ˆθ, t) · ρmin) {rompa lazos a favor de ˆri} más s (ˆθ, t) ← 0 Sigue a argumentar por qué un agente no tiene incentivos para empeorar su trabajo.",
                "Estas dos propiedades juntas implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador.4.1 Prueba de racionalidad individual y \"compatibilidad de incentivos\" Después de presentar la prueba (trivial) de IR, dividimos la prueba de IC en Lemmas.",
                "El mecanismo γ1 satisface la \"compatibilidad de incentivos\"."
            ],
            "translated_text": "",
            "candidates": [
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "estrategia dominante)",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad con incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos",
                "compatibilidad con incentivos",
                "compatibilidad de incentivos"
            ],
            "error": []
        },
        "individual rationality": {
            "translated_key": "racionalidad individual",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and <br>individual rationality</br>.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, <br>individual rationality</br>, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies <br>individual rationality</br> (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies <br>individual rationality</br> and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of <br>individual rationality</br> and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies <br>individual rationality</br>.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies <br>individual rationality</br> and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La configuración se puede resumir de la siguiente manera.1 Overview de la configuración: para todo T, el centro instancia s (ˆθ, t) ← i, para algunos i s.t.ˆRi ≤ t if ∃i, (ri = t) entonces θi se revela al agente I si ∃i, (t ≥ ri) y el agente I no ha declarado un trabajo, entonces el agente puedo declarar cualquier trabajo ˆθi, s.t.ˆRi = t y ˆli ≥ li if ∃i, (ˆdi = t) ∧ (ei (ˆθ, t) ≥ li) luego el trabajo completado I se devuelve al agente I si ∃i, (ˆdi = t) luego se establece el centro y recogePago PI (ˆθ) del Agente I 3.2 Objetivos del mecanismo Nuestro objetivo como diseñador de mecanismo es maximizar el valor de los trabajos completos, sujeto a las limitaciones de la compatibilidad de incentivos y la \"racionalidad individual\".",
                "El segundo objetivo para nuestro mecanismo, \"racionalidad individual\", requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa.",
                "Un mecanismo directo γ satisface la \"racionalidad individual\" (ir) si ∀i, θi, ˆθ - i, ui (g (θi, ˆθ -i), θi) ≥ 0.",
                "Después de proporcionar cierta intuición de por qué γ1 satisface la \"racionalidad individual\" y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la relación competitiva.",
                "Estas dos propiedades juntas implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador.4.1 Prueba de \"racionalidad individual\" y compatibilidad de incentivos después de presentar la prueba (trivial) de IR, dividimos la prueba de IC en Lemmas.",
                "El mecanismo γ1 satisface la \"racionalidad individual\".",
                "Cuando K = 1, y cada agente no puedo declarar falsamente Li, el mecanismo γ2 satisface la \"racionalidad individual\" y la compatibilidad de incentivos."
            ],
            "translated_text": "",
            "candidates": [
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual"
            ],
            "error": []
        },
        "profitable deviation": {
            "translated_key": "desviación rentable",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no <br>profitable deviation</br> is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Ahora podemos combinar los lemas para mostrar que no es posible una \"desviación rentable\"."
            ],
            "translated_text": "",
            "candidates": [
                "desviación rentable",
                "desviación rentable"
            ],
            "error": []
        },
        "monotonicity": {
            "translated_key": "monotonicidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying <br>monotonicity</br>, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Una vez más, aplicando \"monotonicidad\", esto implicaría que la prioridad del trabajo activo en TClose F excede (1 + √ k) VF, contradiciendo el hecho de que es (1 + √ k) VF."
            ],
            "translated_text": "",
            "candidates": [
                "monotonicidad",
                "monotonicidad"
            ],
            "error": []
        },
        "mechanism design": {
            "translated_key": "diseño del mecanismo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>mechanism design</br> for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting <br>mechanism design</br> problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of <br>mechanism design</br> [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and <br>mechanism design</br> (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of <br>mechanism design</br> is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the <br>mechanism design</br> setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "<br>mechanism design</br> SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a <br>mechanism design</br> problem.",
                "In this section we first present the <br>mechanism design</br> formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard <br>mechanism design</br> setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the <br>mechanism design</br> setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in <br>mechanism design</br>.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "<br>mechanism design</br> was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic <br>mechanism design</br>, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing <br>mechanism design</br> (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic <br>mechanism design</br>, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic <br>mechanism design</br>: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online <br>mechanism design</br>, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic <br>mechanism design</br>, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "\"Diseño de mecanismo\" para la programación en tiempo real en línea Ryan Porter ∗ Departamento de informática de la Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu Resumen para el problema de la programación de trabajos en línea en tiempo real en un solo procesador, el trabajo previo presenta la coincidencia de y la parte superior yLímites inferiores en la relación competitiva que se puede lograr mediante un algoritmo determinista.",
                "Para el problema resultante de \"diseño de mecanismo\" (en el que también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, al tiempo que aumenta la relación competitiva por uno.",
                "La adición de agentes interesados en sí mismo mueve el problema del área del diseño del algoritmo al del \"diseño de mecanismo\" [17], la ciencia de la elaboración de protocolos de los agentes interesados.",
                "Los últimos años han visto mucha actividad en la interfaz de la informática y el \"diseño del mecanismo\" (ver, por ejemplo, [9, 18, 19]).",
                "Un concepto de solución básica de \"diseño de mecanismo\" es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre sea de cada interés, lo mejor de los agentes, presentar su trabajo inmediatamente al liberar y declarar sinceramente su valor, longitud y fecha límite.",
                "Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos la configuración del \"diseño del mecanismo\" en la Sección 3.",
                "Configuración del \"diseño del mecanismo\" Sin embargo, la información falsa sobre el trabajo 2 causaría que TD1 (versión 2) complete este trabajo.",
                "El trabajo 2 se completaría antes de la llegada del trabajo 3.2 1, mientras que sería fácil alterar el algoritmo reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida de P.2 Si bien no describiremos lo significativamente más complejo para abordar problemas de incentivos como este, necesitamos formalizar la configuración como un problema de \"diseño de mecanismo\".",
                "En esta sección primero presentamos la formulación del \"diseño del mecanismo\" y luego definimos nuestros objetivos para el mecanismo.3.1 Formulación Existe un centro, que controla el procesador y los agentes de N, donde el centro es desconocido por el centro de antemano.",
                "En una configuración estándar de \"diseño de mecanismo\", el resultado se aplica al final del mecanismo."
            ],
            "translated_text": "",
            "candidates": [
                "diseño de mecanismo",
                "Diseño de mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño del mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "Diseño del mecanismo",
                "diseño del mecanismo",
                "diseño de mecanismo",
                "diseño del mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo",
                "diseño del mecanismo",
                "diseño de mecanismo",
                "diseño de mecanismo"
            ],
            "error": []
        },
        "game theory": {
            "translated_key": "teoría de juego",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "schedule": {
            "translated_key": "horario",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the <br>schedule</br>, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the <br>schedule</br> must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only <br>schedule</br> jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a <br>schedule</br> for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a <br>schedule</br> of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the <br>schedule</br> over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the <br>schedule</br> into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a <br>schedule</br> and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the <br>schedule</br> is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the <br>schedule</br>.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the <br>schedule</br> the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the <br>schedule</br>, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not <br>schedule</br> a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must <br>schedule</br> jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El agente puede retrasar la liberación del trabajo al algoritmo, inflar su longitud y declarar un valor arbitrario y una fecha límite para el trabajo, mientras que el centro determina no solo el \"horario\", sino el pago de cada agente.",
                "El desafío clave en este entorno en línea es que el \"horario\" debe construirse en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento.",
                "Además, los vendedores no solo \"programan\" trabajos, sino que también determinan la cantidad que cobran a los compradores, un problema que no se aborda en el entorno no estratégico.",
                "En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un \"horario\" para los trabajos, y cada agente realiza un pago al centro.",
                "Un resultado o ∈ O es simplemente un \"horario\" de trabajos en el procesador, registrado por la función S: + → {0, 1 ,..., N}, que mapea cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo.",
                "Dado que un trabajo no se puede ejecutar antes de su tiempo de liberación, el espacio de posibles resultados está restringido en el que s (θ, t) = I implica ri ≤ t.Además, debido a que el algoritmo en línea debe producir el \"cronograma\" con el tiempo, sin conocimiento de insumos futuros, debe tomar la misma decisión en el tiempo t para las entradas que son indistinguibles en este momento.",
                "TD1 (Versión 2) divide el \"Anexo\" en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a esta TB TB) y termina con la finalización de un trabajo.",
                "Un resultado O = (S (·), P1, ..., PN) consiste en un \"horario\" y un pago de cada agente al mecanismo.",
                "La restricción en el \"horario\" es ahora que s (ˆθ, t) = I implica ˆri ≤ t, para capturar el hecho de que un trabajo no puede programarse en el procesador antes de que se declare al mecanismo.",
                "Por estas razones, en este documento requerimos estrategias dominantes, en oposición a un concepto de equilibrio más débil, como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 Disminución del límite inferior en la relación competitiva.4 Un posible argumento contra la necesidad de compatibilidad con incentivos es que una mentira de los agentes en realidad puede mejorar el \"horario\"."
            ],
            "translated_text": "",
            "candidates": [
                "cronograma",
                "horario",
                "cronograma",
                "horario",
                "cronograma",
                "programan",
                "cronograma",
                "horario",
                "cronograma",
                "horario",
                "cronograma",
                "cronograma",
                "cronograma",
                "Anexo",
                "cronograma",
                "horario",
                "cronograma",
                "horario",
                "cronograma",
                "horario"
            ],
            "error": []
        }
    }
}